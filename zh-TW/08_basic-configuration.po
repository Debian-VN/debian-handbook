# AUTHOR <EMAIL@ADDRESS>, YEAR.
msgid ""
msgstr ""
"Project-Id-Version: 0\n"
"POT-Creation-Date: 2015-10-06 16:10+0200\n"
"PO-Revision-Date: 2016-07-25 01:43+0000\n"
"Last-Translator: mao <mao@lins.fju.edu.tw>\n"
"Language-Team: Traditional Chinese <https://hosted.weblate.org/projects/debian-handbook/08_basic-configuration/zh_Hant/>\n"
"Language: zh-TW\n"
"MIME-Version: 1.0\n"
"Content-Type: application/x-publican; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 2.8-dev\n"

msgid "Configuration"
msgstr "組態"

msgid "Localization"
msgstr "在地化"

msgid "Locales"
msgstr "地區設定"

msgid "Network"
msgstr "網路"

msgid "Name resolution"
msgstr "名稱解析"

msgid "Users"
msgstr "使用者"

msgid "Groups"
msgstr "群組"

msgid "Accounts"
msgstr "帳號"

msgid "Command-line interpreter"
msgstr "命令列解析器"

msgid "Shell"
msgstr "Shell"

msgid "Printing"
msgstr "列印"

msgid "Bootloader"
msgstr "啟動程式"

msgid "Kernel compiling"
msgstr "編譯核心"

msgid "Basic Configuration: Network, Accounts, Printing..."
msgstr "基本組態：網路、帳號、列印..."

msgid "A computer with a new installation created with <command>debian-installer</command> is intended to be as functional as possible, but many services still have to be configured. Furthermore, it is always good to know how to change certain configuration elements defined during the initial installation process."
msgstr "以 <command>debian-installer</command> 命令安裝的電腦是儘可能的可用，但仍有若干服務需要組態。而且，瞭解修改初始安裝程序的組態是件好事。"

msgid "This chapter reviews everything included in what we could call the “basic configuration”: networking, language and locales, users and groups, printing, mount points, etc."
msgstr "本章包括所有的 “基本組態”：網路、語系與地區設定、列印、掛載點等。"

msgid "Configuring the System for Another Language"
msgstr "組態系統供其他語系使用"

msgid "<primary>French localization</primary>"
msgstr "<primary>法文在地化</primary>"

msgid "If the system was installed using French, the machine will probably already have French set as the default language. But it is good to know what the installer does to set the language, so that later, if the need arises, you can change it."
msgstr "選擇法語介面安裝系統，則可能已經把法語當成預設語言。但是瞭解安裝器安裝語系的方法，需要發生時，就可以變更語系。"

msgid "<emphasis>TOOL</emphasis> The <command>locale</command> command to display the current configuration"
msgstr "<emphasis>工具</emphasis> 此 <command>locale</command> 命令顯示當前的組態"

msgid "The <command>locale</command> command lists a summary of the current configuration of various locale parameters (date format, numbers format, etc.), presented in the form of a group of standard environment variables dedicated to the dynamic modification of these settings."
msgstr "<command>locale</command> 命令列出地區設定參數的當前語系組態 (日期格式、數字格式等)，以一組標準的環境變數表示這些設定的動態修改。"

msgid "Setting the Default Language"
msgstr "設定預設語系"

msgid "<primary>locales</primary>"
msgstr "<primary>locales</primary>"

msgid "<primary>language</primary>"
msgstr "<primary>語系</primary>"

msgid "<primary><command>locale-gen</command></primary>"
msgstr "<primary><command>locale-gen</command></primary>"

msgid "A locale is a group of regional settings. This includes not only the language for text, but also the format for displaying numbers, dates, times, and monetary sums, as well as the alphabetical comparison rules (to properly account for accented characters). Although each of these parameters can be specified independently from the others, we generally use a locale, which is a coherent set of values for these parameters corresponding to a “region” in the broadest sense. These locales are usually indicated under the form, <literal><replaceable>language-code</replaceable>_<replaceable>COUNTRY-CODE</replaceable></literal>, sometimes with a suffix to specify the character set and encoding to be used. This enables consideration of idiomatic or typographical differences between different regions with a common language."
msgstr "地區設定是一組區域設定。不祗是語文，還包括顯示的數字、日期、時間、貨幣與字母對照表 (針對重音符號)。雖然這些參數可以各別設定，我們還是習慣以一個區域設定處理全部事宜，廣義上符合 “地區” 的一組設定值就搞定。這些地區設定以相同形式表現，<literal><replaceable>語文代碼</replaceable>_<replaceable>國家代碼</replaceable></literal>，有時加上後置詞指明使用的編碼。這種方式可以呈現同個語文在不同地區的慣用語或用字。"

msgid "<emphasis>CULTURE</emphasis> Character sets"
msgstr "<emphasis>文字</emphasis> 字元集"

msgid "<primary>character set</primary>"
msgstr "<primary>字元集</primary>"

msgid "<primary>encoding</primary>"
msgstr "<primary>編碼</primary>"

msgid "<primary>ISO-8859-1</primary>"
msgstr "<primary>ISO-8859-1</primary>"

msgid "<primary>ISO-8859-15</primary>"
msgstr "<primary>ISO-8859-15</primary>"

msgid "<primary>Latin 1</primary>"
msgstr "<primary>Latin 1</primary>"

msgid "<primary>Latin 9</primary>"
msgstr "<primary>Latin 9</primary>"

msgid "Historically, each locale has an associated “character set” (group of known characters) and a preferred “encoding” (internal representation for characters within the computer)."
msgstr "過去，每個地區都對應一組 “字元集” (已知字元的集合) 與偏好的 “編碼” (電腦內表示字元的方法)。"

msgid "The most popular encodings for latin-based languages were limited to 256 characters because they opted to use a single byte for each character. Since 256 characters was not enough to cover all European languages, multiple encodings were needed, and that is how we ended up with <emphasis>ISO-8859-1</emphasis> (also known as “Latin 1”) up to <emphasis>ISO-8859-15</emphasis> (also known as “Latin 9”), among others."
msgstr "最常見的編碼是拉丁基礎的語言限於256個字元，因為每個字元祗用到一個位元組。256個字元顯然不夠所有的歐洲語系使用，需要多編碼，所以出現 <emphasis>ISO-8859-1</emphasis> (也稱為 “Latin 1”) 至 <emphasis>ISO-8859-15</emphasis> (也稱為 “Latin 9”)，以及其他的編碼方式。"

msgid "Working with foreign languages often implied regular switches between various encodings and character sets. Furthermore, writing multilingual documents led to further, almost intractable problems. Unicode (a super-catalog of nearly all writing systems from all of the world's languages) was created to work around this problem. One of Unicode's encodings, UTF-8, retains all 128 ASCII symbols (7-bit codes), but handles other characters differently. Those are preceded by a specific escape sequence of a few bits, which implicitly defines the length of the character. This allows encoding all Unicode characters on a sequence of one or more bytes. Its use has been popularized by the fact that it is the default encoding in XML documents."
msgstr "在英文以外的語系工作，經常需要切換編碼與字元集。尤有甚者，撰寫多語系文件還會碰到極為頑固的問題。Unicode (幾乎包括全世界所有書寫系統的編碼) 就是用來解決此等問題。UTF-8 是 Unicode 的編碼之一，仍是 128 ASCII 符號 (7-位元代碼)，但以不同方式處理其他字元。以逸出字元為首的數個位元帶頭，設定字元的長度。此種方法允許 Unicode 字元以一個或多個位元組呈現。已是 XML 文件的預設編碼方式。"

msgid "<primary>ASCII</primary>"
msgstr "<primary>ASCII</primary>"

msgid "<primary>UTF-8</primary>"
msgstr "<primary>UTF-8</primary>"

msgid "<primary>Unicode</primary>"
msgstr "<primary>Unicode</primary>"

msgid "This is the encoding that should generally be used, and is thus the default on Debian systems."
msgstr "就是這個編碼表最常用，Debian 系統把它做為預設值。"

msgid "The <emphasis role=\"pkg\">locales</emphasis> package includes all the elements required for proper functioning of “localization” of various applications. During installation, this package will ask to select a set of supported languages. This set can be changed at any time by running <command>dpkg-reconfigure locales</command> as root."
msgstr "<emphasis role=\"pkg\">locales</emphasis> 套件包含應用軟體 “地區化” 後仍維持原有功能所需的所有元素。安裝過程中，此套件要求選擇支援的語系。以根使用者權限執行 <command>dpkg-reconfigure locales</command> 命令就能在任何時候變更語系的設定。"

msgid "The first question invites you to select “locales” to support. Selecting all English locales (meaning those beginning with “<literal>en_</literal>”) is a reasonable choice. Do not hesitate to also enable other locales if the machine will host foreign users. The list of locales enabled on the system is stored in the <filename>/etc/locale.gen</filename> file. It is possible to edit this file by hand, but you should run <command>locale-gen</command> after any modifications. It will generate the necessary files for the added locales to work, and remove any obsolete files."
msgstr "第一件事是選擇支援的 “地區設定”。選擇英語地區設定 (表示以 “<literal>en_</literal>” 起頭) 是合理的。別忘了再選擇另個地區設定以便支援其他語系。系統的地區設定表儲存在 <filename>/etc/locale.gen</filename> 檔案內。可以手動編輯它，但在修改後應執行 <command>locale-gen</command> 命令。產生新增地區設定所需要的必要檔案，並且移除不需要的檔案。"

msgid "The second question, entitled “Default locale for the system environment”, requests a default locale. The recommended choice in the U.S.A. is “<literal>en_US.UTF-8</literal>”. British English speakers will prefer “<literal>en_GB.UTF-8</literal>”, and Canadians will prefer either “<literal>en_CA.UTF-8</literal>” or, for French, “<literal>fr_CA.UTF-8</literal>”. The <filename>/etc/default/locale</filename> file will then be modified to store this choice. From there, it is picked up by all user sessions since PAM will inject its content in the <varname>LANG</varname> environment variable."
msgstr "第二個問題，標題為 “系統環境預設的地區設定”，選定預設的地區設定。美國是 “<literal>en_US.UTF-8</literal>”。英國是 “<literal>en_GB.UTF-8</literal>”，加拿大是 “<literal>en_CA.UTF-8</literal>” 或，法國是， “<literal>fr_CA.UTF-8</literal>”。<filename>/etc/default/locale</filename> 會被修改儲存前述的設定。從這裡，使用者選定讓 PAM 注入內容至 <varname>LANG</varname> 環境變數。"

msgid "<primary>environment</primary>"
msgstr "<primary>環境</primary>"

msgid "<primary>locale</primary>"
msgstr "<primary>地區設定</primary>"

msgid "<primary><varname>LANG</varname></primary>"
msgstr "<primary><varname>LANG</varname></primary>"

msgid "<emphasis>BEHIND THE SCENES</emphasis> <filename>/etc/environment</filename> and <filename>/etc/default/locale</filename>"
msgstr "<emphasis>後台</emphasis> <filename>/etc/environment</filename> 與 <filename>/etc/default/locale</filename>"

msgid "The <filename>/etc/environment</filename> file provides the <command>login</command>, <command>gdm</command>, or even <command>ssh</command> programs with the correct environment variables to be created."
msgstr "<filename>/etc/environment</filename> 檔案提供 <command>login</command>、<command>gdm</command>、或 <command>ssh</command> 程式建置正確的環境變數。"

msgid "These applications do not create these variables directly, but rather via a PAM (<filename>pam_env.so</filename>) module. PAM (Pluggable Authentication Module) is a modular library centralizing the mechanisms for authentication, session initialization, and password management. See <xref linkend=\"sect.config-pam\" /> for an example of PAM configuration."
msgstr "應用程式不會直接新增這些變數，而是經由 PAM (<filename>pam_env.so</filename>) 模組做事。可插入式認證模組 (Pluggable Authentication Module, PAM) 是供集中式的機器認證、延遲初始、與密碼管理模組程式庫。PAM 組態的範例參見 <xref linkend=\"sect.config-pam\" />。"

msgid "The <filename>/etc/default/locale</filename> file works in a similar manner, but contains only the <varname>LANG</varname> environment variable. Thanks to this split, some PAM users can inherit a complete environment without localization. Indeed, it is generally discouraged to run server programs with localization enabled; on the other hand, localization and regional settings are recommended for programs that open user sessions."
msgstr "<filename>/etc/default/locale</filename> 檔案以類似的方式運作，但祗有 <varname>LANG</varname> 環境變數。感謝此種區隔，某些 PAM 使用者可以在地區設定之外承襲完整的環境。事實上，不鼓勵在伺服器軟體執行地區設定；比較建議在使用者端的程式設定地區及區域。"

msgid "<primary>PAM</primary>"
msgstr "<primary>PAM</primary>"

msgid "<primary><filename>pam_env.so</filename></primary>"
msgstr "<primary><filename>pam_env.so</filename></primary>"

msgid "Configuring the Keyboard"
msgstr "組態鍵盤"

msgid "<primary>keyboard layout</primary>"
msgstr "<primary>鍵盤布局</primary>"

msgid "<primary>layout, keyboard</primary>"
msgstr "<primary>布局，鍵盤</primary>"

msgid "Even if the keyboard layout is managed differently in console and graphical mode, Debian offers a single configuration interface that works for both: it is based on debconf and is implemented in the <emphasis role=\"pkg\">keyboard-configuration</emphasis> package. Thus the <command>dpkg-reconfigure keyboard-configuration</command> command can be used at any time to reset the keyboard layout."
msgstr "即使鍵盤布局與終端機和圖形介面的管理不同，Debian 仍提供單一組態介面供兩者使用：以 debconf 為基礎應用於 <emphasis role=\"pkg\">keyboard-configuration</emphasis> 套件。因此，任何時間均可使用 <command>dpkg-reconfigure keyboard-configuration</command> 命令重設鍵盤。"

msgid "<primary><emphasis>console-data</emphasis></primary>"
msgstr "<primary><emphasis>console-data</emphasis></primary>"

msgid "<primary><emphasis>console-tools</emphasis></primary>"
msgstr "<primary><emphasis>console-tools</emphasis></primary>"

msgid "<primary><emphasis>keyboard-configuration</emphasis></primary>"
msgstr "<primary><emphasis>keyboard-configuration</emphasis></primary>"

msgid "<indexterm><primary><literal>azerty</literal></primary></indexterm>The questions are relevant to the physical keyboard layout (a standard PC keyboard in the US will be a “Generic 104 key”), then the layout to choose (generally “US”), and then the position of the AltGr key (right Alt). Finally comes the question of the key to use for the “Compose key”, which allows for entering special characters by combining keystrokes. Type successively <keycombo action=\"seq\"><keycap>Compose</keycap><keycap>'</keycap><keycap>e</keycap></keycombo> and produce an e-acute (“é”). All these combinations are described in the <filename>/usr/share/X11/locale/en_US.UTF-8/Compose</filename> file (or another file, determined according to the current locale indicated by <filename>/usr/share/X11/locale/compose.dir</filename>)."
msgstr "<indexterm><primary><literal>azerty</literal></primary></indexterm>問題與鍵盤的實體配置 (美式標準鍵盤為 “通用 104 鍵”)有關，選擇配置 (通常是 “US”)，然後選取 AltGr鍵 (即右側的 Alt 鍵)。最後是 “組合鍵”，以多個鍵同時按下組合成特殊字元。連續鍵入 <keycombo action=\"seq\"><keycap>Compose</keycap><keycap>'</keycap><keycap>e</keycap></keycombo> 就能產生帶讀音符號的 e (“é”)。這些組合鍵列在 <filename>/usr/share/X11/locale/en_US.UTF-8/Compose</filename> 檔案 (或其他檔案，視 <filename>/usr/share/X11/locale/compose.dir</filename> 指示的當前在地設定)。"

msgid "<primary><literal>Compose</literal>, key</primary>"
msgstr "<primary><literal>組合</literal>，鍵</primary>"

msgid "<primary><literal>Meta</literal>, key</primary>"
msgstr "<primary><literal>Meta</literal>, key</primary>"

msgid "<primary>key</primary><secondary><literal>Meta</literal></secondary>"
msgstr "<primary>key</primary><secondary><literal>Meta</literal></secondary>"

msgid "<primary>key</primary><secondary><literal>Compose</literal></secondary>"
msgstr "<primary>key</primary><secondary><literal>Compose</literal></secondary>"

msgid "Note that the keyboard configuration for graphical mode described here only affects the default layout; the GNOME and KDE environments, among others, provide a keyboard control panel in their preferences allowing each user to have their own configuration. Some additional options regarding the behavior of some particular keys are also available in these control panels."
msgstr "此處描述的圖形模式鍵盤組態祗影響預設的布局；在 GNOME 與 KDE 與其他環境下，在系統設定的鍵盤控制面板中，允許使用者擁有自己的組態。在此等控制面板中，還可以加入特定按鍵的選項。"

msgid "Migrating to UTF-8"
msgstr "移殖至 UTF-8"

msgid "The generalization of UTF-8 encoding has been a long awaited solution to numerous difficulties with interoperability, since it facilitates international exchange and removes the arbitrary limits on characters that can be used in a document. The one drawback is that it had to go through a rather difficult transition phase. Since it could not be completely transparent (that is, it could not happen at the same time all over the world), two conversion operations were required: one on file contents, and the other on filenames. Fortunately, the bulk of this migration has been completed and we discuss it largely for reference."
msgstr "期待已久的 UTF-8 一般化編碼是解決互通性的方案之一，可解決文件中字元的國際交換與誤值的限制。其中一個限制是必須經由相當困難的轉換階段。它可以完全透通 (就是，不會同時在全世界發生)，需要兩個轉換作業：檔案內容，以及檔案名稱。幸運的是，該等移殖已經完成且討論甚多。"

msgid "<emphasis>CULTURE</emphasis> <foreignphrase>Mojibake</foreignphrase> and interpretation errors"
msgstr "<emphasis>文化</emphasis> <foreignphrase>亂碼</foreignphrase> 與解譯錯誤"

msgid "When a text is sent (or stored) without encoding information, it is not always possible for the recipient to know with certainty what convention to use for determining the meaning of a set of bytes. You can usually get an idea by getting statistics on the distribution of values present in the text, but that doesn't always give a definite answer. When the encoding system chosen for reading differs from that used in writing the file, the bytes are mis-interpreted, and you get, at best, errors on some characters, or, at worst, something completely illegible."
msgstr "送出 (或儲存) 未帶編碼資訊的文字時，接收者不見得知道位元組的編碼方式。或許可從統計方式從文字的內容查知其編碼方式，但不見得正確。讀取與撰寫的編碼方式不同時，就會誤解位元組的意思，就會得到錯誤的字元，更慘的是，看見完全無法閱讀的內容。"

msgid "Thus, if a French text appears normal with the exception of accented letters and certain symbols which appear to be replaced with sequences of characters like “Ã©” or Ã¨” or “Ã§”, it is probably a file encoded as UTF-8 but interpreted as ISO-8859-1 or ISO-8859-15. This is a sign of a local installation that has not yet been migrated to UTF-8. If, instead, you see question marks instead of accented letters — even if these question marks seem to also replace a character that should have followed the accented letter — it is likely that your installation is already configured for UTF-8 and that you have been sent a document encoded in Western ISO."
msgstr "因此，法文的內容看起來正常，祗是無法顯示 “Ã©” 或 Ã¨” 或 “Ã§” 等重音字母與符號，很可能以 UTF-8 編碼儲存但被解讀成 ISO-8859-1 或 ISO-8859-15。在地的安裝尚未移殖至 UTF-8。如果，看到問號取代重音字母 — 即使這些問號取代重音字母後的字元 — 很可能已安裝並組態為 UTF-8 不過送出的文件仍以 Western ISO 編碼。"

msgid "So much for “simple” cases. These cases only appear in Western culture, since Unicode (and UTF-8) was designed to maximize the common points with historical encodings for Western languages based on the Latin alphabet, which allows recognition of parts of the text even when some characters are missing."
msgstr "這些都是 “簡單的” 個案。這些個案祗出現在西方文化裡，因為 Unicode (與 UTF-8) 是擴充拉丁字母為基礎的西方語系編碼，即使失漏部份字元仍可辨識其他內容。"

msgid "In more complex configurations, which, for example, involve two environments corresponding to two different languages that do not use the same alphabet, you often get completely illegible results — a series of abstract symbols that have nothing to do with each other. This is especially common with Asian languages due to their numerous languages and writing systems. The Japanese word <foreignphrase>mojibake</foreignphrase> has been adopted to describe this phenomenon. When it appears, diagnosis is more complex and the simplest solution is often to simply migrate to UTF-8 on both sides."
msgstr "在較複雜的環境裡，諸如，使用不同字母的兩種語文，通常得到完全不同的結果 — 彼此完全無意義的抽象符號。特別是語言與文字完全不同的亞洲語文。日文的 <foreignphrase>mojibake</foreignphrase>，即亂碼，用來說明此現象。出現時，診斷極為困難，最簡單的方法就是兩端都移殖至 UTF-8。"

msgid "As far as file names are concerned, the migration can be relatively simple. The <command>convmv</command> tool (in the package with the same name) was created specifically for this purpose; it allows renaming files from one encoding to another. The use of this tool is relatively simple, but we recommend doing it in two steps to avoid surprises. The following example illustrates a UTF-8 environment containing directory names encoded in ISO-8859-15, and the use of <command>convmv</command> to rename them."
msgstr "轉換檔名編碼，移殖工作還算簡單。<command>convmv</command> 工具 (以同名存在套件內) 是專門移殖用的；可以把檔名重新命名於不同的編碼。此工具還很簡單，但需要兩個步驟。下例說明在 UTF-8 環境下採用 ISO-8859-15 編碼的資料夾，以 <command>convmv</command> 重新命名。"

msgid ""
"<computeroutput>$ </computeroutput><userinput>ls travail/</userinput>\n"
"<computeroutput>Ic?nes  ?l?ments graphiques  Textes\n"
"$ </computeroutput><userinput>convmv -r -f iso-8859-15 -t utf-8 travail/</userinput>\n"
"<computeroutput>Starting a dry run without changes...\n"
"mv \"travail/�l�ments graphiques\"        \"travail/Éléments graphiques\"\n"
"mv \"travail/Ic�nes\"     \"travail/Icônes\"\n"
"No changes to your files done. Use --notest to finally rename the files.\n"
"$ </computeroutput><userinput>convmv -r --notest -f iso-8859-15 -t utf-8 travail/</userinput>\n"
"<computeroutput>mv \"travail/�l�ments graphiques\"        \"travail/Éléments graphiques\"\n"
"mv \"travail/Ic�nes\"     \"travail/Icônes\"\n"
"Ready!\n"
"$ </computeroutput><userinput>ls travail/</userinput>\n"
"<computeroutput>Éléments graphiques  Icônes  Textes</computeroutput>"
msgstr ""
"<computeroutput>$ </computeroutput><userinput>ls travail/</userinput>\n"
"<computeroutput>Ic?nes  ?l?ments graphiques  Textes\n"
"$ </computeroutput><userinput>convmv -r -f iso-8859-15 -t utf-8 travail/</userinput>\n"
"<computeroutput>Starting a dry run without changes...\n"
"mv \"travail/�l�ments graphiques\"        \"travail/Éléments graphiques\"\n"
"mv \"travail/Ic�nes\"     \"travail/Icônes\"\n"
"No changes to your files done. Use --notest to finally rename the files.\n"
"$ </computeroutput><userinput>convmv -r --notest -f iso-8859-15 -t utf-8 travail/</userinput>\n"
"<computeroutput>mv \"travail/�l�ments graphiques\"        \"travail/Éléments graphiques\"\n"
"mv \"travail/Ic�nes\"     \"travail/Icônes\"\n"
"Ready!\n"
"$ </computeroutput><userinput>ls travail/</userinput>\n"
"<computeroutput>Éléments graphiques  Icônes  Textes</computeroutput>"

msgid "For the file content, conversion procedures are more complex due to the vast variety of existing file formats. Some file formats include encoding information that facilitates the tasks of the software used to treat them; it is sufficient, then, to open these files and re-save them specifying UTF-8 encoding. In other cases, you have to specify the original encoding (ISO-8859-1 or “Western”, or ISO-8859-15 or “Western (Euro)”, according to the formulations) when opening the file."
msgstr "以檔案內容來說，因為檔案格式的多樣性，增加轉換工作的複雜度。有些檔案格式本身包括編碼資訊協助軟體使用它們；就可以直接打開它們，並指明以 UTF-8 編碼再儲存之。其他的情況下，則必須以原始的編碼格式 (ISO-8859-1 或 “Western”、或 ISO-8859-15 或 “Western (Euro)”，視其規則而定) 開啟它們。"

msgid "For simple text files, you can use <command>recode</command> (in the package of the same name) which allows automatic recoding. This tool has numerous options so you can play with its behavior. We recommend you consult the documentation, the <citerefentry> <refentrytitle>recode</refentrytitle> <manvolnum>1</manvolnum> </citerefentry> man page, or the <citerefentry> <refentrytitle>recode</refentrytitle> </citerefentry> info page (more complete)."
msgstr "簡單的文字檔，可以使用 <command>recode</command> (以同名存在於套件中) 自動重新編碼。此工具有很多選項。建議參加相關的文件， <citerefentry> <refentrytitle>recode</refentrytitle> <manvolnum>1</manvolnum> </citerefentry> man 頁面，或 <citerefentry> <refentrytitle>recode</refentrytitle> </citerefentry> info 頁面 (較為完整)。"

msgid "Configuring the Network"
msgstr "組態網路"

msgid "<emphasis>BACK TO BASICS</emphasis> Essential network concepts (Ethernet, IP address, subnet, broadcast)"
msgstr "<emphasis>基本</emphasis> 必要的網路概念 (Ethernet、IP 位址、次網路、廣播)"

msgid "<primary>Ethernet</primary>"
msgstr "<primary>Ethernet</primary>"

msgid "<primary>10BASE-T</primary>"
msgstr "<primary>10BASE-T</primary>"

msgid "<primary>100BASE-T</primary>"
msgstr "<primary>100BASE-T</primary>"

msgid "<primary>1000BASE-T</primary>"
msgstr "<primary>1000BASE-T</primary>"

msgid "<primary>10GBASE-T</primary>"
msgstr "<primary>10GBASE-T</primary>"

msgid "<primary>connector, RJ45</primary>"
msgstr "<primary>連結器，RJ45</primary>"

msgid "<primary>RJ45 connector</primary>"
msgstr "<primary>RJ45 連接器</primary>"

msgid "Most modern local networks use the Ethernet protocol, where data is split into small blocks called frames and transmitted on the wire one frame at a time. Data speeds vary from 10 Mb/s for older Ethernet cards to 10 Gb/s in the newest cards (with the most common rate currently growing from 100 Mb/s to 1 Gb/s). The most widely used cables are called 10BASE-T, 100BASE-T, 1000BASE-T or 10GBASE-T depending on the throughput they can reliably provide (the T stands for “twisted pair”); those cables end in an RJ45 connector. There are other cable types, used mostly for speeds of 1 Gb/s and above."
msgstr "當代的網路多半使用 Ethernet 協定，資料分為小小的區塊稱為框並且一次傳送一個框。傳送的速度從舊型 Ethernet 卡的 10 Mb/s 至最新卡的 10 Gb/s (最常見的速度為 100 Mb/s 至 1 Gb/s)。最常見的纜線是 10BASE-T、100BASE-T、1000BASE-T 或 10GBASE-T，視需求而定 (T 是雙絞線英文名稱的第一個字母 “twisted pair”)；這些纜線以 RJ45 連結器相接。當然還有其他類型的纜線，通常供速度超過 1 Gb/s 以上的環境使用。"

msgid "<primary>address, IP address</primary>"
msgstr "<primary>位址，IP 位址</primary>"

msgid "<primary>IP address</primary>"
msgstr "<primary>IP 位址</primary>"

msgid "An IP address is a number used to identify a network interface on a computer on a local network or the Internet. In the currently most widespread version of IP (IPv4), this number is encoded in 32 bits, and is usually represented as 4 numbers separated by periods (e.g. <literal>192.168.0.1</literal>), each number being between 0 and 255 (inclusive, which corresponds to 8 bits of data). The next version of the protocol, IPv6, extends this addressing space to 128 bits, and the addresses are generally represented as a series of hexadecimal numbers separated by colons (e.g., 2001:0db8:13bb:0002:0000:0000:0000:0020, or 2001:db8:13bb:2::20 for short)."
msgstr "IP 位址是一組數字用於辨識電腦在地區網路或網際網路的介面。最常用的是 IP 版本是 (IPv4)，此組數字由 32 位元編成，通常以句點區隔的 4 個數字表示 (如 <literal>192.168.0.1</literal>)，使用 0 至 255 之間的數字 (含在內，對應於 8 位元的資料)。通信協定的下個版本是 IPv6，採用 128 位元表示一個位址，其位址以 16 進位表示，用冒號區隔 (如，2001:0db8:13bb:0002:0000:0000:0000:0020，或 2001:db8:13bb:2::20 簡版表示)。"

msgid "<primary>subnet</primary>"
msgstr "<primary>次網路</primary>"

msgid "<primary>mask</primary><secondary>subnet mask</secondary>"
msgstr "<primary>遮罩</primary><secondary>次網路遮罩</secondary>"

msgid "<primary>network</primary><secondary>address</secondary>"
msgstr "<primary>網路</primary><secondary>位址</secondary>"

msgid "A subnet mask (netmask) defines in its binary code which portion of an IP address corresponds to the network, the remainder specifying the machine. In the example of configuring a static IPv4 address given here, the subnet mask, <literal>255.255.255.0</literal> (24 “1”s followed by 8 “0”s in binary representation) indicates that the first 24 bits of the IP address correspond to the network address, and the other 8 are specific to the machine. In IPv6, for readability, only the number of “1”s is expressed; the netmask for an IPv6 network could, thus, be <literal>64</literal>."
msgstr "次網路遮罩 (網路遮罩) 設定對應於網路的 IP 位址二進位代碼，其餘的則有機器指定。在前述的固定 IPv4 位址中，次網路遮罩，<literal>255.255.255.0</literal> (以 2 進位表示，就是 24 個 “1” 之後接著 8 個 “0”) 表示 IP 位址前 24 位元對應至網路位址，且其餘 8 個則指向機器。在 IPv6 裡，為了方便閱讀，祗表示數字 “1”；IPv6 網路的網路遮罩可以是 <literal>64</literal>。"

msgid "The network address is an IP address in which the part describing the machine's number is 0. The range of IPv4 addresses in a complete network is often indicated by the syntax, <emphasis>a.b.c.d/e</emphasis>, in which <emphasis>a.b.c.d</emphasis> is the network address and <emphasis>e</emphasis> is the number of bits affected to the network part in an IP address. The example network would thus be written: <literal>192.168.0.0/24</literal>. The syntax is similar in IPv6: <literal>2001:db8:13bb:2::/64</literal>."
msgstr "網路位址是一個 IP 位址，描述機器的號碼是 0。IPv4 位址的範圍是完成的網路以此語法表示，<emphasis>a.b.c.d/e</emphasis>，<emphasis>a.b.c.d</emphasis> 是網路位址，而 <emphasis>e</emphasis> 是被影響的位元數。因此，此網路可寫成：<literal>192.168.0.0/24</literal>。在 IPv6 的類似語法為：<literal>2001:db8:13bb:2::/64</literal>。"

msgid "<primary>router</primary>"
msgstr "<primary>路由器</primary>"

msgid "<primary>bridge</primary>"
msgstr "<primary>橋接器</primary>"

msgid "A router is a machine that connects several networks to each other. All traffic coming through a router is guided to the correct network. To do this, the router analyzes incoming packets and redirects them according to the IP address of their destination. The router is often known as a gateway; in this configuration, it works as a machine that helps reach out beyond a local network (towards an extended network, such as the Internet)."
msgstr "路由器用於連結多個網路。進入路由器的資訊被引導至正確的網路。所以，路由器分析進來的封包，根據其目的位址轉送至其他地方。路由器通常稱為閘道器；協助進入在地網路以外的地方 (網際網路之類的外部網路)。"

msgid "<primary>broadcast</primary>"
msgstr "<primary>廣播</primary>"

msgid "The special broadcast address connects all the stations in a network. Almost never “routed”, it only functions on the network in question. Specifically, it means that a data packet addressed to the broadcast never passes through the router."
msgstr "特定的廣播位址連結網路內所有的站台。幾乎不曾 “發送”，祗在網路內發送問題。就是說，經由廣播發送的資料封包不會通常路由器。"

msgid "This chapter focuses on IPv4 addresses, since they are currently the most commonly used. The details of the IPv6 protocol are approached in <xref linkend=\"sect.ipv6\" />, but the concepts remain the same."
msgstr "本章祗討論 IPv4 位址，現在最常見的。IPv6 協定的詳情在 <xref linkend=\"sect.ipv6\" />，其概念是一樣的。"

msgid "Since the network is automatically configured during the initial installation, the <filename>/etc/network/interfaces</filename> file already contains a valid configuration. A line starting with <literal>auto</literal> gives a list of interfaces to be automatically configured on boot by <emphasis role=\"pkg\">ifupdown</emphasis> and its <filename>/etc/init.d/networking</filename> init script. This will often be <literal>eth0</literal>, which refers to the first Ethernet card."
msgstr "初始安裝時會自動組態網路，<filename>/etc/network/interfaces</filename> 檔案內已有完備的組態。以 <literal>auto</literal> 起頭的資料在開機時自動被 <emphasis role=\"pkg\">ifupdown</emphasis> 組態，且組態它的 <filename>/etc/init.d/networking</filename> init 腳本。通常是 <literal>eth0</literal>，指向第一個 Ethernet 網卡。"

msgid "<primary>network</primary><secondary>configuration</secondary>"
msgstr "<primary>網路</primary><secondary>組態</secondary>"

msgid "<primary>configuration</primary><secondary>of the network</secondary>"
msgstr "<primary>組態</primary><secondary>網路</secondary>"

msgid "<primary>interface</primary><secondary>network interface</secondary>"
msgstr "<primary>介面</primary><secondary>網路介面</secondary>"

msgid "<primary><literal>eth0</literal></primary>"
msgstr "<primary><literal>eth0</literal></primary>"

msgid "<emphasis>ALTERNATIVE</emphasis> NetworkManager"
msgstr "<emphasis>其他</emphasis> NetworkManager"

msgid "<primary><emphasis role=\"pkg\">network-manager</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">網路管理器</emphasis></primary>"

msgid "If Network Manager is particularly recommended in roaming setups (see <xref linkend=\"sect.roaming-network-config\" />), it is also perfectly usable as the default network management tool. You can create “System connections” that are used as soon as the computer boots either manually with a <filename>.ini</filename>-like file in <filename>/etc/NetworkManager/system-connections/</filename> or through a graphical tool (<command>nm-connection-editor</command>). Just remember to deactivate all entries in <filename>/etc/network/interfaces</filename> if you want Network Manager to handle them. <ulink type=\"block\" url=\"https://wiki.gnome.org/Projects/NetworkManager/SystemSettings/jessie\" /> <ulink type=\"block\" url=\"https://developer.gnome.org/NetworkManager/0.9/ref-settings.html\" />"
msgstr "漫遊設定推薦使用的網路管理器 (見 <xref linkend=\"sect.roaming-network-config\" />)，同樣適用於預設的網路管理工具。啟動電腦時以人工啟用 <filename>.ini</filename> 之類的檔案在 <filename>/etc/NetworkManager/system-connections/</filename> 之內或經由圖形工具 (<command>nm-connection-editor</command>)，可以同時新增 “系統連結”。想要網路管理器處理它們時，記得關閉 <filename>/etc/network/interfaces</filename> 內的所有條目。<ulink type=\"block\" url=\"https://wiki.gnome.org/Projects/NetworkManager/SystemSettings/jessie\" /> <ulink type=\"block\" url=\"https://developer.gnome.org/NetworkManager/0.9/ref-settings.html\" />"

msgid "Ethernet Interface"
msgstr "Ethernet 介面"

msgid "If the computer has an Ethernet card, the IP network that is associated with it must be configured by choosing from one of two methods. The simplest method is dynamic configuration with DHCP, and it requires a DHCP server on the local network. It may indicate a desired hostname, corresponding to the <literal>hostname</literal> setting in the example below. The DHCP server then sends configuration settings for the appropriate network."
msgstr "電腦使用 Ethernet 網路卡時，必須以下列的方法之一組態 IP 網路。最簡單的方式是以 DHCP 動態組態，需要在地網路的 DHCP 伺服器。可以使用與下例 <literal>hostname</literal> 設定的主機名稱。DHCP 伺服器就會送出組態設定給適當的網路。"

msgid "<primary>DHCP</primary>"
msgstr "<primary>DHCP</primary>"

msgid "DHCP configuration"
msgstr "DHCP 組態"

msgid ""
"\n"
"auto eth0\n"
"iface eth0 inet dhcp\n"
"  hostname arrakis"
msgstr ""
"\n"
"auto eth0\n"
"iface eth0 inet dhcp\n"
"  hostname arrakis"

msgid "A “static” configuration must indicate network settings in a fixed manner. This includes at least the IP address and subnet mask; network and broadcast addresses are also sometimes listed. A router connecting to the exterior will be specified as a gateway."
msgstr "“靜態” 組態必須以固定方式指明網路設定。至少包括 IP 網址及次網路遮罩；有時也列出網路及廣播位址。必須以閘道指出連結外部的路由器。"

msgid "Static configuration"
msgstr "靜態組態"

msgid ""
"\n"
"auto eth0\n"
"iface eth0 inet static\n"
"  address 192.168.0.3\n"
"  netmask 255.255.255.0\n"
"  broadcast 192.168.0.255\n"
"  network 192.168.0.0\n"
"  gateway 192.168.0.1"
msgstr ""
"\n"
"auto eth0\n"
"iface eth0 inet static\n"
"  address 192.168.0.3\n"
"  netmask 255.255.255.0\n"
"  broadcast 192.168.0.255\n"
"  network 192.168.0.0\n"
"  gateway 192.168.0.1"

msgid "<emphasis>NOTE</emphasis> Multiple addresses"
msgstr "<emphasis>說明</emphasis> 多位址"

msgid "It is possible not only to associate several interfaces to a single, physical network card, but also several IP addresses to a single interface. Remember also that an IP address may correspond to any number of names via DNS, and that a name may also correspond to any number of numerical IP addresses."
msgstr "在一個實體網路卡上可以連結多個介面，而且可以設定多個 IP 位址。IP 位址本身可以經由 DNS 對應至多個網域名稱，名稱本身可以對應至多個 IP 位址。"

msgid "As you can guess, the configurations can be rather complex, but these options are only used in very special cases. The examples cited here are typical of the usual configurations."
msgstr "如您所想，組態可以極為複雜，不過祗限於極為特殊的例子。此處引用的例子都是一般常見的組態。"

msgid "Connecting with PPP through a PSTN Modem"
msgstr "經由 PSTN 數據機的 PPP 連結"

msgid "<primary>PPP</primary>"
msgstr "<primary>PPP</primary>"

msgid "<primary>point to point</primary>"
msgstr "<primary>點對點</primary>"

msgid "<primary>connection</primary><secondary>by PSTN modem</secondary>"
msgstr "<primary>連結</primary><secondary>經由 PSTN 數據機</secondary>"

msgid "<primary>modem</primary><secondary>PSTN</secondary>"
msgstr "<primary>數據機</primary><secondary>PSTN</secondary>"

msgid "A point to point (PPP) connection establishes an intermittent connection; this is the most common solution for connections made with a telephone modem (“PSTN modem”, since the connection goes over the public switched telephone network)."
msgstr "點對點 (PPP) 連結建立斷續的連結；這是電話數據機最常見的連結方式 (“PSTN 數據機”，經由公共交換電話網路)。"

msgid "A connection by telephone modem requires an account with an access provider, including a telephone number, username, password, and, sometimes the authentication protocol to be used. Such a connection is configured using the <command>pppconfig</command> tool in the Debian package of the same name. By default, it sets up a connection named <literal>provider</literal> (as in Internet service provider). When in doubt about the authentication protocol, choose <emphasis>PAP</emphasis>: it is offered by the majority of Internet service providers."
msgstr "電話數據機需要帳號才能連結，包括電話號碼、使用者名稱、密碼、以及認證協定。這種連結 Debian 同名套件內的使用 <command>pppconfig</command> 工具。預設使用的名稱是 <literal>提供者</literal> (做為網際網路服務提供者)。對認證協定有疑義時，選擇 <emphasis>PAP</emphasis>：大多數網際網路服務提供者使用它。"

msgid "<primary><command>pppconfig</command></primary>"
msgstr "<primary><command>pppconfig</command></primary>"

msgid "<primary>PAP</primary>"
msgstr "<primary>PAP</primary>"

msgid "After configuration, it is possible to connect using the <command>pon</command> command (giving it the name of the connection as a parameter, when the default value of <literal>provider</literal> is not appropriate). The link is disconnected with the <command>poff</command> command. These two commands can be executed by the root user, or by any other user, provided they are in the <literal>dip</literal> group."
msgstr "組態之後，就可以使用 <command>pon</command> 命令 (<literal>提供者</literal> 的預設值不適用時，將連結的名稱當成參數)。以 <command>poff</command> 命令斷線。這兩個令可以被根使用者執行，或位在 <literal>dip</literal> 群組的其他使用者。"

msgid "<primary><command>pon</command></primary>"
msgstr "<primary><command>pon</command></primary>"

msgid "<primary><command>poff</command></primary>"
msgstr "<primary><command>poff</command></primary>"

msgid "Connecting through an ADSL Modem"
msgstr "以 ADSL 數據連結"

msgid "<primary>connection</primary><secondary>by ADSL modem</secondary>"
msgstr "<primary>連結</primary><secondary>經由 ADSL 數據機</secondary>"

msgid "<primary>modem</primary><secondary>ADSL</secondary>"
msgstr "<primary>數據機</primary><secondary>ADSL</secondary>"

msgid "<primary>ADSL, modem</primary>"
msgstr "<primary>ADSL，數據機</primary>"

msgid "The generic term “ADSL modem” covers a multitude of devices with very different functions. The modems that are simplest to use with Linux are those that have an Ethernet interface (and not only a USB interface). These tend to be popular; most ADSL Internet service providers lend (or lease) a “box” with Ethernet interfaces. Depending on the type of modem, the configuration required can vary widely."
msgstr "“ADSL 數據機” 一辭包括不同功能的多種設備。使用 Linux 的數據機有 Ethernet 介面 (不祗是 USB 介面)。這是極為普遍的數據機；大部份的 ADSL 網際網路服務商出借 (或出租) 一個含 Ethernet 介面的 “盒子”。視其類型而有不同的設定。"

msgid "Modems Supporting PPPOE"
msgstr "支援 PPPOE 的數據機"

msgid "<primary>PPPOE</primary>"
msgstr "<primary>PPPOE</primary>"

msgid "<primary><command>pppoeconf</command></primary>"
msgstr "<primary><command>pppoeconf</command></primary>"

msgid "Some Ethernet modems work with the PPPOE protocol (Point to Point Protocol over Ethernet). The <command>pppoeconf</command> tool (from the package with the same name) will configure the connection. To do so, it modifies the <filename>/etc/ppp/peers/dsl-provider</filename> file with the settings provided and records the login information in the <filename>/etc/ppp/pap-secrets</filename> and <filename>/etc/ppp/chap-secrets</filename> files. It is recommended to accept all modifications that it proposes."
msgstr "部份 Ethernet 數據機使用 PPPOE 協定 (乙太網上的對等協定，Point to Point Protocol over Ethernet)。<command>pppoeconf</command> 工具 (位於同名套件內) 將組態其連結。修改 <filename>/etc/ppp/peers/dsl-provider</filename> 檔案內容時，採用 <filename>/etc/ppp/pap-secrets</filename> 與 <filename>/etc/ppp/chap-secrets</filename> 檔案的內容。建議全盤接納所有的提議。"

msgid "Once this configuration is complete, you can open the ADSL connection with the command, <command>pon dsl-provider</command> and disconnect with <command>poff dsl-provider</command>."
msgstr "組態完成之後，以命令 <command>pon dsl-provider</command> 開啟 ADSL 連結，並以命令 <command>poff dsl-provider</command> 斷線。"

msgid "<primary><literal>dsl-provider</literal></primary>"
msgstr "<primary><literal>dsl-provider</literal></primary>"

msgid "<emphasis>TIP</emphasis> Starting <command>ppp</command> at boot"
msgstr "<emphasis>秘訣</emphasis>啟動 <command>ppp</command> 於開機時"

msgid "<primary><command>systemd</command></primary>"
msgstr "<primary><command>systemd</command></primary>"

msgid "<primary><command>init</command></primary>"
msgstr "<primary><command>init</command></primary>"

msgid "PPP connections over ADSL are, by definition, intermittent. Since they are usually not billed according to time, there are few downsides to the temptation of keeping them always open. The standard means to do so is to use the init system."
msgstr "PPP 在 ADSL 上的連結，其本意是斷斷續續的。因為不是依照連線時間收費，所以不必隨時打開它。標準的方法是使用 init 系統。"

msgid "The default init system on <emphasis role=\"distribution\">Jessie</emphasis> is <command>systemd</command>. Adding an automatically restarting task for the ADSL connection is a simple matter of creating a “unit file” such as <filename>/etc/systemd/system/adsl-connection.service</filename>, with contents such as the following:"
msgstr "在 <emphasis role=\"distribution\">Jessie</emphasis> 預設的 init 系統是 <command>systemd</command>。在 ADSL 連結自動重新啟動很簡單，新增一個像 <filename>/etc/systemd/system/adsl-connection.service</filename> 之類的 “unit file” 就可以了，其內容類似以下的："

msgid ""
"[Unit]\n"
"Description=ADSL connection\n"
"\n"
"[Service]\n"
"Type=forking\n"
"ExecStart=/usr/sbin/pppd call dsl-provider\n"
"Restart=always\n"
"\n"
"[Install]\n"
"WantedBy=multi-user.target"
msgstr ""
"[Unit]\n"
"Description=ADSL connection\n"
"\n"
"[Service]\n"
"Type=forking\n"
"ExecStart=/usr/sbin/pppd call dsl-provider\n"
"Restart=always\n"
"\n"
"[Install]\n"
"WantedBy=multi-user.target"

msgid "Once this unit file has been defined, it needs to be enabled with <command>systemctl enable adsl-connection</command>. Then the loop can be started manually with <command>systemctl start adsl-connection</command>; it will also be started automatically on boot."
msgstr "設定這個 unit file 之後，還需以 <command>systemctl enable adsl-connection</command> 命令啟動它。然後以手動方式，啟動此命令 <command>systemctl start adsl-connection</command> 迴圈；然後就可在開機時自動啟動。"

msgid "On systems not using <command>systemd</command> (including <emphasis role=\"distribution\">Wheezy</emphasis> and earlier versions of Debian), the standard SystemV init works differently. On such systems, all that is needed is to add a line such as the following at the end of the <filename>/etc/inittab</filename> file; then, any time the connection is disconnected, <command>init</command> will reconnect it."
msgstr "未使用 <command>systemd</command> 命令的系統 (包括 <emphasis role=\"distribution\">Wheezy</emphasis> 及更早的 Debian 版本)，可使用標準的 SystemV init。在這種系統裡，祗需在 <filename>/etc/inittab</filename> 檔案加入一行字；然後，在斷線之後，執行 <command>init</command> 就可重新連線。"

msgid ""
"\n"
"adsl:2345:respawn:/usr/sbin/pppd call dsl-provider"
msgstr ""
"\n"
"adsl:2345:respawn:/usr/sbin/pppd call dsl-provider"

msgid "For ADSL connections that auto-disconnect on a daily basis, this method reduces the duration of the interruption."
msgstr "撥接後自動斷線的 ADSL，這種方法減少中斷的次數。"

msgid "Modems Supporting PPTP"
msgstr "支援 PPTP 的數據機"

msgid "<primary>PPTP</primary>"
msgstr "<primary>PPTP</primary>"

msgid "The PPTP (Point-to-Point Tunneling Protocol) protocol was created by Microsoft. Deployed at the beginning of ADSL, it was quickly replaced by PPPOE. If this protocol is forced on you, see <xref linkend=\"sect.pptp\" />."
msgstr "PPTP (點對點隧道協議，Point-to-Point Tunneling Protocol) 協定由微軟創製。在 ADSL 的初期就已布置，取代 PPPOE。若被強迫使用此協定，參見 <xref linkend=\"sect.pptp\" />。"

msgid "Modems Supporting DHCP"
msgstr "支援 DHCP 數據機"

msgid "When a modem is connected to the computer by an Ethernet cable (crossover cable) you typically configure a network connection by DHCP on the computer; the modem automatically acts as a gateway by default and takes care of routing (meaning that it manages the network traffic between the computer and the Internet)."
msgstr "以 Ethernet 纜線 (跳線) 連線電腦的數據機，可以在電腦以 DHCP 組態網路連結；數據機自動成為閘道且執行路由的功能 (就是管理電腦與網際網路的流量)。"

msgid "<emphasis>BACK TO BASICS</emphasis> Crossover cable for a direct Ethernet connection"
msgstr "<emphasis>基本</emphasis> 直接連結 Ethernet 的跳線"

msgid "<primary>crossover cable</primary>"
msgstr "<primary>跳線</primary>"

msgid "Computer network cards expect to receive data on specific wires in the cable, and send their data on others. When you connect a computer to a local network, you usually connect a cable (straight or crossover) between the network card and a repeater or switch. However, if you want to connect two computers directly (without an intermediary switch or repeater), you must route the signal sent by one card to the receiving side of the other card, and vice-versa. This is the purpose of a crossover cable, and the reason it is used."
msgstr "電腦網路卡經由特定纜線接收資料，也從同樣的管道送出資料。電腦連上地區網路後，通常以纜線 (直接連線或跳線) 連結網路上與中繼器或交換器。若想直接連結兩部電腦 (不經過交換器或中繼器)，必須經由網路卡送出資料至接收端的另個網路卡，反之亦然。這就是跳線的作用，以及使用它的原因。"

msgid "Note that this distinction has become almost irrelevant over time, as modern network cards are able do detect the type of cable present and adapt accordingly, so it won't be unusual that both kinds of cable will work in a given location."
msgstr "此區別在現在的環境沒有作用，現代的網路卡可以自動偵測纜線的類型並據以配合它，所以兩種纜線都可運用自如。"

msgid "Most “ADSL routers” on the market can be used like this, as do most of the ADSL modems provided by Internet services providers."
msgstr "大部份的 “ADSL 路由器” 也能這麼做，網際網路服務供應商提供的 ADSL 數據機也具有此功能。"

msgid "Automatic Network Configuration for Roaming Users"
msgstr "網路自動組態漫遊使用者"

msgid "<primary>network</primary><secondary>roaming configuration</secondary>"
msgstr "<primary>網路</primary><secondary>漫遊組態</secondary>"

msgid "Many Falcot engineers have a laptop computer that, for professional purposes, they also use at home. The network configuration to use differs according to location. At home, it may be a wifi network (protected by a WPA key), while the workplace uses a wired network for greater security and more bandwidth."
msgstr "Falcot 公司的工程師擁有專業用的筆電，同時也在家裡使用它。根據使用場所的不同，網路有不同的組態方式。在家裡，可能使用 WiFi 網路 (以 WPA 鑰保護)，在工作場合則使用較安全與頻寬更充足的固接網路。"

msgid "To avoid having to manually connect or disconnect the corresponding network interfaces, administrators installed the <emphasis role=\"pkg\">network-manager</emphasis> package on these roaming machines. This software enables a user to easily switch from one network to another using a small icon displayed in the notification area of their graphical desktop. Clicking on this icon displays a list of available networks (both wired and wireless), so they can simply choose the network they wish to use. The program saves the configuration for the networks to which the user has already connected, and automatically switches to the best available network when the current connection drops."
msgstr "為了避免人工連結與斷線對應的網路介面，管理者在漫遊機器安裝 <emphasis role=\"pkg\">network-manager</emphasis> 套件。此軟體可以讓使用者從圖形桌面的小圖示，在多個網路間切換。按下此圖示即顯示可用的網路 (固接與無線)，藉以選擇其中之一。此程式儲存曾連結網路的組態，斷線時自動選擇最佳的網路。"

msgid "In order to do this, the program is structured in two parts: a daemon running as root handles activation and configuration of network interfaces and a user interface controls this daemon. PolicyKit handles the required authorizations to control this program and Debian configured PolicyKit in such a way so that members of the netdev group can add or change Network Manager connections."
msgstr "為了達到這個目的，程式分為兩個部份：在根部執行後台進程並組態網路介面與使用者介面控制該後台進程。PolicyKit 處理必要的權限以控制此程式，然後由 Debian 組態 PolicyKit 讓 netdev 群組成員可以新增或修改 Network Manager 的連結。"

msgid "Network Manager knows how to handle various types of connections (DHCP, manual configuration, local network), but only if the configuration is set with the program itself. This is why it will systematically ignore all network interfaces in <filename>/etc/network/interfaces</filename> for which it is not suited. Since Network Manager doesn't give details when no network connections are shown, the easy way is to delete from <filename>/etc/network/interfaces</filename> any configuration for all interfaces that must be managed by Network Manager."
msgstr "程式自身已組態後，網路管理器就能夠處理多種類型的連線 (DHCP、手動組態、地區網路)。所以能夠系統地忽略在 <filename>/etc/network/interfaces</filename> 裡面不合適的網路介面。網路管理器無法提供未顯示網路連線的詳情，最簡單的方法是刪除 <filename>/etc/network/interfaces</filename> 內必須由網路管理器組態的所有介面。"

msgid "Note that this program is installed by default when the “Desktop Environment” task is chosen during initial installation."
msgstr "在初始安裝階段選擇 “桌面環境”的工作，就能夠預設安裝此程式。"

msgid "<emphasis>ALTERNATIVE</emphasis> Configuration by “network profile”"
msgstr "<emphasis>其他</emphasis> 由“網路設定檔”組態"

msgid "<primary><emphasis role=\"pkg\">guessnet</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">guessnet</emphasis></primary>"

msgid "More advanced users may want to try the <emphasis role=\"pkg\">guessnet</emphasis> package for automatic network configuration. A group of test scripts determine which network profile should be activated and configure it on the fly."
msgstr "更進階的使用者可能布望試用 <emphasis role=\"pkg\">guessnet</emphasis> 套件做為網路自動組態的工具。以一組測試腳本決定啟用與組態的網路設定檔。"

msgid "Users who prefer to manually select a network profile will prefer the <emphasis role=\"pkg\">netenv</emphasis> program, found in the package of the same name."
msgstr "以人工選定網路設定的使用者，將偏向使用在同名套件內找到的 <emphasis role=\"pkg\">netenv</emphasis> 程式。"

msgid "Setting the Hostname and Configuring the Name Service"
msgstr "設定主機名稱與組態名稱服務"

msgid "<primary>name</primary><secondary>attribution and resolution</secondary>"
msgstr "<primary>名稱</primary><secondary>屬性與解析</secondary>"

msgid "<primary>assignment of names</primary>"
msgstr "<primary>指定名稱</primary>"

msgid "The purpose of assigning names to IP numbers is to make them easier for people to remember. In reality, an IP address identifies a network interface associated with a device such as a network card. Since each machine can have several network cards, and several interfaces on each card, one single computer can have several names in the domain name system."
msgstr "將 IP 數字轉換為名稱係方便記憶。實務上，IP 位址係用於辨識網路卡之類的網路介面設備。機器可能有多個網路卡，每個網路卡可能有多個介面，所以在網域名稱系統裡，一部電腦就可能有多個名稱。"

msgid "Each machine is, however, identified by a main (or “canonical”) name, stored in the <filename>/etc/hostname</filename> file and communicated to the Linux kernel by initialization scripts through the <command>hostname</command> command. The current value is available in a virtual filesystem, and you can get it with the <command>cat /proc/sys/kernel/hostname</command> command."
msgstr "然而，每部機器都有個辨識用的主要 (如 “canonical”) 名稱，儲存在 <filename>/etc/hostname</filename> 檔案內並以初始腳本經由 <command>hostname</command> 命令與 Linux 核心溝通。現在的值儲存在虛擬檔案系統，可經由 <command>cat /proc/sys/kernel/hostname</command> 命令取得。"

msgid "<primary><command>hostname</command></primary>"
msgstr "<primary><command>主機名稱</command></primary>"

msgid "<emphasis>BACK TO BASICS</emphasis> <filename>/proc/</filename> and <filename>/sys/</filename>, virtual filesystems"
msgstr "<emphasis>基本</emphasis> <filename>/proc/</filename> 與 <filename>/sys/</filename>，虛擬檔案系統"

msgid "<primary><filename>/proc/</filename></primary>"
msgstr "<primary><filename>/proc/</filename></primary>"

msgid "<primary><filename>proc</filename></primary>"
msgstr "<primary><filename>proc</filename></primary>"

msgid "<primary><filename>/sys/</filename></primary>"
msgstr "<primary><filename>/sys/</filename></primary>"

msgid "<primary><filename>sys</filename></primary>"
msgstr "<primary><filename>sys</filename></primary>"

msgid "The <filename>/proc/</filename> and <filename>/sys/</filename> file trees are generated by “virtual” filesystems. This is a practical means of recovering information from the kernel (by listing virtual files) and communicating them to it (by writing to virtual files)."
msgstr "<filename>/proc/</filename> 與 <filename>/sys/</filename> 檔案樹係由 “虛擬” 檔案系統產生。從核心 (以列出虛擬檔案方式) 取得資訊並與其溝通 (寫入虛擬檔案) 的實務。"

msgid "<filename>/sys/</filename> in particular is designed to provide access to internal kernel objects, especially those representing the various devices in the system. The kernel can, thus, share various pieces of information: the status of each device (for example, if it is in energy saving mode), whether it is a removable device, etc. Note that <filename>/sys/</filename> has only existed since kernel version 2.6."
msgstr "<filename>/sys/</filename> 係供近用內部核心物件之用，尤其是代表系統的各種設備。核心本身可以共享資源：每個設備的狀態 (如，處於省電模式)、移動狀置等。<filename>/sys/</filename> 祗存於於核心版本 2.6 及更新的版本。"

msgid "Surprisingly, the domain name is not managed in the same way, but comes from the complete name of the machine, acquired through name resolution. You can change it in the <filename>/etc/hosts</filename> file; simply write a complete name for the machine there at the beginning of the list of names associated with the address of the machine, as in the following example:"
msgstr "意外的是，網域名稱的管理方式不同，來自機器的完整名稱，經由名稱解析取得。可以在 <filename>/etc/hosts</filename> 檔案內更改它；在名稱清單前寫入完整的名稱，如下例："

msgid ""
"\n"
"127.0.0.1     localhost\n"
"192.168.0.1   arrakis.falcot.com arrakis"
msgstr ""
"\n"
"127.0.0.1     localhost\n"
"192.168.0.1   arrakis.falcot.com arrakis"

msgid "<primary><filename>hosts</filename></primary>"
msgstr "<primary><filename>主機</filename></primary>"

msgid "<primary><filename>/etc/hosts</filename></primary>"
msgstr "<primary><filename>/etc/hosts</filename></primary>"

msgid "<primary>domain</primary><secondary>name</secondary>"
msgstr "<primary>網域</primary><secondary>名稱</secondary>"

msgid "<primary>name</primary><secondary>domain</secondary>"
msgstr "<primary>名稱</primary><secondary>網域</secondary>"

msgid "<primary>NSS</primary>"
msgstr "<primary>NSS</primary>"

msgid "Name Resolution"
msgstr "名稱解析"

msgid "<primary>resolution</primary><secondary>name</secondary>"
msgstr "<primary>解析</primary><secondary>名稱</secondary>"

msgid "<primary>name</primary><secondary>resolution</secondary>"
msgstr "<primary>名稱</primary><secondary>解析</secondary>"

msgid "The mechanism for name resolution in Linux is modular and can use various sources of information declared in the <filename>/etc/nsswitch.conf</filename> file. The entry that involves host name resolution is <literal>hosts</literal>. By default, it contains <literal>files dns</literal>, which means that the system consults the <filename>/etc/hosts</filename> file first, then DNS servers. NIS/NIS+ or LDAP servers are other possible sources."
msgstr "Linux 的名稱解析機制是模組化的且可使用 <filename>/etc/nsswitch.conf</filename> 宣稱的資料來源。涉及主機名稱解析的款目是 <literal>hosts</literal>。預設，它包括 <literal>files dns</literal>，表示系統先參照 <filename>/etc/hosts</filename> 檔案，再參照 DNS 伺服器。NIS/NIS+ 或 LDAP 伺服器是另個來源選擇。"

msgid "<emphasis>NOTE</emphasis> NSS and DNS"
msgstr "<emphasis>說明</emphasis> NSS 與 DNS"

msgid "Be aware that the commands specifically intended to query DNS (especially <command>host</command>) do not use the standard name resolution mechanism (NSS). As a consequence, they do not take into consideration <filename>/etc/nsswitch.conf</filename>, and thus, not <filename>/etc/hosts</filename> either."
msgstr "專門用於查詢 DNS (特別是 <command>host</command>) 的命令未使用標準的名稱解析機制 (NSS)。也就是，完全未考慮 <filename>/etc/nsswitch.conf</filename>，也不使用 <filename>/etc/hosts</filename>。"

msgid "Configuring DNS Servers"
msgstr "組態 DNS 伺服器"

msgid "<primary>DNS</primary>"
msgstr "<primary>DNS</primary>"

msgid "<primary>Domain Name Service</primary>"
msgstr "<primary>網域名稱服務</primary>"

msgid "DNS (Domain Name Service) is a distributed and hierarchical service mapping names to IP addresses, and vice-versa. Specifically, it can turn a human-friendly name such as <literal>www.eyrolles.com</literal> into the actual IP address, <literal>213.244.11.247</literal>."
msgstr "DNS (網域名稱服務) 是對映名稱至 IP 位址的分散式階層服務，同時也反向對映。尤其是，把人可閱讀的名稱，如 <literal>www.eyrolles.com</literal> 對映至實際的 IP 位址 <literal>213.244.11.247</literal>。"

msgid "To access DNS information, a DNS server must be available to relay requests. Falcot Corp has its own, but an individual user is more likely to use the DNS servers provided by their ISP."
msgstr "必須先設定 DNS 伺服器，才能用到 DNS 資訊。Falcot 公司自設該伺服器，但個人使用者可能使用 ISP 提供的 DNS 伺服器。"

msgid "<primary><filename>resolv.conf</filename></primary>"
msgstr "<primary><filename>resolv.conf</filename></primary>"

msgid "<primary><literal>nameserver</literal></primary>"
msgstr "<primary><literal>nameserver</literal></primary>"

msgid "The DNS servers to be used are indicated in the <filename>/etc/resolv.conf</filename>, one per line, with the <literal>nameserver</literal> keyword preceding an IP address, as in the following example:"
msgstr "DNS 伺服器的用法在 <filename>/etc/resolv.conf</filename> 內，每個一列，在 IP 位址前有 <literal>nameserver</literal> 鍵詞，如下："

msgid ""
"\n"
"nameserver 212.27.32.176\n"
"nameserver 212.27.32.177\n"
"nameserver 8.8.8.8"
msgstr ""
"\n"
"nameserver 212.27.32.176\n"
"nameserver 212.27.32.177\n"
"nameserver 8.8.8.8"

msgid "Note that the <filename>/etc/resolv.conf</filename> file may be handled automatically (and overwritten) when the network is managed by NetworkManager or configured via DHCP."
msgstr "網路由 NetworkManager 管理或經由 DHCP 組態時，可以自動處理 (與覆寫) <filename>/etc/resolv.conf</filename> 檔案。"

msgid "The <filename>/etc/hosts</filename> file"
msgstr "<filename>/etc/hosts</filename> 檔案"

msgid "If there is no name server on the local network, it is still possible to establish a small table mapping IP addresses and machine hostnames in the <filename>/etc/hosts</filename> file, usually reserved for local network stations. The syntax of this file is very simple: each line indicates a specific IP address followed by the list of any associated names (the first being “completely qualified”, meaning it includes the domain name)."
msgstr "地區網路沒洧名稱伺服器時，仍可以在保留給地區網路的 <filename>/etc/hosts</filename> 檔案內，建立 IP 位址與主機名稱的小型對照表。此檔案的語法極簡單：每列一個固定 IP 位址，然後是相關的名稱 (第一個是 “完全合格”，表示包括網域名稱)。"

msgid "This file is available even during network outages or when DNS servers are unreachable, but will only really be useful when duplicated on all the machines on the network. The slightest alteration in correspondence will require the file to be updated everywhere. This is why <filename>/etc/hosts</filename> generally only contains the most important entries."
msgstr "即使網路停擺或 DNS 伺服器不通仍可近用此檔案，但祗適用於在地區網路所有機器重製的內容。即使是極微小的變動，都需要更新各地所有的檔案。所以， <filename>/etc/hosts</filename> 通常祗包括最重要的款目。"

msgid "This file will be sufficient for a small network not connected to the Internet, but with 5 machines or more, it is recommended to install a proper DNS server."
msgstr "這個檔案對未連上網際網路的小型網路是夠用的，5 部以內的機器，建議安裝一個 DNS 伺服器較佳。"

msgid "<emphasis>TIP</emphasis> Bypassing DNS"
msgstr "<emphasis>秘訣</emphasis> 繞過 DNS"

msgid "Since applications check the <filename>/etc/hosts</filename> file before querying DNS, it is possible to include information in there that is different from what the DNS would return, and therefore to bypass normal DNS-based name resolution."
msgstr "某些應用程式先檢查 <filename>/etc/hosts</filename> 檔案才查詢 DNS，與 DNS 送回資料不同的部份，可以先儲存在這裡，並略過 DNS 的名稱解析。"

msgid "This allows, in the event of DNS changes not yet propagated, to test access to a website with the intended name even if this name is not properly mapped to the correct IP address yet."
msgstr "修改 DNS 但尚未布署前，這種做法可以測試網站名稱與 IP 位址的對應性。"

msgid "Another possible use is to redirect traffic intended for a specific host to the localhost, thus preventing any communication with the given host. For example, hostnames of servers dedicated to serving ads could be diverted which would bypass these ads resulting in more fluid, less distracting, navigation."
msgstr "另一個可能用法是把流量轉移至指定的區域主機，避免大流量進入指定的主機。例如，可以繞過專供廣告使用的伺服器主機名稱，讓結果更順暢、少些干擾。"

msgid "User and Group Databases"
msgstr "使用者與群組資料庫"

msgid "<primary>user</primary><secondary>database</secondary>"
msgstr "<primary>使用者</primary><secondary>資料庫</secondary>"

msgid "<primary>group</primary><secondary>database</secondary>"
msgstr "<primary>群組</primary><secondary>資料庫</secondary>"

msgid "<primary>database</primary><secondary>of users</secondary>"
msgstr "<primary>資料庫</primary><secondary>使用者</secondary>"

msgid "<primary>database</primary><secondary>of groups</secondary>"
msgstr "<primary>資料庫</primary><secondary>群組</secondary>"

msgid "The list of users is usually stored in the <filename>/etc/passwd</filename> file, while the <filename>/etc/shadow</filename> file stores encrypted passwords. Both are text files, in a relatively simple format, which can be read and modified with a text editor. Each user is listed there on a line with several fields separated with a colon (“<literal>:</literal>”)."
msgstr "使用者清單通常儲存在 <filename>/etc/passwd</filename> 檔案內，把編碼後的密碼儲存在 <filename>/etc/shadow</filename> 檔案內。這兩個檔案都是純文字檔，以簡單的格式儲存，可以用文字編輯器讀取與修改。每個使用者佔一列，其欄位以冒號區隔 (“<literal>:</literal>”)。"

msgid "<emphasis>NOTE</emphasis> Editing system files"
msgstr "<emphasis>說明</emphasis> 編輯系統檔案"

msgid "The system files mentioned in this chapter are all plain text files, and can be edited with a text editor. Considering their importance to core system functionality, it is always a good idea to take extra precautions when editing system files. First, always make a copy or backup of a system file before opening or altering it. Second, on servers or machines where more than one person could potentially access the same file at the same time, take extra steps to guard against file corruption."
msgstr "本章討論的系統檔案都是純文字檔，可以用文字編輯器處理。這些檔案對核心系統的運作極為重要，編輯該等檔案時多加慎重不會錯的。首先，先複製或備份原檔案。第二，在伺服器或多人可同時近用該等檔案的機器上，多費心以防止檔案損壞。"

msgid "For this purpose, it is enough to use the <command>vipw</command> command to edit the <filename>/etc/passwd</filename> file, or <command>vigr</command> to edit <filename>/etc/group</filename>. These commands lock the file in question prior to running the text editor, (<command>vi</command> by default, unless the <varname>EDITOR</varname> environment variable has been altered). The <literal>-s</literal> option in these commands allows editing the corresponding <foreignphrase>shadow</foreignphrase> file."
msgstr "為了達成此目標，最好使用 <command>vipw</command> 命令編輯 <filename>/etc/passwd</filename> 檔案，或使用 <command>vigr</command> 命令編輯 <filename>/etc/group</filename> 檔案。這些命令會先鎖住該等檔案再執行文字編輯器， (預設使用 <command>vi</command> 命令，除非 <varname>EDITOR</varname> 環境變數有其他的設定)。加上 <literal>-s</literal> 選項可同時編輯對應的 <foreignphrase>shadow</foreignphrase> 檔案。"

msgid "<emphasis>BACK TO BASICS</emphasis> Crypt, a one-way function"
msgstr "<emphasis>基本</emphasis> Crypt，單向的函數"

msgid "<primary>crypt</primary>"
msgstr "<primary>crypt</primary>"

msgid "<command>crypt</command> is a one-way function that transforms a string (<varname>A</varname>) into another string (<varname>B</varname>) in a way that <varname>A</varname> cannot be derived from <varname>B</varname>. The only way to identify <varname>A</varname> is to test all possible values, checking each one to determine if transformation by the function will produce <varname>B</varname> or not. It uses up to 8 characters as input (string <varname>A</varname>) and generates a string of 13, printable, ASCII characters (string <varname>B</varname>)."
msgstr "<command>crypt</command> 是單向函數以特別的方法把字串 (<varname>A</varname>) 轉換成另個字串 (<varname>B</varname>)，轉換後無法回覆成 <varname>A</varname> 經由 <varname>B</varname>。辨識 <varname>A</varname> 的唯一方法是逐一測試所有可能的值，查驗等同於 <varname>B</varname> 的結果。最多可輸入 8 個字元 (字串 <varname>A</varname>) 然後產生 13 個字元的可列印 ASCII 字元 (字串 <varname>B</varname>)。"

msgid "User List: <filename>/etc/passwd</filename>"
msgstr "使用者清單：<filename>/etc/passwd</filename>"

msgid "Here is the list of fields in the <filename>/etc/passwd</filename> file:"
msgstr "在 <filename>/etc/passwd</filename> 檔案內的欄位清單："

msgid "<primary><command>passwd</command></primary>"
msgstr "<primary><command>passwd</command></primary>"

msgid "<primary><filename>/etc/passwd</filename></primary>"
msgstr "<primary><filename>/etc/passwd</filename></primary>"

msgid "<primary><literal>uid</literal></primary>"
msgstr "<primary><literal>uid</literal></primary>"

msgid "<primary><literal>gid</literal></primary>"
msgstr "<primary><literal>gid</literal></primary>"

msgid "<primary><literal>GECOS</literal></primary>"
msgstr "<primary><literal>GECOS</literal></primary>"

msgid "<primary><literal>login</literal></primary>"
msgstr "<primary><literal>login</literal></primary>"

msgid "login, for example <literal>rhertzog</literal>;"
msgstr "登入，例如 <literal>rhertzog</literal>；"

msgid "password: this is a password encrypted by a one-way function (<command>crypt</command>), relying on <literal>DES</literal>, <literal>MD5</literal>, <literal>SHA-256</literal> or <literal>SHA-512</literal>. The special value “<literal>x</literal>” indicates that the encrypted password is stored in <filename>/etc/shadow</filename>;"
msgstr "password：就是密碼加密的單向函數 (<command>crypt</command>)，使用 <literal>DES</literal>、<literal>MD5</literal>、<literal>SHA-256</literal> 或 <literal>SHA-512</literal>。以特別符號 “<literal>x</literal>” 表示加密後的密碼儲存在<filename>/etc/shadow</filename>；"

msgid "<literal>uid</literal>: unique number identifying each user;"
msgstr "<literal>uid</literal>：用於辨識個別使用者的不重複數字；"

msgid "<literal>gid</literal>: unique number for the user's main group (Debian creates a specific group for each user by default);"
msgstr "<literal>gid</literal>：使用者主要群組 (Debian 的預設值係為每個使用者建立一個群組) 的不重複號碼；"

msgid "<literal>GECOS</literal>: data field usually containing the user's full name;"
msgstr "<literal>GECOS</literal>：通常儲存使用者全名的資料欄；"

msgid "login directory, assigned to the user for storage of their personal files (the environment variable <varname>$HOME</varname> generally points here);"
msgstr "登入資料夾，用於儲存使用者的個人檔案 (環境變數 <varname>$HOME</varname> 通常指向此處)；"

msgid "program to execute upon login. This is usually a command interpreter (shell), giving the user free rein. If you specify <command>/bin/false</command> (which does nothing and returns control immediately), the user cannot login."
msgstr "登入時執行的程式。通常是命令解譯器 (shell)，若指定為 <command>/bin/false</command> (不做任何事並立即回到控制)，則使用者無法登入。"

msgid "<emphasis>BACK TO BASICS</emphasis> Unix group"
msgstr "<emphasis>基本</emphasis> Unix 群組"

msgid "<primary>group</primary>"
msgstr "<primary>群組</primary>"

msgid "A Unix group is an entity including several users so that they can easily share files using the integrated permission system (by benefiting from the same rights). You can also restrict use of certain programs to a specific group."
msgstr "Unix 群組是包括多個使用者的實體，以整合授權系統可以共享檔案 (具有同樣的權限)。可以限定程式供指定的群組使用。"

msgid "The Hidden and Encrypted Password File: <filename>/etc/shadow</filename>"
msgstr "隱藏與加密的密碼檔：<filename>/etc/shadow</filename>"

msgid "<primary><filename>shadow</filename></primary>"
msgstr "<primary><filename>shadow</filename></primary>"

msgid "<primary><filename>/etc/shadow</filename></primary>"
msgstr "<primary><filename>/etc/shadow</filename></primary>"

msgid "The <filename>/etc/shadow</filename> file contains the following fields:"
msgstr "The <filename>/etc/shadow</filename> 檔案含以下的欄位："

msgid "login;"
msgstr "登入；"

msgid "encrypted password;"
msgstr "加密的密碼；"

msgid "several fields managing password expiration."
msgstr "管理密碼期限的欄位。"

msgid "<emphasis>DOCUMENTATION</emphasis> <filename>/etc/passwd</filename>, <filename>/etc/shadow</filename> and <filename>/etc/group</filename> file formats"
msgstr "<emphasis>文件</emphasis> <filename>/etc/passwd</filename>、<filename>/etc/shadow</filename> 與 <filename>/etc/group</filename> 檔案格式"

msgid "These formats are documented in the following man pages: <citerefentry><refentrytitle>passwd</refentrytitle><manvolnum>5</manvolnum></citerefentry>, <citerefentry><refentrytitle>shadow</refentrytitle><manvolnum>5</manvolnum></citerefentry>, and <citerefentry><refentrytitle>group</refentrytitle><manvolnum>5</manvolnum></citerefentry>."
msgstr "這些格式記錄在下列的手冊頁面：<citerefentry><refentrytitle>passwd</refentrytitle><manvolnum>5</manvolnum></citerefentry>、<citerefentry><refentrytitle>shadow</refentrytitle><manvolnum>5</manvolnum></citerefentry>、與 <citerefentry><refentrytitle>group</refentrytitle><manvolnum>5</manvolnum></citerefentry>。"

msgid "<emphasis>SECURITY</emphasis> <filename>/etc/shadow</filename> file security"
msgstr "<emphasis>安全</emphasis> <filename>/etc/shadow</filename> 檔案安全"

msgid "<filename>/etc/shadow</filename>, unlike its alter-ego, <filename>/etc/passwd</filename>, cannot be read by regular users. Any encrypted password stored in <filename>/etc/passwd</filename> is readable by anybody; a cracker could try to “break” (or reveal) a password by one of several “brute force” methods which, simply put, guess at commonly used combinations of characters. This attack — called a \"dictionary attack\" — is no longer possible on systems using <filename>/etc/shadow</filename>."
msgstr "<filename>/etc/shadow</filename>，不同於它的分身，<filename>/etc/passwd</filename>，不能被一般使用者讀取。儲存在 <filename>/etc/passwd</filename> 內的加密後密碼可被任何人讀取；破壞者可以用 “暴力” 法破壞它們，以常見的編碼字元破解。這種攻擊方式 — 稱為 \"字典攻擊\" — 對於使用 <filename>/etc/shadow</filename> 的系統是無效的。"

msgid "Modifying an Existing Account or Password"
msgstr "修改既有的帳號或密碼"

msgid "<primary><command>chsh</command></primary>"
msgstr "<primary><command>chsh</command></primary>"

msgid "<primary><command>chfn</command></primary>"
msgstr "<primary><command>chfn</command></primary>"

msgid "<primary><command>chage</command></primary>"
msgstr "<primary><command>chage</command></primary>"

msgid "<primary>password</primary>"
msgstr "<primary>密碼</primary>"

msgid "The following commands allow modification of the information stored in specific fields of the user databases: <command>passwd</command> permits a regular user to change their password, which in turn, updates the <filename>/etc/shadow</filename> file; <command>chfn</command> (CHange Full Name), reserved for the super-user (root), modifies the <literal>GECOS</literal> field. <command>chsh</command> (CHange SHell) allows the user to change their login shell, however available choices will be limited to those listed in <filename>/etc/shells</filename>; the administrator, on the other hand, is not bound by this restriction and can set the shell to any program of their choosing."
msgstr "以下的命令允許修改使用者資料庫內的特定欄位資料：<command>passwd</command> 允許使用者更改自己的密碼，並更新 <filename>/etc/shadow</filename> 檔案；<command>chfn</command> (CHange Full Name)，保留給超級使用者 (root) 專用，修改 <literal>GECOS</literal> 欄位。<command>chsh</command> (CHange SHell) 允許使用者變更自己的登入 shell，但祗限列名在 <filename>/etc/shells</filename> 之內；另一方面，管理者不受此限，且可設定任何 shell。"

msgid "Finally, the <command>chage</command> (CHange AGE) command allows the administrator to change the password expiration settings (the <literal>-l <replaceable>user</replaceable></literal> option will list the current settings). You can also force the expiration of a password using the <command>passwd -e <replaceable>user</replaceable></command> command, which will require the user to change their password the next time they log in."
msgstr "最後，<command>chage</command> (CHange AGE) 命令允許管理者變更密碼的有效期 (<literal>-l <replaceable>使用者</replaceable></literal> 選項列出現在的設定)。以 <command>passwd -e <replaceable>使用者</replaceable></command> 命令強迫密碼失效，要求使用者登錄時變更密碼才能繼續使用。"

msgid "Disabling an Account"
msgstr "帳號禁用"

msgid "<primary>Disable an account</primary>"
msgstr "<primary>禁用帳號</primary>"

msgid "<primary>account</primary><secondary>disable</secondary>"
msgstr "<primary>帳號</primary><secondary>禁用</secondary>"

msgid "You may find yourself needing to “disable an account” (lock out a user), as a disciplinary measure, for the purposes of an investigation, or simply in the event of a prolonged or definitive absence of a user. A disabled account means the user cannot login or gain access to the machine. The account remains intact on the machine and no files or data are deleted; it is simply inaccessible. This is accomplished by using the command <command>passwd -l <replaceable>user</replaceable></command> (lock). Re-enabling the account is done in similar fashion, with the <literal>-u</literal> option (unlock)."
msgstr "有時需要 “禁用一個帳號” (關閉某使用者)，基於紀律考量、調查、或使用者太久未登入。被禁用的帳號表示該使用者不能登入或近用該機器。帳號還在機器內且檔案與資料都未被刪除木；祗是不能使用。以 <command>passwd -l <replaceable>使用者</replaceable></command> (鎖定) 命令就能夠達成。以同樣的方式另個選項 <literal>-u</literal> (解鎖) 就可恢復該帳號。"

msgid "<emphasis>GOING FURTHER</emphasis> NSS and system databases"
msgstr "<emphasis>下一步</emphasis> NSS 與系統資料庫"

msgid "<primary>Name Service Switch</primary>"
msgstr "<primary>姓名服務切換</primary>"

msgid "Instead of using the usual files to manage lists of users and groups, you could use other types of databases, such as LDAP or <command>db</command>, by using an appropriate NSS (Name Service Switch) module. The modules used are listed in the <filename>/etc/nsswitch.conf</filename> file, under the <literal>passwd</literal>, <literal>shadow</literal> and <literal>group</literal> entries. See <xref linkend=\"sect.config-nss\" /> for a specific example of the use of an NSS module by LDAP."
msgstr "與其使用檔案管理使用者與群組清單，還可使用其他資料庫類型，諸如 LDAP 或 <command>db</command>，藉由適當的 NSS (Name Service Switch 姓名服務切換) 模組。可用的模組列在 <filename>/etc/nsswitch.conf</filename> 檔案內，在 <literal>passwd</literal>、<literal>shadow</literal> 與 <literal>group</literal> 款目下。LDAP 下的 NSS 模組使用法，見 <xref linkend=\"sect.config-nss\" />。"

msgid "Group List: <filename>/etc/group</filename>"
msgstr "群組清單：<filename>/etc/group</filename>"

msgid "Groups are listed in the <filename>/etc/group</filename> file, a simple textual database in a format similar to that of the <filename>/etc/passwd</filename> file, with the following fields:"
msgstr "群組列在 <filename>/etc/group</filename> 檔案內，單純的文字資料庫類似 <filename>/etc/passwd</filename> 檔案，包括以下的欄位："

msgid "group name;"
msgstr "群組名稱；"

msgid "password (optional): This is only used to join a group when one is not a usual member (with the <command>newgrp</command> or <command>sg</command> commands, see sidebar <xref linkend=\"sidebar.working-with-several-groups\" />);"
msgstr "密碼 (選項)：加入群組會用到 (以 <command>newgrp</command> 或 <command>sg</command> 命令，見專欄 <xref linkend=\"sidebar.working-with-several-groups\" />)；"

msgid "<literal>gid</literal>: unique group identification number;"
msgstr "<literal>gid</literal>：不重複的群組辨識碼；"

msgid "list of members: list of names of users who are members of the group, separated by commas."
msgstr "成員清單：屬於此群組的使用者名稱清單，以逗點區隔。"

msgid "<emphasis>BACK TO BASICS</emphasis> Working with several groups"
msgstr "<emphasis>基本</emphasis> 在多個群組工作"

msgid "<primary><command>newgrp</command></primary>"
msgstr "<primary><command>newgrp</command></primary>"

msgid "<primary><command>sg</command></primary>"
msgstr "<primary><command>sg</command></primary>"

msgid "<primary><command>id</command></primary>"
msgstr "<primary><command>id</command></primary>"

msgid "<primary>group</primary><secondary>change</secondary>"
msgstr "<primary>群組</primary><secondary>改變</secondary>"

msgid "Each user may be a member of many groups; one of them is their “main group”. A user's main group is, by default, created during initial user configuration. By default, each file that a user creates belongs to them, as well as to their main group. This is not always desirable; for example, when the user needs to work in a directory shared by a group other than their main group. In this case, the user needs to change their main group using one of the following commands: <command>newgrp</command>, which starts a new shell, or <command>sg</command>, which simply executes a command using the supplied alternate group. These commands also allow the user to join a group to which they do not belong. If the group is password protected, they will need to supply the appropriate password before the command is executed."
msgstr "終端使用者可能參加多個群組；其中一個是自己的 “主要群組”。使用者自己的主要群組，使用者初始組態時自動產生的預設值。使用者新增的檔案自動屬於該讀者，以及其主要群組。這種方式並不完全合意；例如，使用者需要在自己主要群組之外的資料夾工作，與其他群組共享其檔案。在這種情況下，使用者需以命令：<command>newgrp</command> 變更其主要群組，產生新的 shell，或以 <command>sg</command> 命令，使用其他群組。這些命令也允許使用者加入其他群組。若該等群組受密碼保護，則需先取得密碼才能執行該等命令。"

msgid "Alternatively, the user can set the <literal>setgid</literal> bit on the directory, which causes files created in that directory to automatically belong to the correct group. For more details, see sidebar <xref linkend=\"sidebar.setgid-dir\" />."
msgstr "使用者還可以設定資料夾的 <literal>setgid</literal> 位元，讓該資料夾內的檔案自動屬於特定群組。詳情見專欄 <xref linkend=\"sidebar.setgid-dir\" />。"

msgid "The <command>id</command> command displays the current state of a user, with their personal identifier (<varname>uid</varname> variable), current main group (<varname>gid</varname> variable), and the list of groups to which they belong (<varname>groups</varname> variable)."
msgstr "<command>id</command> 命令顯示使用者現在的狀態，包括個人辨識碼 (<varname>uid</varname> 變數)、現在的主要群組 (<varname>gid</varname> variable)、以及其所屬群組的清單 (<varname>groups</varname> 變數)。"

msgid "<primary><filename>group</filename></primary>"
msgstr "<primary><filename>group</filename></primary>"

msgid "<primary><filename>/etc/group</filename></primary>"
msgstr "<primary><filename>/etc/group</filename></primary>"

msgid "The <command>addgroup</command> and <command>delgroup</command> commands add or delete a group, respectively. The <command>groupmod</command> command modifies a group's information (its <literal>gid</literal> or identifier). The command <command>passwd -g <replaceable>group</replaceable></command> changes the password for the group, while the <command>passwd -r -g <replaceable>group</replaceable></command> command deletes it."
msgstr "<command>addgroup</command> 與 <command>delgroup</command> 命令可以新增或刪除群組。<command>groupmod</command> 命令修改群組的資訊 (其 <literal>gid</literal> 或辨識碼)。命令 <command>passwd -g <replaceable>group</replaceable></command> 可變更群組的密碼，<command>passwd -r -g <replaceable>group</replaceable></command> 命令可刪除群組的密碼。"

msgid "<primary><command>addgroup</command></primary>"
msgstr "<primary><command>addgroup</command></primary>"

msgid "<primary><command>delgroup</command></primary>"
msgstr "<primary><command>delgroup</command></primary>"

msgid "<primary><command>groupmod</command></primary>"
msgstr "<primary><command>groupmod</command></primary>"

msgid "<primary>group</primary><secondary>creation</secondary>"
msgstr "<primary>群組</primary><secondary>新增</secondary>"

msgid "<primary>creation</primary><secondary>of groups</secondary>"
msgstr "<primary>新增</primary><secondary>群組</secondary>"

msgid "<primary>group</primary><secondary>deletion</secondary>"
msgstr "<primary>群組</primary><secondary>刪除</secondary>"

msgid "<primary>deletion of a group</primary>"
msgstr "<primary>刪除群組</primary>"

msgid "<emphasis>TIP</emphasis> <command>getent</command>"
msgstr "<emphasis>秘訣</emphasis> <command>getent</command>"

msgid "<primary><command>getent</command></primary>"
msgstr "<primary><command>getent</command></primary>"

msgid "The <command>getent</command> (get entries) command checks the system databases the standard way, using the appropriate library functions, which in turn call the NSS modules configured in the <filename>/etc/nsswitch.conf</filename> file. The command takes one or two arguments: the name of the database to check, and a possible search key. Thus, the command <command>getent passwd rhertzog</command> will give the information from the user database regarding the user <literal>rhertzog</literal>."
msgstr "<command>getent</command> (取得款目的意思 get entries) 命令使用適當的程式庫函數，呼叫組態於 <filename>/etc/nsswitch.conf</filename> 檔案的 NSS 模組，以標準方式檢查系統資料庫。此命令需要一個或兩個參數：被檢查的資料庫名稱、以及可能的搜尋鍵詞。因此，<command>getent passwd rhertzog</command> 命令將從使用者 <literal>rhertzog</literal> 中給予使用者資料庫。"

msgid "Creating Accounts"
msgstr "新增帳號"

msgid "<primary>account</primary><secondary>creation</secondary>"
msgstr "<primary>帳號</primary><secondary>新增</secondary>"

msgid "<primary>creation</primary><secondary>of user accounts</secondary>"
msgstr "<primary>新增</primary><secondary>使用者帳號</secondary>"

msgid "One of the first actions an administrator needs to do when setting up a new machine is to create user accounts. This is typically done using the <command>adduser</command> command which takes a user-name for the new user to be created, as an argument."
msgstr "設定新機器後管理者需做的第一件事就是新增使用者帳號。以 <command>adduser</command> 命令新增使用者的名稱，做為其參數。"

msgid "<primary><command>adduser</command></primary>"
msgstr "<primary><command>adduser</command></primary>"

msgid "The <command>adduser</command> command asks a few questions before creating the account, but its usage is fairly straightforward. Its configuration file, <filename>/etc/adduser.conf</filename>, includes all the interesting settings: it can be used to automatically set a quota for each new user by creating a user template, or to change the location of user accounts; the latter is rarely useful, but it comes in handy when you have a large number of users and want to divide their accounts over several disks, for instance. You can also choose a different default shell."
msgstr "<command>adduser</command> 命令在新增帳號前先詢問若干問題，但其使用方式相當直覺。 <filename>/etc/adduser.conf</filename> 是它的組態檔，包括有趣的設定：可用於自動設定使用者的額度、或改變使用者帳號的位置；後者較少使用，但有多個使用者且需區隔該等帳號於若干硬碟時，就是很好用的工具。也可選擇不同的 shell 為預設值。"

msgid "<emphasis>BACK TO BASICS</emphasis> Quota"
msgstr "<emphasis>基本</emphasis> 額度"

msgid "<primary>quota</primary>"
msgstr "<primary>額度</primary>"

msgid "The term “quota” refers to a limit on machine resources that a user is allowed to use. This frequently refers to disk space."
msgstr "“額度” 指的是使用者在此機器可使用的資源上限。通常指的是磁碟空間。"

msgid "The creation of an account populates the user's home directory with the contents of the <filename>/etc/skel/</filename> template. This provides the user with a set of standard directories and configuration files."
msgstr "新增帳號時，把使用者的家目錄置於 <filename>/etc/skel/</filename> 模皮。提供使用者一組標準的資料夾與組態檔案。"

msgid "<primary>group</primary><secondary>add a user</secondary>"
msgstr "<primary>群組</primary><secondary>新增使用者</secondary>"

msgid "<primary>add a user to a group</primary>"
msgstr "<primary>新增群組的使用者</primary>"

msgid "In some cases, it will be useful to add a user to a group (other than their default “main” group) in order to grant them additional permissions. For example, a user who is included in the <emphasis>audio</emphasis> group can access audio devices (see sidebar <xref linkend=\"sidebar.special-files\" />). This can be achieved with a command such as <command>adduser <replaceable>user</replaceable> <replaceable>group</replaceable></command>."
msgstr "有的時候，把使用者加入群組 (除了自己預設的 “主要” 群組) 以取得額外的權限。例如，在 <emphasis>audio</emphasis> 群組內的使用者可以近用該群組內的音效設備 (見專欄 <xref linkend=\"sidebar.special-files\" />)。以 <command>adduser <replaceable>user</replaceable> <replaceable>group</replaceable></command> 命令就能把使用者加入該群組。"

msgid "<emphasis>BACK TO BASICS</emphasis> Device access permissions"
msgstr "<emphasis>基本</emphasis> 近用設備的權限"

msgid "<primary>device</primary><secondary>access permissions</secondary>"
msgstr "<primary>設備</primary><secondary>近用權限</secondary>"

msgid "<primary>file</primary><secondary>special</secondary>"
msgstr "<primary>檔案</primary><secondary>特別</secondary>"

msgid "<primary>mode</primary><secondary>character</secondary>"
msgstr "<primary>模式</primary><secondary>字元</secondary>"

msgid "<primary>mode</primary><secondary>block</secondary>"
msgstr "<primary>模式</primary><secondary>區塊</secondary>"

msgid "<primary>block, mode</primary>"
msgstr "<primary>區塊，模組</primary>"

msgid "<primary>character, mode</primary>"
msgstr "<primary>字元，模組</primary>"

msgid "<primary>special, file</primary>"
msgstr "<primary>特別，檔案</primary>"

msgid "<primary><command>mknod</command></primary>"
msgstr "<primary><command>mknod</command></primary>"

msgid "Each hardware peripheral device is represented under Unix with a special file, usually stored in the file tree under <filename>/dev/</filename> (DEVices). Two types of special files exist according to the nature of the device: “character mode” and “block mode” files, each mode allowing for only a limited number of operations. While character mode limits interaction with read/write operations, block mode also allows seeking within the available data. Finally, each special file is associated with two numbers (“major” and “minor”) that identify the device to the kernel in a unique manner. Such a file, created by the <command>mknod</command> command, simply contains a symbolic (and more human-friendly) name."
msgstr "每個週邊硬體設備在 Unix 之下，都是一個儲存在 <filename>/dev/</filename> (DEVices) 的特別檔案。根據設備的特性有兩種特別檔案：“字元模式” 與 “區塊模式” 檔案，每個模式都祗有固定數量的運算元。字元模式限制讀/寫運算，區塊模式還允許搜尋可得的資料。最後，每個特別檔案有兩個數字 (“主要” 與 “次要”) 供核心辨識該設備。這種檔案以 <command>mknod</command> 命令新增，包括符號名稱 (人類可以理解的符號)。"

msgid "The permissions of a special file map to the permissions necessary to access the device itself. Thus, a file such as <filename>/dev/mixer</filename>, representing the audio mixer, only has read/write permissions for the root user and members of the <literal>audio</literal> group. Only these users can operate the audio mixer."
msgstr "特別檔案的權限對映至近用設備本身的權限。因此，<filename>/dev/mixer</filename> 這個檔案代表混音器，祗有根使用者與 <literal>audio</literal> 群組的使用者擁有讀/取權限。且祗有該等使用者才能操作混音器。"

msgid "It should be noted that the combination of <emphasis role=\"pkg\">udev</emphasis>, <emphasis role=\"pkg\">consolekit</emphasis> and <emphasis role=\"pkg\">policykit</emphasis> can add additional permissions to allow users physically connected to the console (and not through the network) to access to certain devices."
msgstr "經由 <emphasis role=\"pkg\">udev</emphasis>、<emphasis role=\"pkg\">consolekit</emphasis> 與 <emphasis role=\"pkg\">policykit</emphasis> 指令，使用者就可以直接操作 (不經由網路) 這些設備。"

msgid "Shell Environment"
msgstr "Shell 環境"

msgid "Command interpreters (or shells) can be a user's first point of contact with the computer, and they must therefore be rather friendly. Most of them use initialization scripts that allow configuration of their behavior (automatic completion, prompt text, etc.)."
msgstr "命令解譯器 (或 shells) 是使用者接觸電腦的第一個點，必須足夠友善。大部份的人使用初始設定的腳本組態其行為 (自動完成、提示字元等)。"

msgid "<primary>command line interface</primary>"
msgstr "<primary>命令列介面</primary>"

msgid "<primary>command interpreter</primary>"
msgstr "<primary>命令解譯器</primary>"

msgid "<primary>shell</primary>"
msgstr "<primary>shell</primary>"

msgid "<primary><command>bash</command></primary>"
msgstr "<primary><command>bash</command></primary>"

msgid "<command>bash</command>, the standard shell, uses the <filename>/etc/bash.bashrc</filename> initialization script for “interactive” shells, and <filename>/etc/profile</filename> for “login” shells."
msgstr "<command>bash</command> 是標準的 shell，使用 <filename>/etc/bash.bashrc</filename> 初始腳本做為 “互動” shells，並以 <filename>/etc/profile</filename> 做為 “登入” shells。"

msgid "<emphasis>BACK TO BASICS</emphasis> Login shell and (non) interactive shell"
msgstr "<emphasis>基本</emphasis> 登入 shell 與 (非) 互動 shell"

msgid "In simple terms, a login shell is invoked when you login to the console either locally or remotely via <command>ssh</command>, or when you run an explicit <command>bash --login</command> command. Regardless of whether it is a login shell or not, a shell can be interactive (in an <command>xterm</command>-type terminal for instance); or non-interactive (when executing a script)."
msgstr "簡單說，不論在地登入或使用 <command>ssh</command> 遠端登入，或以 <command>bash --login</command> 命令登入，都啟用登入 shell。在 登入或非登入 shell 裡，該 shell 必須是互動的 (例如在 <command>xterm</command>-type 終端機內)；或非互動式 (使用執行式腳本)。"

msgid "<emphasis>DISCOVERY</emphasis> Other shells, other scripts"
msgstr "<emphasis>發現</emphasis> 其他 shells、其他腳本"

msgid "Each command interpreter has a specific syntax and its own configuration files. Thus, <command>zsh</command> uses <filename>/etc/zshrc</filename> and <filename>/etc/zshenv</filename>; <command>csh</command> uses <filename>/etc/csh.cshrc</filename>, <filename>/etc/csh.login</filename> and <filename>/etc/csh.logout</filename>. The man pages for these programs document which files they use."
msgstr "命令解譯器有自己的語法及其組態檔案。因此，<command>zsh</command> 使用 <filename>/etc/zshrc</filename> 與 <filename>/etc/zshenv</filename>；<command>csh</command> 使用 <filename>/etc/csh.cshrc</filename>、<filename>/etc/csh.login</filename> 與 <filename>/etc/csh.logout</filename>。這些程式的手冊頁面詳述其用法。"

msgid "<primary><command>zsh</command></primary>"
msgstr "<primary><command>zsh</command></primary>"

msgid "<primary><command>csh</command></primary>"
msgstr "<primary><command>csh</command></primary>"

msgid "For <command>bash</command>, it is useful to activate “automatic completion” in the <filename>/etc/bash.bashrc</filename> file (simply uncomment a few lines)."
msgstr "<command>bash</command> 啟用 <filename>/etc/bash.bashrc</filename> 檔案 (未評論的幾列) 內的 “自動完成”。"

msgid "<emphasis>BACK TO BASICS</emphasis> Automatic completion"
msgstr "<emphasis>基本</emphasis> 自動補完"

msgid "<primary>automatic completion</primary>"
msgstr "<primary>自動補完</primary>"

msgid "Many command interpreters provide a completion feature, which allows the shell to automatically complete a partially typed command name or argument when the user hits the <keycap>Tab</keycap> key. This lets users work more efficiently and be less error-prone."
msgstr "若干命令解譯器提供補完功能，即鍵入命令前幾個字後，使用者按 <keycap>Tab</keycap> 後，shell 自動補完命令名稱或參數。使用者的工作更有效率且更少錯誤。"

msgid "This function is very powerful and flexible. It is possible to configure its behavior according to each command. Thus, the first argument following <command>apt-get</command> will be proposed according to the syntax of this command, even if it does not match any file (in this case, the possible choices are <literal>install</literal>, <literal>remove</literal>, <literal>upgrade</literal>, etc.)."
msgstr "此函數極有用並富彈性。可根據每個命令分別組態。因此，<command>apt-get</command> 之後的第一個參數，可根據此命令的語法布建，即使未對映任何檔案 (在本例中，可能的選擇為 <literal>install</literal>、<literal>remove</literal>、<literal>upgrade</literal>等)。"

msgid "<emphasis>BACK TO BASICS</emphasis> The tilde, a shortcut to HOME"
msgstr "<emphasis>基本</emphasis> 波浪號，回到家資料夾的捷徑"

msgid "<primary>~</primary>"
msgstr "<primary>~</primary>"

msgid "<primary>tilde</primary>"
msgstr "<primary>波浪號</primary>"

msgid "The tilde is often used to indicate the directory to which the environment variable, <varname>HOME</varname>, points (being the user's home directory, such as <filename>/home/rhertzog/</filename>). Command interpreters automatically make the substitution: <filename>~/hello.txt</filename> becomes <filename>/home/rhertzog/hello.txt</filename>."
msgstr "波浪號通常用於表示環境變數 <varname>HOME</varname> 指向 (就是使用者的家資料夾，如 <filename>/home/rhertzog/</filename>) 的資料夾。命令解譯器自動取代：<filename>~/hello.txt</filename> 就是 <filename>/home/rhertzog/hello.txt</filename>。"

msgid "The tilde also allows access to another user's home directory. Thus, <filename>~rmas/bonjour.txt</filename> is synonymous with <filename>/home/rmas/bonjour.txt</filename>."
msgstr "波浪號也可近用至另個使用者的家資料夾。因此，<filename>~rmas/bonjour.txt</filename> 等於 <filename>/home/rmas/bonjour.txt</filename>。"

msgid "In addition to these common scripts, each user can create their own <filename>~/.bashrc</filename> and <filename>~/.bash_profile</filename> to configure their shell. The most common changes are the addition of aliases; these are words that are automatically replaced with the execution of a command, which makes it faster to invoke that command. For instance, you could create the <literal>la</literal> alias for the command <command>ls -la | less</command> command; then you only have to type <command>la</command> to inspect the contents of a directory in detail."
msgstr "除了這些常見的腳本，使用者還可以建立自己的 <filename>~/.bashrc</filename> 與 <filename>~/.bash_profile</filename> 來組態其 shell。常見的改變是新增別名；即自動取代執行的命令，以加速命令的效率。例如，新增 <literal>la</literal>  別名取代 <command>ls -la | less</command> 命令後，祗需鍵入 <command>la</command> 就能檢視資料夾內容的詳情。"

msgid "<emphasis>BACK TO BASICS</emphasis> Environment variables"
msgstr "<emphasis>基本</emphasis> 環境變數"

msgid "<primary>environment</primary><secondary>environment variable</secondary>"
msgstr "<primary>環境</primary><secondary>環境變數</secondary>"

msgid "<primary>variable, environment</primary>"
msgstr "<primary>變數，環境</primary>"

msgid "Environment variables allow storage of global settings for the shell or various other programs called. They are contextual (each process has its own set of environment variables) but inheritable. This last characteristic offers the possibility for a login shell to declare variables which will be passed down to all programs it executes."
msgstr "環境變數儲存供 shell 或其他程式使用的全域設定。它們是與環境相關的 (每個程序都有自己的環境變數) 但可繼承的。最後這個特性讓登入 shell 時可以宣告繼承所有程式的變數。"

msgid "Setting default environment variables is an important element of shell configuration. Leaving aside the variables specific to a shell, it is preferable to place them in the <filename>/etc/environment</filename> file, since it is used by the various programs likely to initiate a shell session. Variables typically defined there include <varname>ORGANIZATION</varname>, which usually contains the name of the company or organization, and <varname>HTTP_PROXY</varname>, which indicates the existence and location of an HTTP proxy."
msgstr "設定預設的環境變數是 shell 組態的重要工作。除了把變數指定給 shell 之外，還可以放在 <filename>/etc/environment</filename> 檔案內，以備供啟始 shell 的其他程式使用。設定的變數通常包括 <varname>ORGANIZATION</varname>，包括公司或組織的名稱；以及 <varname>HTTP_PROXY</varname>，指示 HTTP 代理伺服器的位置。"

msgid "<emphasis>TIP</emphasis> All shells configured identically"
msgstr "<emphasis>秘訣</emphasis> 所有的 shells 擁有相同的組態"

msgid "Users often want to configure their login and interactive shells in the same way. To do this, they choose to interpret (or “source”) the content from <filename>~/.bashrc</filename> in the <filename>~/.bash_profile</filename> file. It is possible to do the same with files common to all users (by calling <filename>/etc/bash.bashrc</filename> from <filename>/etc/profile</filename>)."
msgstr "使用者通常以相同的方式登入與互動 shell。所以，從 <filename>~/.bashrc</filename> 裡的 <filename>~/.bash_profile</filename> 檔案選擇解譯器 (或 “來源”) 的內容。也可使用適用於所有使用者的檔案 (呼叫 <filename>/etc/bash.bashrc</filename> 源自 <filename>/etc/profile</filename>)。"

msgid "Printer Configuration"
msgstr "列表機組態"

msgid "<primary>configuration</primary><secondary>printing</secondary>"
msgstr "<primary>組態</primary><secondary>列印</secondary>"

msgid "<primary>printing</primary><secondary>configuration</secondary>"
msgstr "<primary>列印</primary><secondary>組態</secondary>"

msgid "Printer configuration used to cause a great many headaches for administrators and users alike. These headaches are now mostly a thing of the past, thanks to <emphasis role=\"pkg\">cups</emphasis>, the free print server using the IPP protocol (Internet Printing Protocol)."
msgstr "組態印表機是管理者與使用者頭痛的項目之一。感謝 IPP 協定 (Internet Printing Protocol) 的自由印表機伺服器 <emphasis role=\"pkg\">cups</emphasis>，這些頭痛已過去了。"

msgid "<primary>IPP</primary>"
msgstr "<primary>IPP</primary>"

msgid "<primary>Internet Printing Protocol</primary>"
msgstr "<primary>Internet Printing Protocol</primary>"

msgid "<primary><command>cups</command></primary>"
msgstr "<primary><command>cups</command></primary>"

msgid "This program is divided over several Debian packages: <emphasis role=\"pkg\">cups</emphasis> is the central print server; <emphasis role=\"pkg\">cups-bsd</emphasis> is a compatibility layer allowing use of commands from the traditional BSD printing system (<command>lpd</command> daemon, <command>lpr</command> and <command>lpq</command> commands, etc.); <emphasis role=\"pkg\">cups-client</emphasis> contains a group of programs to interact with the server (block or unblock a printer, view or delete print jobs in progress, etc.); and finally, <emphasis role=\"pkg\">cups-driver-gutenprint</emphasis> contains a collection of additional printer drivers for <command>cups</command>."
msgstr "此程式分散在若干 Debian 套件中：<emphasis role=\"pkg\">cups</emphasis> 是中央印表伺服器；<emphasis role=\"pkg\">cups-bsd</emphasis> 是使用傳統 BSD 列印系統 (<command>lpd</command> 後台進程、<command>lpr</command> 與 <command>lpq</command> 等命令) 命令的相容層；<emphasis role=\"pkg\">cups-client</emphasis> 包括一群與伺服器互動 (攔阻或放行印表機、檢視或刪除進行中的印表工作等) 的程式；最後，<emphasis role=\"pkg\">cups-driver-gutenprint</emphasis> 包括給 <command>cups</command> 使用的其他印表機驅動程式集。"

msgid "<primary><command>lpr</command></primary>"
msgstr "<primary><command>lpr</command></primary>"

msgid "<primary><command>lpd</command></primary>"
msgstr "<primary><command>lpd</command></primary>"

msgid "<primary><command>lpq</command></primary>"
msgstr "<primary><command>lpq</command></primary>"

msgid "<emphasis>COMMUNITY</emphasis> CUPS"
msgstr "<emphasis>社群</emphasis> CUPS"

msgid "<primary>CUPS</primary>"
msgstr "<primary>CUPS</primary>"

msgid "<primary>Common Unix Printing System</primary>"
msgstr "<primary>通用 Unix 列印系統</primary>"

msgid "CUPS (Common Unix Printing System) is a project (and a trademark) managed by Apple, Inc. <ulink type=\"block\" url=\"http://www.cups.org/\" />"
msgstr "CUPS (通用 Unix 列印系統, Common Unix Printing System) 是蘋果公司管理的計畫 (與商標)。<ulink type=\"block\" url=\"http://www.cups.org/\" />"

msgid "After installation of these different packages, <command>cups</command> is administered easily through a web interface accessible at the local address: <literal>http://localhost:631/</literal>. There you can add printers (including network printers), remove, and administer them. You can also administer <command>cups</command> with the graphical interface provided by the desktop environment. Finally, there is also the <command>system-config-printer</command> graphical interface (from the Debian package of the same name)."
msgstr "組態這些套件後，可經由網頁介面進入本地位址就能管理 <command>cups</command>：<literal>http://localhost:631/</literal>。可以新增、移除與管理印表機 (包括網路印表機)。也可以在桌面環境以圖形介面管理 <command>cups</command>。最後，還有 <command>system-config-printer</command> 圖形介面 (來自同名的 Debian 套件) 可用。"

msgid "<primary><command>cups</command></primary><secondary>administration</secondary>"
msgstr "<primary><command>cups</command></primary><secondary>管理</secondary>"

msgid "<emphasis>NOTE</emphasis> Obsolescence of <filename>/etc/printcap</filename>"
msgstr "<emphasis>說明</emphasis> 過時的 <filename>/etc/printcap</filename>"

msgid "<emphasis>cups</emphasis> no longer uses the <filename>/etc/printcap</filename> file, which is now obsolete. Programs that rely upon this file to get a list of available printers will, thus, fail. To avoid this problem, delete this file and make it a symbolic link (see sidebar <xref linkend=\"sidebar.symbolic-link\" />) to <filename>/var/run/cups/printcap</filename>, which is maintained by <emphasis>cups</emphasis> to ensure compatibility."
msgstr "<emphasis>cups</emphasis> 不再使用已經過時的 <filename>/etc/printcap</filename> 檔案。從此檔案取得的可用印表機已過時不合用。為了避免此麻燸，應刪除此檔案並連結 (見專欄 <xref linkend=\"sidebar.symbolic-link\" />) 至 <filename>/var/run/cups/printcap</filename>，由 <emphasis>cups</emphasis> 維護該檔案以確保其相容性。"

msgid "<primary><filename>printcap</filename></primary>"
msgstr "<primary><filename>printcap</filename></primary>"

msgid "Configuring the Bootloader"
msgstr "組態 Bootloader"

msgid "<primary>loader</primary><secondary>bootloader</secondary>"
msgstr "<primary>安裝器</primary><secondary>啟動載入器</secondary>"

msgid "<primary>bootloader</primary>"
msgstr "<primary>啟動載入器</primary>"

msgid "It is probably already functional, but it is always good to know how to configure and install the bootloader in case it disappears from the Master Boot Record. This can occur after installation of another operating system, such as Windows. The following information can also help you to modify the bootloader configuration if needed."
msgstr "或許已經運作了，但最好知道如何組態與安裝載入啟動器，萬一它不在 Master Boot Record 中。安裝 Windows 等其他作業系統後，很可能出現這種情況。以下的資訊在必要時可協助修改載入啟動器組態。"

msgid "<emphasis>BACK TO BASICS</emphasis> Master boot record"
msgstr "<emphasis>基本</emphasis> Master boot record"

msgid "<primary>MBR</primary>"
msgstr "<primary>MBR</primary>"

msgid "<primary>Master Boot Record</primary>"
msgstr "<primary>Master Boot Record</primary>"

msgid "The Master Boot Record (MBR) occupies the first 512 bytes of the first hard disk, and is the first thing loaded by the BIOS to hand over control to a program capable of booting the desired operating system. In general, a bootloader gets installed in the MBR, removing its previous content."
msgstr "主開機記錄 (Master Boot Record, MBR) 位於第一顆磁碟的最前方 512 位元組，首先被 BIOS 載入，再啟動作業系統。一般來說，由主開機記錄安裝啟動程式，移除稍早的內容。"

msgid "Identifying the Disks"
msgstr "辨識磁碟"

msgid "<emphasis>CULTURE</emphasis> <emphasis>udev</emphasis> and <filename>/dev/</filename>"
msgstr "<emphasis>文化</emphasis> <emphasis>udev</emphasis> 與 <filename>/dev/</filename>"

msgid "The <filename>/dev/</filename> directory traditionally houses so-called “special” files, intended to represent system peripherals (see sidebar <xref linkend=\"sidebar.special-files\" />). Once upon a time, it used to contain all special files that could potentially be used. This approach had a number of drawbacks among which the fact that it restricted the number of devices that one could use (due to the hardcoded list of names), and that it was impossible to know which special files were actually useful."
msgstr "<filename>/dev/</filename> 資料夾習慣儲存被稱為 “特殊的” 檔案，用於代表系統的週邊裝置 (見專欄 <xref linkend=\"sidebar.special-files\" />)。曾經納入所有可能用到的特殊檔案。這種處理方式有若干缺點，限制設備數量是其中之一，每種設備祗能有一個 (因為清單名稱被限制)，且不可能知道實際上該用那個特殊檔案。"

msgid "Nowadays, the management of special files is entirely dynamic and matches better the nature of hot-swappable computer devices. The kernel cooperates with <emphasis>udev</emphasis> to create and delete them as needed when the corresponding devices appear and disappear. For this reason, <filename>/dev/</filename> doesn't need to be persistent and is thus a RAM-based filesystem that starts empty and contains only the relevant entries."
msgstr "如今，以動態方式管理特殊的檔案，並且更適合熱切換的電腦設備。核心與 <emphasis>udev</emphasis> 合作在需要的時候新增與刪除檔案以對映出現或消失的設備。所以，<filename>/dev/</filename> 不需要維持不變，反而採用 RAM 儲存的檔案系統清除或納入相關的款目。"

msgid "The kernel communicates lots of information about any newly added device and hands out a pair of major/minor numbers to identify it. With this <command>udevd</command> can create the special file under the name and with the permissions that it wants. It can also create aliases and perform additional actions (such as initialization or registration tasks). <command>udevd</command>'s behavior is driven by a large set of (customizable) rules."
msgstr "核心與新增的設備溝通，並發給主要/次要號碼以供辨識。以 <command>udevd</command> 命令可以新增特殊的檔案並授權使用它。也可新增別名執行其他的工作 (諸如初始化或登錄工作)。<command>udevd</command> 命令的行為由一組 (可客製化) 的規則驅動。"

msgid "With dynamically assigned names, you can thus keep the same name for a given device, regardless of the connector used or the connection order, which is especially useful when you use various USB peripherals. The first partition on the first hard drive can then be called <filename>/dev/sda1</filename> for backwards compatibility, or <filename>/dev/root-partition</filename> if you prefer, or even both at the same time since <command>udevd</command> can be configured to automatically create a symbolic link."
msgstr "動態給予名稱，就能夠讓同名稱永遠指向特定設備，不必在意連結的設備或順序，尤其在使用 USB 週邊時更為便利。第一個磁碟的第一個區塊稱為 <filename>/dev/sda1</filename> 可供向後相容，喜歡的話也可稱為 <filename>/dev/root-partition</filename>，或兩者共用，因為 <command>udevd</command> 可以組態成自動新增符號連結。"

msgid "In ancient times, some kernel modules did automatically load when you tried to access the corresponding device file. This is no longer the case, and the peripheral's special file no longer exists prior to loading the module; this is no big deal, since most modules are loaded on boot thanks to automatic hardware detection. But for undetectable peripherals (such as very old disk drives or PS/2 mice), this doesn't work. Consider adding the modules, <literal>floppy</literal>, <literal>psmouse</literal> and <literal>mousedev</literal> to <filename>/etc/modules</filename> in order to force loading them on boot."
msgstr "過去在需要進入特定設備檔案時，部份的核心模組無法自動載入。現在情況已變了，週邊設備的特殊檔案於載入模組時才會存在；所以問題不大，受惠於自動偵測硬體，大部份模組都可於啟動時載入。但對於偵測不到的週邊 (諸如極舊的磁碟機或 PS/2 滑鼠)，則無效。在此情況下，就需新增 <literal>floppy</literal>、<literal>psmouse</literal> 與 <literal>mousedev</literal> 等模組至 <filename>/etc/modules</filename> 才能於啟動時強迫載入。"

msgid "<primary>hard drive, names</primary>"
msgstr "<primary>硬碟，名稱</primary>"

msgid "<primary>names</primary><secondary>of hard drives</secondary>"
msgstr "<primary>名稱</primary><secondary>硬式磁碟機</secondary>"

msgid "Configuration of the bootloader must identify the different hard drives and their partitions. Linux uses “block” special files stored in the <filename>/dev/</filename> directory, for this purpose. Since Debian <emphasis role=\"distribution\">Squeeze</emphasis>, the naming scheme for hard drives has been unified by the Linux kernel, and all hard drives (IDE/PATA, SATA, SCSI, USB, IEEE 1394) are now represented by <filename>/dev/sd*</filename>."
msgstr "組態啟動程式必須辨認硬碟及其分區。Linux 使用 “block” 特殊檔案儲存在 <filename>/dev/</filename> 資料夾內。因為 Debian <emphasis role=\"distribution\">Squeeze</emphasis> 版本使用源自 Linux 核心的硬碟命名架構，所有的硬碟 (IDE/PATA、SATA、SCSI、USB、IEEE 1394) 都以 <filename>/dev/sd*</filename> 表示。"

msgid "Each partition is represented by its number on the disk on which it resides: for instance, <filename>/dev/sda1</filename> is the first partition on the first disk, and <filename>/dev/sdb3</filename> is the third partition on the second disk."
msgstr "每個分區由其磁碟代號表示：如，<filename>/dev/sda1</filename> 是第一個磁碟的第一個分區，而 <filename>/dev/sdb3</filename> 是第二個磁碟的第三個分區。"

msgid "<primary>partition</primary><secondary>primary</secondary>"
msgstr "<primary>分區</primary><secondary>主要</secondary>"

msgid "<primary>partition</primary><secondary>extended</secondary>"
msgstr "<primary>分區</primary><secondary>延伸</secondary>"

msgid "<primary>partition</primary><secondary>secondary</secondary>"
msgstr "<primary>分區</primary><secondary>次要</secondary>"

msgid "<primary>partition table</primary><secondary>MS-DOS format</secondary>"
msgstr "<primary>分區表</primary><secondary>MS-DOS 格式</secondary>"

msgid "The PC architecture (or “i386”, including its younger cousin “amd64”) has long been limited to using the “MS-DOS” partition table format, which only allows four “primary” partitions per disk. To go beyond this limitation under this scheme, one of them has to be created as an “extended” partition, and it can then contain additional “secondary” partitions. These secondary partitions are numbered from 5. Thus the first secondary partition could be <filename>/dev/sda5</filename>, followed by <filename>/dev/sda6</filename>, etc."
msgstr "PC 架構 (或 “i386”，包括新出現的 “amd64”) 不再受限於使用 “MS-DOS” 分區表格式，每個磁碟可以擁有超過 4 個 “主要” 分區。在此架構下要超過此限制，必須新增 “延伸” 分區，然後就能使用新增的 “次要” 分區。這些次要分區由 5 開始編號。所以，第一個磁碟的次要分區可以是 <filename>/dev/sda5</filename>，然後是 <filename>/dev/sda6</filename>，餘此類推。"

msgid "Another restriction of the MS-DOS partition table format is that it only allows disks up to 2 TiB in size, which is becoming a real problem with recent disks."
msgstr "MS-DOS 分區表格式的另個限制是磁碟的容量不能超過 2 TiB，成為當代磁碟的真正問題。"

msgid "<primary>GPT</primary><secondary>partition table format</secondary>"
msgstr "<primary>GPT</primary><secondary>分區表格式</secondary>"

msgid "<primary>partition table</primary><secondary>GPT format</secondary>"
msgstr "<primary>分區表</primary><secondary>GPT 格式</secondary>"

msgid "A new partition table format called GPT loosens these constraints on the number of partitions (it allows up to 128 partitions when using standard settings) and on the size of the disks (up to 8 ZiB, which is more than 8 billion terabytes). If you intend to create many physical partitions on the same disk, you should therefore ensure that you are creating the partition table in the GPT format when partitioning your disk."
msgstr "GPT 是新的分區表格式，解放對區分數的限制 (標準方式最多可以設定 128 個區分) 以及磁碟容量的限制 (最多達 8 ZiB，超過 8 百萬兆位元組)。若想在一個磁碟切出多個實體區分，必須以 GPT 格式新增分區表。"

msgid "It is not always easy to remember what disk is connected to which SATA controller, or in third position in the SCSI chain, especially since the naming of hotplugged hard drives (which includes among others most SATA disks and external disks) can change from one boot to another. Fortunately, <command>udev</command> creates, in addition to <filename>/dev/sd*</filename>, symbolic links with a fixed name, which you could then use if you wished to identify a hard drive in a non-ambiguous manner. These symbolic links are stored in <filename>/dev/disk/by-id</filename>. On a machine with two physical disks, for example, one could find the following:"
msgstr "不容易記得磁碟掛在 SATA 控制卡的位置，或在 SCSI 鏈的第三個位置，尤其是熱插拔硬式磁碟機 (包括 SATA 磁碟與外掛磁碟) 可改變開機的位置。還好，<command>udev</command> 以固定的名稱，新增 <filename>/dev/sd*</filename> 以外的符號連結，就能夠輕易的辨識硬式磁碟機。這種符號連結儲存在 <filename>/dev/disk/by-id</filename> 之內。例如，在兩個實體磁碟的機器，可以找到如下的訊息："

msgid ""
"<computeroutput>mirexpress:/dev/disk/by-id# </computeroutput><userinput>ls -l\n"
"</userinput><computeroutput>total 0\n"
"lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP -&gt; ../../sda\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697 -&gt; ../../sdb\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part1 -&gt; ../../sdb1\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part2 -&gt; ../../sdb2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP -&gt; ../../sda\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697 -&gt; ../../sdb\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part1 -&gt; ../../sdb1\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part2 -&gt; ../../sdb2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0 -&gt; ../../sdc\n"
"lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part1 -&gt; ../../sdc1\n"
"lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part2 -&gt; ../../sdc2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9 23 jul. 08:58 wwn-0x5000c50015c4842f -&gt; ../../sda\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 wwn-0x5000c50015c4842f-part1 -&gt; ../../sda1\n"
"[...]\n"
"mirexpress:/dev/disk/by-id# </computeroutput>"
msgstr ""
"<computeroutput>mirexpress:/dev/disk/by-id# </computeroutput><userinput>ls -l\n"
"</userinput><computeroutput>total 0\n"
"lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP -&gt; ../../sda\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697 -&gt; ../../sdb\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part1 -&gt; ../../sdb1\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part2 -&gt; ../../sdb2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP -&gt; ../../sda\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697 -&gt; ../../sdb\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part1 -&gt; ../../sdb1\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part2 -&gt; ../../sdb2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0 -&gt; ../../sdc\n"
"lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part1 -&gt; ../../sdc1\n"
"lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part2 -&gt; ../../sdc2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9 23 jul. 08:58 wwn-0x5000c50015c4842f -&gt; ../../sda\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 wwn-0x5000c50015c4842f-part1 -&gt; ../../sda1\n"
"[...]\n"
"mirexpress:/dev/disk/by-id# </computeroutput>"

msgid "Note that some disks are listed several times (because they behave simultaneously as ATA disks and SCSI disks), but the relevant information is mainly in the model and serial numbers of the disks, from which you can find the peripheral file."
msgstr "同顆磁碟出現多次 (因為它們同時做為 ATA 磁碟與 SCSI 磁碟)，但是根據磁碟的型號與序號等相關資訊，就可找到對應的週邊裝置檔案。"

msgid "The example configuration files given in the following sections are based on the same setup: a single SATA disk, where the first partition is an old Windows installation and the second contains Debian GNU/Linux."
msgstr "下節的組態檔根據同樣的設定而來：一個 SATA 磁碟，第一個區分是安裝舊型的視窗、第二個分區安裝 Debian GNU/Linux。"

msgid "Configuring LILO"
msgstr "組態 LILO"

msgid "<primary>LILO</primary>"
msgstr "<primary>LILO</primary>"

msgid "<primary>Linux Loader</primary>"
msgstr "<primary>Linux 載入器</primary>"

msgid "<emphasis>LILO</emphasis> (LInux LOader) is the oldest bootloader — solid but rustic. It writes the physical address of the kernel to boot on the MBR, which is why each update to LILO (or its configuration file) must be followed by the command <command>lilo</command>. Forgetting to do so will render a system unable to boot if the old kernel was removed or replaced as the new one will not be in the same location on the disk."
msgstr "<emphasis>LILO</emphasis> (Linux 啟動程式, LInux LOader) 是最舊的啟動程式 — 穩定但粗糙。把核心的實體位址寫入 MBR 的啟動，所以每次更新至 LILO (或其組態檔案) 都必須再執行命令 <command>lilo</command>。忘記的話，移除或更新核心後，新的核心就不會在磁碟的原來位置，以致系統無法啟動。"

msgid "LILO's configuration file is <filename>/etc/lilo.conf</filename>; a simple file for standard configuration is illustrated in the example below."
msgstr "LILO 的組態檔是 <filename>/etc/lilo.conf</filename>；一個簡單的檔案供標準組態之用，如下例。"

msgid "LILO configuration file"
msgstr "LILO 組態檔案"

msgid ""
"\n"
"# The disk on which LILO should be installed.\n"
"# By indicating the disk and not a partition.\n"
"# you order LILO to be installed on the MBR.\n"
"boot=/dev/sda\n"
"# the partition that contains Debian\n"
"root=/dev/sda2\n"
"# the item to be loaded by default\n"
"default=Linux\n"
"\n"
"# the most recent kernel image\n"
"image=/vmlinuz\n"
"  label=Linux\n"
"  initrd=/initrd.img\n"
"  read-only\n"
"\n"
"# Old kernel (if the newly installed kernel doesn't boot)\n"
"image=/vmlinuz.old\n"
"  label=LinuxOLD\n"
"  initrd=/initrd.img.old\n"
"  read-only\n"
"  optional\n"
"\n"
"# only for Linux/Windows dual boot\n"
"other=/dev/sda1\n"
"  label=Windows"
msgstr ""
"\n"
"# The disk on which LILO should be installed.\n"
"# By indicating the disk and not a partition.\n"
"# you order LILO to be installed on the MBR.\n"
"boot=/dev/sda\n"
"# the partition that contains Debian\n"
"root=/dev/sda2\n"
"# the item to be loaded by default\n"
"default=Linux\n"
"\n"
"# the most recent kernel image\n"
"image=/vmlinuz\n"
"  label=Linux\n"
"  initrd=/initrd.img\n"
"  read-only\n"
"\n"
"# Old kernel (if the newly installed kernel doesn't boot)\n"
"image=/vmlinuz.old\n"
"  label=LinuxOLD\n"
"  initrd=/initrd.img.old\n"
"  read-only\n"
"  optional\n"
"\n"
"# only for Linux/Windows dual boot\n"
"other=/dev/sda1\n"
"  label=Windows"

msgid "GRUB 2 Configuration"
msgstr "GRUB 2 組態"

msgid "<primary>GRUB</primary>"
msgstr "<primary>GRUB</primary>"

msgid "<primary>GRUB 2</primary>"
msgstr "<primary>GRUB 2</primary>"

msgid "<emphasis>GRUB</emphasis> (GRand Unified Bootloader) is more recent. It is not necessary to invoke it after each update of the kernel; <emphasis>GRUB</emphasis> knows how to read the filesystems and find the position of the kernel on the disk by itself. To install it on the MBR of the first disk, simply type <command>grub-install /dev/sda</command>. <indexterm><primary><command>grub-install</command></primary></indexterm>"
msgstr "<emphasis>GRUB</emphasis> (GRand Unified Bootloader) 是最近的事。更新核心後不必再啟動它；<emphasis>GRUB</emphasis> 知道如何讀取檔案系統並找到核心在磁碟的位置。鍵入 <command>grub-install /dev/sda</command> 命令就能夠把它安裝在第一個磁碟的 MBR。<indexterm><primary><command>grub-install</command></primary></indexterm>"

msgid "<emphasis>NOTE</emphasis> Disk names for GRUB"
msgstr "<emphasis>說明</emphasis> GRUB 的磁碟名稱"

msgid "GRUB can only identify hard drives based on information provided by the BIOS. <literal>(hd0)</literal> corresponds to the first disk thus detected, <literal>(hd1)</literal> the second, etc. In most cases, this order corresponds exactly to the usual order of disks under Linux, but problems can occur when you associate SCSI and IDE disks. GRUB stores correspondences that it detects in the file <filename>/boot/grub/device.map</filename>. If you find errors there (because you know that your BIOS detects drives in a different order), correct them manually and run <command>grub-install</command> again. <command>grub-mkdevicemap</command> can help creating a <filename>device.map</filename> file from which to start."
msgstr "GRUB 祗能根據 BIOS 提供的資訊辨識硬式磁碟機。<literal>(hd0)</literal> 對應偵測到的第一個磁碟、<literal>(hd1)</literal> 第二個磁碟等。大部份的情況下，此順序剛好是 Linux 的磁碟順序，同時使用 SCSI 與 IDE 磁碟時就出問題。GRUB 把偵測到的資訊儲存在 <filename>/boot/grub/device.map</filename> 檔案內。若在此發現錯誤 (因為已知 BIOS 以不同的順序偵測到磁碟)，再次執行 <command>grub-install</command> 命令。<command>grub-mkdevicemap</command> 命令可新增 <filename>device.map</filename> 檔案。"

msgid "Partitions also have a specific name in GRUB. When you use “classical” partitions in MS-DOS format, the first partition on the first disk is labeled, <literal>(hd0,msdos1)</literal>, the second <literal>(hd0,msdos2)</literal>, etc."
msgstr "區分表在 GRUB 內也有特定的名稱。通常使用 MS-DOS 格式的 “經典” 區分，第一個磁碟的第一個分區標記為 <literal>(hd0,msdos1)</literal>、第二個分區標記為 <literal>(hd0,msdos2)</literal>，餘此類推。"

msgid "GRUB 2 configuration is stored in <filename>/boot/grub/grub.cfg</filename>, but this file (in Debian) is generated from others. Be careful not to modify it by hand, since such local modifications will be lost the next time <command>update-grub</command> is run (which may occur upon update of various packages). The most common modifications of the <filename>/boot/grub/grub.cfg</filename> file (to add command line parameters to the kernel or change the duration that the menu is displayed, for example) are made through the variables in <filename>/etc/default/grub</filename>. To add entries to the menu, you can either create a <filename>/boot/grub/custom.cfg</filename> file or modify the <filename>/etc/grub.d/50_custom</filename> file. For more complex configurations, you can modify other files in <filename>/etc/grub.d</filename>, or add to them; these scripts should return configuration snippets, possibly by making use of external programs. These scripts are the ones that will update the list of kernels to boot: <filename>10_linux</filename> takes into consideration the installed Linux kernels; <filename>20_linux_xen</filename> takes into account Xen virtual systems, and <filename>30_os-prober</filename> lists other operating systems (Windows, OS X, Hurd)."
msgstr "GRUB 2 的組態存在 <filename>/boot/grub/grub.cfg</filename> 內，但該檔案 (在 Debian 環境下) 以其他方式產生。不可以人工方式修改它，否則在下次執行 <command>update-grub</command> 時 (更新多個套件時需執行它)，將失去該等修改的內容。修改 <filename>/boot/grub/grub.cfg</filename> 檔案 (新增給核心使用的參數或改變顯示選單的時間，舉例而已) 通常經由 <filename>/etc/default/grub</filename> 的變數。新增款目至選單時，可以新建 <filename>/boot/grub/custom.cfg</filename> 檔案或修改 <filename>/etc/grub.d/50_custom</filename> 檔案。更複雜的組態，可以修改 <filename>/etc/grub.d</filename> 內的其他檔案，或新增之；這些腳本應送回組態的片斷，很可能是外部程式做的修改。這些腳本將更新啟動的核心：<filename>10_linux</filename> 考量安裝 Linux 核心；<filename>20_linux_xen</filename> 考量 Xen 虛擬系統，而 <filename>30_os-prober</filename> 則列出其他的作業系統 (Windows、OS X、Hurd)。"

msgid "For Macintosh Computers (PowerPC): Configuring Yaboot"
msgstr "Macintosh 電腦 (PowerPC)：組態 Yaboot"

msgid "<primary><command>yaboot</command></primary>"
msgstr "<primary><command>yaboot</command></primary>"

msgid "Yaboot is the bootloader used by old Macintosh computers using PowerPC processors. They do not boot like PCs, but rely on a “bootstrap” partition, from which the BIOS (or OpenFirmware) executes the loader, and on which the <command>ybin</command> program installs <command>yaboot</command> and its configuration file. You will only need to run this command again if the <filename>/etc/yaboot.conf</filename> is modified (it is duplicated on the bootstrap partition, and <command>yaboot</command> knows how to find the position of the kernels on the disks)."
msgstr "Yaboot 是使用 PowerPC 晶片的舊型 Macintosh 電腦用到的啟動程式。它的啟動方式不同於 PC，採用 “引導” 分區法，從 BIOS (或 OpenFirmware) 執行啟動程式，然後由 <command>ybin</command> 程式安裝 <command>yaboot</command> 及其組態檔。修改 <filename>/etc/yaboot.conf</filename> 檔案後 (在啟動程式分區複製，且 <command>yaboot</command> 知道如何到磁碟找尋核心的位置)，需再次執行此命令。"

msgid "Before executing <command>ybin</command>, you must first have a valid <filename>/etc/yaboot.conf</filename>. The following is an example of a minimal configuration. <indexterm><primary><command>ybin</command></primary></indexterm>"
msgstr "執行 <command>ybin</command> 之前，應有合法的 <filename>/etc/yaboot.conf</filename> 程式。以下的最小組態的範例。<indexterm><primary><command>ybin</command></primary></indexterm>"

msgid "Yaboot configuration file"
msgstr "Yaboot 組態檔案"

msgid ""
"\n"
"# bootstrap partition\n"
"boot=/dev/sda2\n"
"# the disk\n"
"device=hd:\n"
"# the Linux partition\n"
"partition=3\n"
"root=/dev/sda3\n"
"# boot after 3 seconds of inactivity\n"
"# (timeout is in tenths of seconds)\n"
"timeout=30\n"
"\n"
"install=/usr/lib/yaboot/yaboot\n"
"magicboot=/usr/lib/yaboot/ofboot\n"
"enablecdboot\n"
"\n"
"# last kernel installed\n"
"image=/vmlinux\n"
"        label=linux\n"
"        initrd=/initrd.img\n"
"        read-only\n"
"\n"
"# old kernel\n"
"image=/vmlinux.old\n"
"        label=old\n"
"        initrd=/initrd.img.old\n"
"        read-only\n"
"\n"
"# only for Linux/Mac OSX dual-boot\n"
"macosx=/dev/sda5\n"
"\n"
"# bsd=/dev/sdaX and macos=/dev/sdaX\n"
"# are also possible"
msgstr ""
"\n"
"# bootstrap partition\n"
"boot=/dev/sda2\n"
"# the disk\n"
"device=hd:\n"
"# the Linux partition\n"
"partition=3\n"
"root=/dev/sda3\n"
"# boot after 3 seconds of inactivity\n"
"# (timeout is in tenths of seconds)\n"
"timeout=30\n"
"\n"
"install=/usr/lib/yaboot/yaboot\n"
"magicboot=/usr/lib/yaboot/ofboot\n"
"enablecdboot\n"
"\n"
"# last kernel installed\n"
"image=/vmlinux\n"
"        label=linux\n"
"        initrd=/initrd.img\n"
"        read-only\n"
"\n"
"# old kernel\n"
"image=/vmlinux.old\n"
"        label=old\n"
"        initrd=/initrd.img.old\n"
"        read-only\n"
"\n"
"# only for Linux/Mac OSX dual-boot\n"
"macosx=/dev/sda5\n"
"\n"
"# bsd=/dev/sdaX and macos=/dev/sdaX\n"
"# are also possible"

msgid "Other Configurations: Time Synchronization, Logs, Sharing Access…"
msgstr "其他組態：時間同步、記錄、共享近用…"

msgid "The many elements listed in this section are good to know for anyone who wants to master all aspects of configuration of the GNU/Linux system. They are, however, treated briefly and frequently refer to the documentation."
msgstr "本節列出的細目對希望精通 GNU/Linux 系統組態極有幫助。這裡祗列出簡要的內容，詳情仍需參閱文件。"

msgid "Timezone"
msgstr "時區"

msgid "<primary>timezone</primary>"
msgstr "<primary>時區</primary>"

msgid "<emphasis>BACK TO BASICS</emphasis> Symbolic links"
msgstr "<emphasis>基本</emphasis> 符號連結"

msgid "<primary>link</primary><secondary>symbolic</secondary>"
msgstr "<primary>連結</primary><secondary>符號</secondary>"

msgid "<primary>symbolic link</primary>"
msgstr "<primary>符號連結</primary>"

msgid "<primary><command>ln</command></primary>"
msgstr "<primary><command>ln</command></primary>"

msgid "A symbolic link is a pointer to another file. When you access it, the file to which it points is opened. Removal of the link will not cause deletion of the file to which it points. Likewise, it does not have its own set of permissions, but rather retains the permissions of its target. Finally, it can point to any type of file: directories, special files (sockets, named pipes, device files, etc.), even other symbolic links."
msgstr "符號連結是一種指向另個檔案的指標。近用時，被指向的檔案就被打開。移除連結不會刪除指向的檔案。同樣的，沒有自的授權，而是使用目標本身的授權。最後，可以用於任何類型的檔案：資料夾、特殊檔案 (網路插座、具名管道、設備檔案等)、甚至另個符號連結。"

msgid "The <command>ln -s <replaceable>target</replaceable> <replaceable>link-name</replaceable></command> command creates a symbolic link, named <replaceable>link-name</replaceable>, pointing to <replaceable>target</replaceable>."
msgstr "<command>ln -s <replaceable>target</replaceable> <replaceable>link-name</replaceable></command> 命令新增一個符號連結，命名為 <replaceable>link-name</replaceable>，指向 <replaceable>target</replaceable>。"

msgid "If the target does not exist, then the link is “broken” and accessing it will result in an error indicating that the target file does not exist. If the link points to another link, you will have a “chain” of links that turns into a “cycle” if one of the targets points to one of its predecessors. In this case, accessing one of the links in the cycle will result in a specific error (“too many levels of symbolic links”); this means the kernel gave up after several rounds of the cycle."
msgstr "若目標不存在，則連結算是 “破損” 且其近用送回錯誤訊息指示目標檔案不存在。若連結指向另個連結，該連結又指向其前任連結，則該等連結的 “鏈” 形成 “循環”。在這種情況下，近用循環內的任一連結也會得到特定的錯誤 (“過多層的符號連結”)；經過若干循環後核心放棄它。"

msgid "The timezone, configured during initial installation, is a configuration item for the <emphasis role=\"pkg\">tzdata</emphasis> package. To modify it, use the <command>dpkg-reconfigure tzdata</command> command, which allows you to choose the timezone to be used in an interactive manner. Its configuration is stored in the <filename>/etc/timezone</filename> file. Additionally, the corresponding file in the <filename>/usr/share/zoneinfo</filename> directory is copied into <filename>/etc/localtime</filename>; this file contains the rules governing the dates where daylight saving time is active, for countries that use it."
msgstr "初始安裝時經由 <emphasis role=\"pkg\">tzdata</emphasis> 套件組態時區。<command>dpkg-reconfigure tzdata</command> 命令以互動方式修改時區。其組態內容儲存在 <filename>/etc/timezone</filename> 檔案。在 <filename>/usr/share/zoneinfo</filename> 資料夾內對映的檔案複製在 <filename>/etc/localtime</filename> 檔案內；此檔案包括使用日光節約時間的國家。"

msgid "<primary><filename>timezone</filename></primary>"
msgstr "<primary><filename>timezone</filename></primary>"

msgid "<primary><filename>/etc/timezone</filename></primary>"
msgstr "<primary><filename>/etc/timezone</filename></primary>"

msgid "<primary><filename>zoneinfo</filename></primary>"
msgstr "<primary><filename>zoneinfo</filename></primary>"

msgid "<primary><filename>/usr/share/zoneinfo/</filename></primary>"
msgstr "<primary><filename>/usr/share/zoneinfo/</filename></primary>"

msgid "<primary>DST</primary>"
msgstr "<primary>DST</primary>"

msgid "<primary>daylight saving time</primary>"
msgstr "<primary>日光節約時間</primary>"

msgid "When you need to temporarily change the timezone, use the <varname>TZ</varname> environment variable, which takes priority over the configured system default:"
msgstr "暫時變更時區，可使用 <varname>TZ</varname> 環境變數，它的優先次序在預設的組態檔之前："

msgid "<primary><varname>TZ</varname></primary>"
msgstr "<primary><varname>TZ</varname></primary>"

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>date</userinput>\n"
"<computeroutput>Thu Feb 19 11:25:18 CET 2015</computeroutput>\n"
"<computeroutput>$ </computeroutput><userinput>TZ=\"Pacific/Honolulu\" date</userinput>\n"
"<computeroutput>Thu Feb 19 00:25:21 HST 2015</computeroutput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>date</userinput>\n"
"<computeroutput>Thu Feb 19 11:25:18 CET 2015</computeroutput>\n"
"<computeroutput>$ </computeroutput><userinput>TZ=\"Pacific/Honolulu\" date</userinput>\n"
"<computeroutput>Thu Feb 19 00:25:21 HST 2015</computeroutput>"

msgid "<emphasis>NOTE</emphasis> System clock, hardware clock"
msgstr "<emphasis>說明</emphasis> 系統時鐘，硬體時鐘"

msgid "There are two time sources in a computer. A computer's motherboard has a hardware clock, called the “CMOS clock”. This clock is not very precise, and provides rather slow access times. The operating system kernel has its own, the software clock, which it keeps up to date with its own means (possibly with the help of time servers, see <xref linkend=\"sect.time-synchronization\" />). This system clock is generally more accurate, especially since it doesn't need access to hardware variables. However, since it only exists in live memory, it is zeroed out every time the machine is booted, contrary to the CMOS clock, which has a battery and therefore “survives” rebooting or halting of the machine. The system clock is, thus, set from the CMOS clock during boot, and the CMOS clock is updated on shutdown (to take into account possible changes or corrections if it has been improperly adjusted)."
msgstr "電腦內有兩個時間來源。主機板有個硬體時鐘，稱為 “CMOS 時鐘”。這個時鐘不準，近用的速度慢。作業系統核心有自己的系統時鐘，以自己的方式 (可能由時間伺服器協助，見 <xref linkend=\"sect.time-synchronization\" />) 保持時間的正確。此系統時鐘較為準確，尤其是不需經由硬體變數就能近用。然而，系統時鐘祗存在於記憶體，開機就歸零，不像 CMOS 時間鐘，有電池支援，不受重新開機或暫停下仍能 “存活”。因此，開機時，由 CMOS 時鐘設定系統時鐘，關機時更新 CMOS 時鐘 (若被不當調整就能修正它)。"

msgid "In practice, there is a problem, since the CMOS clock is nothing more than a counter and contains no information regarding the time zone. There is a choice to make regarding its interpretation: either the system considers it runs in universal time (UTC, formerly GMT), or in local time. This choice could be a simple shift, but things are actually more complicated: as a result of daylight saving time, this offset is not constant. The result is that the system has no way to determine whether the offset is correct, especially around periods of time change. Since it is always possible to reconstruct local time from universal time and the timezone information, we strongly recommend using the CMOS clock in universal time."
msgstr "實務上有個問題，因為 CMOS 時鐘祗是個計數器，未含時區資訊。有幾個方式選擇其解釋方式：系統以世界標準時間 (UTC，舊稱 GMT)，或當地時間看待。雖然可以簡單切換，但卻頗為複雜：它的偏移值不是常數。系統無法判斷偏移值的正確性，尤其在時區交接。總是在世界標準時間與時區資訊之間重組在地時間，建議使用 CMOS 時間為世界標準時間。"

msgid "Unfortunately, Windows systems in their default configuration ignore this recommendation; they keep the CMOS clock on local time, applying time changes when booting the computer by trying to guess during time changes if the change has already been applied or not. This works relatively well, as long as the system has only Windows running on it. But when a computer has several systems (whether it be a “dual-boot” configuration or running other systems via virtual machine), chaos ensues, with no means to determine if the time is correct. If you absolutely must retain Windows on a computer, you should either configure it to keep the CMOS clock as UTC (setting the registry key <literal>HKLM\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation\\RealTimeIsUniversal</literal> to “1” as a DWORD), or use <command>hwclock --localtime --set</command> on the Debian system to set the hardware clock and mark it as tracking the local time (and make sure to manually check your clock in spring and autumn)."
msgstr "不幸的是，視窗系統預設的組態忽視此建議；仍以 CMOS 時鐘為在地時間，啟動時猜測時區的變動。祗要執行單一的視窗系統，就沒有問題。可是，電腦經常安裝多個系統 (“雙重開機” 組態或在虛擬機器執行其他系統)，混亂就免不了，無法決定正確的時間。必須保留視窗系統的前提下，應把 CMOS 時鐘組態成 UTC (把機碼 <literal>HKLM\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation\\RealTimeIsUniversal</literal> 設定為 “1” 做為 DWORD)，或使用 Debian 系統的 <command>hwclock --localtime --set</command> 設定硬體時鐘並標記追蹤其為在地時間 (並且在春秋兩季手段檢查時鐘的正確性)。"

msgid "Time Synchronization"
msgstr "時間同步"

msgid "<primary>time synchronization</primary>"
msgstr "<primary>時間同步</primary>"

msgid "<primary>clock</primary><secondary>synchronization</secondary>"
msgstr "<primary>時間</primary><secondary>同步</secondary>"

msgid "Time synchronization, which may seem superfluous on a computer, is very important on a network. Since users do not have permissions allowing them to modify the date and time, it is important for this information to be precise to prevent confusion. Furthermore, having all of the computers on a network synchronized allows better cross-referencing of information from logs on different machines. Thus, in the event of an attack, it is easier to reconstruct the chronological sequence of actions on the various machines involved in the compromise. Data collected on several machines for statistical purposes won't make a great deal of sense if they are not synchronized."
msgstr "時間同步，在單機時代是多餘，但在網路時代卻很重要。使用者無權修改日期與時間，所以需要精準的時間以免混亂。尤有甚者，網路上的電腦時間同步後，有助於安排社群工作者透過網路全球串聯。受到攻擊時，容易依序恢復原來的運作。由多部機器收集來的統計資料，必須有同步的時間，才能發揮作用。"

msgid "<emphasis>BACK TO BASICS</emphasis> NTP"
msgstr "<emphasis>基本</emphasis> NTP"

msgid "<primary>NTP</primary>"
msgstr "<primary>NTP</primary>"

msgid "<primary>Network</primary><secondary>Time Protocol</secondary>"
msgstr "<primary>Network</primary><secondary>Time Protocol</secondary>"

msgid "NTP (Network Time Protocol) allows a machine to synchronize with others fairly accurately, taking into consideration the delays induced by the transfer of information over the network and other possible offsets."
msgstr "網路時間協定 (Network Time Protocol, NTP) 可以讓機器間相當精準的同步，甚至把網路延遲及其他偏移值列入考量。"

msgid "While there are numerous NTP servers on the Internet, the more popular ones may be overloaded. This is why we recommend using the <emphasis>pool.ntp.org</emphasis> NTP server, which is, in reality, a group of machines that have agreed to serve as public NTP servers. You could even limit use to a sub-group specific to a country, with, for example, <emphasis>us.pool.ntp.org</emphasis> for the United States, or <emphasis>ca.pool.ntp.org</emphasis> for Canada, etc."
msgstr "網際網路上很多 NTP 伺服器可用，受歡迎的其工作量可能負荷過重。所以建議使用 <emphasis>pool.ntp.org</emphasis> NTP 伺服器，它是一組公開的 NTP 伺服器。也可使用針對特定地區的次群組伺服器，如 <emphasis>us.pool.ntp.org</emphasis> 係供美國使用、<emphasis>ca.pool.ntp.org</emphasis> 供加拿大使用。"

msgid "However, if you manage a large network, it is recommended that you install your own NTP server, which will synchronize with the public servers. In this case, all the other machines on your network can use your internal NTP server instead of increasing the load on the public servers. You will also increase homogeneity with your clocks, since all the machines will be synchronized on the same source, and this source is very close in terms of network transfer times."
msgstr "然而，管理大型網路時，還是應安裝與公共伺服器同步的自己 NTP 伺服器。同個網路上自己的機器，就能使用內部的 NTP 伺服器不必增加外部公共伺服器的負擔。以自己的時鐘增加網路內機器的同質化，同步擷取與共用資源，使用共同的網路交換時間。"

msgid "For Workstations"
msgstr "給工作站"

msgid "Since work stations are regularly rebooted (even if only to save energy), synchronizing them by NTP at boot is enough. To do so, simply install the <emphasis role=\"pkg\">ntpdate</emphasis> package. You can change the NTP server used if needed by modifying the <filename>/etc/default/ntpdate</filename> file."
msgstr "工作經常需要重新開機 (雖然祗是節省能源)，開機時以 NTP 同步就夠了。安裝 <emphasis role=\"pkg\">ntpdate</emphasis> 套件就可以。需要更換 NTP 伺服器時，再修改 <filename>/etc/default/ntpdate</filename> 檔案即可。"

msgid "<primary><filename>ntpdate</filename></primary>"
msgstr "<primary><filename>ntpdate</filename></primary>"

msgid "<primary><filename>/etc/default/ntpdate</filename></primary>"
msgstr "<primary><filename>/etc/default/ntpdate</filename></primary>"

msgid "For Servers"
msgstr "供伺服器"

msgid "Servers are only rarely rebooted, and it is very important for their system time to be correct. To permanently maintain correct time, you would install a local NTP server, a service offered in the <emphasis role=\"pkg\">ntp</emphasis> package. In its default configuration, the server will synchronize with <emphasis>pool.ntp.org</emphasis> and provide time in response to requests coming from the local network. You can configure it by editing the <filename>/etc/ntp.conf</filename> file, the most significant alteration being the NTP server to which it refers. If the network has a lot of servers, it may be interesting to have one local time server which synchronizes with the public servers and is used as a time source by the other servers of the network."
msgstr "伺服器很少重開機，系統時間必須絕對精準。為了永久維持時間的正確性，必須安裝由 <emphasis role=\"pkg\">ntp</emphasis> 套件提供的 NPT 伺服器。預設的組態方式係與 <emphasis>pool.ntp.org</emphasis> 同步，且回應在地網路的請求。可以編輯 <filename>/etc/ntp.conf</filename> 檔案改變原來的組態，NTP 伺服器依照該檔案的內容而變更。若有多個伺服器，最好有一個在地時間伺服器與公共的伺服器同步，並做為在地網路其他伺服器的同步的依據。"

msgid "<primary><emphasis role=\"pkg\">ntp</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">ntp</emphasis></primary>"

msgid "<primary>server</primary><secondary>NTP</secondary>"
msgstr "<primary>伺服器</primary><secondary>NTP</secondary>"

msgid "<primary>NTP</primary><secondary>server</secondary>"
msgstr "<primary>NTP</primary><secondary>伺服器</secondary>"

msgid "<emphasis>GOING FURTHER</emphasis> GPS modules and other time sources"
msgstr "<emphasis>進一步</emphasis> GPS 模組與其他時間來源"

msgid "<primary>GPS</primary>"
msgstr "<primary>GPS</primary>"

msgid "<primary>DCF-77</primary>"
msgstr "<primary>DCF-77</primary>"

msgid "If time synchronization is particularly crucial to your network, it is possible to equip a server with a GPS module (which will use the time from GPS satellites) or a DCF-77 module (which will sync time with the atomic clock near Frankfurt, Germany). In this case, the configuration of the NTP server is a little more complicated, and prior consultation of the documentation is an absolute necessity."
msgstr "如果網路對時間同步極為敏感，最好在伺服器安裝 GPS 模組 (which will use the time from GPS satellites) 或 DCF-77 模組 (which will sync time with the atomic clock near Frankfurt, Germany)。在這種情況下，NTP 伺服器的組態就有點複雜，必須參照文件辦理。"

msgid "Rotating Log Files"
msgstr "輪轉日誌檔"

msgid "<primary>file</primary><secondary>logs, rotation</secondary>"
msgstr "<primary>檔案</primary><secondary>日誌，輪轉</secondary>"

msgid "<primary>logs</primary><secondary>files, rotation</secondary>"
msgstr "<primary>日誌</primary><secondary>檔案，輪轉</secondary>"

msgid "<primary>rotation of log files</primary>"
msgstr "<primary>輪轉日誌檔案</primary>"

msgid "<primary><command>logrotate</command></primary>"
msgstr "<primary><command>logrotate</command></primary>"

msgid "Log files can grow, fast, and it is necessary to archive them. The most common scheme is a rotating archive: the log file is regularly archived, and only the latest <replaceable>X</replaceable> archives are retained. <command>logrotate</command>, the program responsible for these rotations, follows directives given in the <filename>/etc/logrotate.conf</filename> file and all of the files in the <filename>/etc/logrotate.d/</filename> directory. The administrator may modify these files, if they wish to adapt the log rotation policy defined by Debian. The <citerefentry><refentrytitle>logrotate</refentrytitle> <manvolnum>1</manvolnum></citerefentry> man page describes all of the options available in these configuration files. You may want to increase the number of files retained in log rotation, or move the log files to a specific directory dedicated to archiving them rather than delete them. You could also send them by e-mail to archive them elsewhere."
msgstr "日誌檔成長的速度很快，需要典藏它。最常的做法是循環典藏：祗保留最新的 <replaceable>X</replaceable> 部份。<command>logrotate</command> 是負責循環的程式，根據 <filename>/etc/logrotate.conf</filename> 檔案內的組態，把日誌檔儲存在 <filename>/etc/logrotate.d/</filename> 資料夾內。管理者可以修改該等檔案，修改 Debian 預設的循環政策。<citerefentry><refentrytitle>logrotate</refentrytitle> <manvolnum>1</manvolnum></citerefentry> 手冊頁面描述該組態可用的選項。可以在循環的過程中，增加典藏的檔案數，或把檔案移至指定的資料夾而不是刪除它們。也可以電子郵件方式寄到別的地方。"

msgid "The <command>logrotate</command> program is executed daily by the <command>cron</command> scheduling program (described in <xref linkend=\"sect.task-scheduling-cron-atd\" />)."
msgstr "<command>logrotate</command> 程式每日執行 <command>cron</command> 排程的要求 (詳情見 <xref linkend=\"sect.task-scheduling-cron-atd\" />)。"

msgid "Sharing Administrator Rights"
msgstr "共享管理員權限"

msgid "<primary>account</primary><secondary>administrator account</secondary>"
msgstr "<primary>帳號</primary><secondary>管理員帳號</secondary>"

msgid "<primary>root</primary>"
msgstr "<primary>根</primary>"

msgid "<primary><command>sudo</command></primary>"
msgstr "<primary><command>sudo</command></primary>"

msgid "Frequently, several administrators work on the same network. Sharing the root passwords is not very elegant, and opens the door for abuse due to the anonymity such sharing creates. The solution to this problem is the <command>sudo</command> program, which allows certain users to execute certain commands with special rights. In the most common use case, <command>sudo</command> allows a trusted user to execute any command as root. To do so, the user simply executes <command>sudo <replaceable>command</replaceable></command> and authenticates using their personal password."
msgstr "數個管理者共同在同個伺服器工作。共用同個根使用者密碼不是好主意，匿名引發的誤用很麻煩。解決方案是使用 <command>sudo</command> 程式，允許使用者對特定命令擁有專門的權力。在多數情況下，<command>sudo</command> 允許受信任的使用者以根的權限執行命令。使用者祗需執行 <command>sudo <replaceable>command</replaceable></command> 並以個人的密碼通過認證。"

msgid "When installed, the <emphasis role=\"pkg\">sudo</emphasis> package gives full root rights to members of the <literal>sudo</literal> Unix group. To delegate other rights, the administrator must use the <command>visudo</command> command, which allows them to modify the <filename>/etc/sudoers</filename> configuration file (here again, this will invoke the <command>vi</command> editor, or any other editor indicated in the <varname>EDITOR</varname> environment variable). Adding a line with <literal><replaceable>username</replaceable> ALL=(ALL) ALL</literal> allows the user in question to execute any command as root."
msgstr "安裝的時候，<emphasis role=\"pkg\">sudo</emphasis> 套件把完整的 root 權限授權給 <literal>sudo</literal> Unix 群組。管理者必須使用 <command>visudo</command> 命令授予其他權利，該命令允許使用者修改 <filename>/etc/sudoers</filename> 組態檔 (當然，必須啟用 <command>vi</command> 編輯器，或在 <varname>EDITOR</varname> 環境變數指定的編輯器)。新增一列 <literal><replaceable>username</replaceable> ALL=(ALL) ALL</literal> 就能允許該使用者以 root 的授權執行命令。"

msgid "<primary><command>visudo</command></primary>"
msgstr "<primary><command>visudo</command></primary>"

msgid "<primary><filename>sudoers</filename></primary>"
msgstr "<primary><filename>sudoers</filename></primary>"

msgid "<primary><filename>/etc/sudoers</filename></primary>"
msgstr "<primary><filename>/etc/sudoers</filename></primary>"

msgid "More sophisticated configurations allow authorization of only specific commands to specific users. All the details of the various possibilities are given in the <citerefentry><refentrytitle>sudoers</refentrytitle> <manvolnum>5</manvolnum></citerefentry> man page."
msgstr "還有較複雜的組態，祗允許特定使用者執行部份命令。詳情在 <citerefentry><refentrytitle>sudoers</refentrytitle> <manvolnum>5</manvolnum></citerefentry> 手冊頁面。"

msgid "List of Mount Points"
msgstr "掛載點清單"

msgid "<primary>point, mount</primary>"
msgstr "<primary>點，掛載</primary>"

msgid "<primary>mount point</primary>"
msgstr "<primary>掛載點</primary>"

msgid "<emphasis>BACK TO BASICS</emphasis> Mounting and unmounting"
msgstr "<emphasis>基本</emphasis> 掛載與卸載"

msgid "In a Unix-like system such as Debian, files are organized in a single tree-like hierarchy of directories. The <filename>/</filename> directory is called the “root directory”; all additional directories are sub-directories within this root. “Mounting” is the action of including the content of a peripheral device (often a hard drive) into the system's general file tree. As a consequence, if you use a separate hard drive to store users' personal data, this disk will have to be “mounted” in the <filename>/home/</filename> directory. The root filesystem is always mounted at boot by the kernel; other devices are often mounted later during the startup sequence or manually with the <command>mount</command> command."
msgstr "在 Debian 這類的 Unix-like 系統裡，檔案以樹狀的資料夾階層組織。<filename>/</filename> 資料夾稱為 “根資料夾”；其他的資料夾都是此根資料夾的次資料夾。“掛載” 是把週邊設備 (通常是磁碟) 納入系統檔案樹的作業。如果以其他磁碟儲存使用者個人的資料，將 “掛載” 於 <filename>/home/</filename> 資料夾。根檔案系統由核心永遠掛載於根；其他設備則稍後再透過啟動順序或以 <command>mount</command> 命令掛載進來。"

msgid "<primary><command>mount</command></primary>"
msgstr "<primary><command>mount</command></primary>"

msgid "Some removable devices are automatically mounted when connected, especially when using the GNOME, KDE or other graphical desktop environments. Others have to be mounted manually by the user. Likewise, they must be unmounted (removed from the file tree). Normal users do not usually have permission to execute the <command>mount</command> and <command>umount</command> commands. The administrator can, however, authorize these operations (independently for each mount point) by including the <literal>user</literal> option in the <filename>/etc/fstab</filename> file."
msgstr "有些移動式裝置在連結時系統自動掛載，尤其在 GNOME、KDE 或其他圖形桌面環境。有些情況就需要使用者手動掛載。同樣的，也需要卸載 (從檔案樹移除)。標準的使用者權限不允許執行掛載 <command>mount</command> 與卸載 <command>umount</command> 命令。祗有管理者才能夠設定 <literal>user</literal> 選項於 <filename>/etc/fstab</filename> 檔案內，授權使用者執行該等命令 (獨立於每個掛載點)。"

msgid "The <command>mount</command> command can be used without arguments (it then lists all mounted filesystems). The following parameters are required to mount or unmount a device. For the complete list, please refer to the corresponding man pages, <citerefentry><refentrytitle>mount</refentrytitle> <manvolnum>8</manvolnum></citerefentry> and <citerefentry><refentrytitle>umount</refentrytitle> <manvolnum>8</manvolnum></citerefentry>. For simple cases, the syntax is simple too: for example, to mount the <filename>/dev/sdc1</filename> partition, which has an ext3 filesystem, into the <filename>/mnt/tmp/</filename> directory, you would simply run <command>mount -t ext3 /dev/sdc1 /mnt/tmp/</command>."
msgstr "<command>mount</command> 命令可以直接使用不需參數 (列出所有已掛載的檔案系統)。以下參數為掛載或卸載設備所必需。完整的參數，請參見對應的手冊頁面，<citerefentry><refentrytitle>mount</refentrytitle> <manvolnum>8</manvolnum></citerefentry> 與 <citerefentry><refentrytitle>umount</refentrytitle> <manvolnum>8</manvolnum></citerefentry>。單純個案的語法也簡單：例如，掛載使用 ex3 檔案系統的 <filename>/dev/sdc1</filename> 分區入 <filename>/mnt/tmp/</filename> 資料夾時，需執行 <command>mount -t ext3 /dev/sdc1 /mnt/tmp/</command> 命令。"

msgid "The <filename>/etc/fstab</filename> file gives a list of all possible mounts that happen either automatically on boot or manually for removable storage devices. Each mount point is described by a line with several space-separated fields: <indexterm><primary><filename>fstab</filename></primary></indexterm> <indexterm><primary><filename>/etc/fstab</filename></primary></indexterm>"
msgstr "<filename>/etc/fstab</filename> 檔案列出所有開機自動掛載或手動掛載的移動儲存裝置。每個掛載點由一列文字描述，包括若干空格區隔的欄位：<indexterm><primary><filename>fstab</filename></primary></indexterm> <indexterm><primary><filename>/etc/fstab</filename></primary></indexterm>"

msgid "device to mount: this can be a local partition (hard drive, CD-ROM) or a remote filesystem (such as NFS)."
msgstr "待掛載的設備：可以是在地分區 (硬碟、CD-ROM) 或遠端的檔案系統 (如 NFS)。"

msgid "This field is frequently replaced with the unique ID of the filesystem (which you can determine with <command>blkid <userinput>device</userinput></command>) prefixed with <literal>UUID=</literal>. This guards against a change in the name of the device in the event of addition or removal of disks, or if disks are detected in a different order."
msgstr "此欄位通常以檔案系統的 ID 取代 (可以用 <command>blkid <userinput>device</userinput></command>) 前置及 <literal>UUID=</literal>。此種方式可以應付新增或移除磁碟設備名稱的情況，或者以其他順序偵測到的磁碟。"

msgid "mount point: this is the location on the local filesystem where the device, remote system, or partition will be mounted."
msgstr "掛載點：這是把設備、遠端系統，或分區掛載於在地檔案系統的位置。"

msgid "type: this field defines the filesystem used on the mounted device. <literal>ext4</literal>, <literal>ext3</literal>, <literal>vfat</literal>, <literal>ntfs</literal>, <literal>btrfs</literal>, <literal>xfs</literal> are a few examples."
msgstr "類型：這個欄位定義掛載設備使用的檔案系統。<literal>ext4</literal>、<literal>ext3</literal>、<literal>vfat</literal>、<literal>ntfs</literal>、<literal>btrfs</literal>、<literal>xfs</literal> 等。"

msgid "<emphasis>BACK TO BASICS</emphasis> NFS, a network filesystem"
msgstr "<emphasis>基本</emphasis> NFS，網路檔案系統"

msgid "NFS is a network filesystem; under Linux, it allows transparent access to remote files by including them in the local filesystem."
msgstr "NFS 是一種 Linux  環境下的網路檔案系統，把遠端的檔案以透明方式納入在地的檔案系統內。"

msgid "A complete list of known filesystems is available in the <citerefentry><refentrytitle>mount</refentrytitle> <manvolnum>8</manvolnum></citerefentry> man page. The <literal>swap</literal> special value is for swap partitions; the <literal>auto</literal> special value tells the <command>mount</command> program to automatically detect the filesystem (which is especially useful for disk readers and USB keys, since each one might have a different filesystem);"
msgstr "知名的檔案系統清單在 <citerefentry><refentrytitle>mount</refentrytitle> <manvolnum>8</manvolnum></citerefentry> 手冊頁面。特殊值 <literal>swap</literal> 係供交換分區使用；特殊值 <literal>auto</literal> 告訴<command>mount</command> 程式自動偵測檔案系統 (對讀卡機與 USB 磁碟機特別有用，因為它們可能使用不同的檔案系統)；"

msgid "options: there are many of them, depending on the filesystem, and they are documented in the <command>mount</command> man page. The most common are"
msgstr "選項：依檔案系統的不同，而有多種選項，詳情見 <command>mount</command> 手冊頁面。最常用的是"

msgid "<literal>rw</literal> or <literal>ro</literal>, meaning, respectively, that the device will be mounted with read/write or read-only permissions."
msgstr "<literal>rw</literal> 或 <literal>ro</literal>，表示該設備掛載後可以讀/寫，或祗有讀取的權限。"

msgid "<literal>noauto</literal> deactivates automatic mounting on boot."
msgstr "<literal>noauto</literal> 開機時關閉自動掛載。"

msgid "<literal>nofail</literal> allows the boot to proceed even when the device is not present. Make sure to put this option for external drives that might be unplugged when you boot, because <command>systemd</command> really ensures that all mount points that must be automatically mounted are actually mounted before letting the boot process continue to its end. Note that you can combine this with <literal>x-systemd.device-timeout=5s</literal> to tell <command>systemd</command> to not wait more than 5 seconds for the device to appear (see <citerefentry><refentrytitle>systemd.mount</refentrytitle><manvolnum>5</manvolnum></citerefentry>)."
msgstr "<literal>nofail</literal> 允許在啟動時處理設備，即使該設備不存在。確認啟動時，該外接磁碟機可能未插入，因為 <command>systemd</command> 將確認所有掛載點在啟動完成前必須自動掛載。可將此與 <literal>x-systemd.device-timeout=5s</literal> 併用，告訴 <command>systemd</command> 不必等 5 秒以上的時間，直接進入下個作業階段 (見 <citerefentry><refentrytitle>systemd.mount</refentrytitle><manvolnum>5</manvolnum></citerefentry>)。"

msgid "<literal>user</literal> authorizes all users to mount this filesystem (an operation which would otherwise be restricted to the root user)."
msgstr "<literal>user</literal> 授權所有的使用者均可掛載此檔案系統 (若無此選項，則祗有根使用者才有此權限)。"

msgid "<literal>defaults</literal> means the group of default options: <literal>rw</literal>, <literal>suid</literal>, <literal>dev</literal>, <literal>exec</literal>, <literal>auto</literal>, <literal>nouser</literal> and <literal>async</literal>, each of which can be individually disabled after <literal>defaults</literal> by adding <literal>nosuid</literal>, <literal>nodev</literal> and so on to block <literal>suid</literal>, <literal>dev</literal> and so on. Adding the <literal>user</literal> option reactivates it, since <literal>defaults</literal> includes <literal>nouser</literal>."
msgstr "<literal>defaults</literal> 表示預設的選項群組為：<literal>rw</literal>、<literal>suid</literal>、<literal>dev</literal>、<literal>exec</literal>、<literal>auto</literal>、<literal>nouser</literal> 與 <literal>async</literal>，使用了 <literal>defaults</literal> 之後，還可以用 <literal>nosuid</literal> 命令、<literal>nodev</literal> 及其他類似的命令，中止 <literal>suid</literal>、<literal>dev</literal> 等作用。加入 <literal>user</literal> 選項可再啟用它，因為 <literal>defaults</literal> 包括 <literal>nouser</literal>。"

msgid "backup: this field is almost always set to <literal>0</literal>. When it is <literal>1</literal>, it tells the <command>dump</command> tool that the partition contains data that is to be backed up."
msgstr "備份：此欄位幾乎都設為 <literal>0</literal>。當它是 <literal>1</literal> 時，告訴 <command>dump</command> 工具將備份有資料的分區。"

msgid "check order: this last field indicates whether the integrity of the filesystem should be checked on boot, and in which order this check should be executed. If it is <literal>0</literal>, no check is conducted. The root filesystem should have the value <literal>1</literal>, while other permanent filesystems get the value <literal>2</literal>."
msgstr "檢查順序：最後一個欄位告知系統在啟動時，或其他時機，檢查檔案系統的完整性。若設為 <literal>0</literal>，則不檢查。根檔案系統的值為 <literal>1</literal>，其他固定檔案系統的值為 <literal>2</literal>。"

msgid "Example <filename>/etc/fstab</filename> file"
msgstr "範例 <filename>/etc/fstab</filename> 檔案"

msgid ""
"\n"
"# /etc/fstab: static file system information.\n"
"#\n"
"# &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;\n"
"proc            /proc           proc    defaults        0       0\n"
"# / was on /dev/sda1 during installation\n"
"UUID=c964222e-6af1-4985-be04-19d7c764d0a7 / ext3 errors=remount-ro 0 1\n"
"# swap was on /dev/sda5 during installation\n"
"UUID=ee880013-0f63-4251-b5c6-b771f53bd90e none swap sw  0       0\n"
"/dev/scd0       /media/cdrom0   udf,iso9660 user,noauto 0       0\n"
"/dev/fd0        /media/floppy   auto    rw,user,noauto  0       0\n"
"arrakis:/shared /shared         nfs     defaults        0       0"
msgstr ""
"\n"
"# /etc/fstab: static file system information.\n"
"#\n"
"# &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;\n"
"proc            /proc           proc    defaults        0       0\n"
"# / was on /dev/sda1 during installation\n"
"UUID=c964222e-6af1-4985-be04-19d7c764d0a7 / ext3 errors=remount-ro 0 1\n"
"# swap was on /dev/sda5 during installation\n"
"UUID=ee880013-0f63-4251-b5c6-b771f53bd90e none swap sw  0       0\n"
"/dev/scd0       /media/cdrom0   udf,iso9660 user,noauto 0       0\n"
"/dev/fd0        /media/floppy   auto    rw,user,noauto  0       0\n"
"arrakis:/shared /shared         nfs     defaults        0       0"

msgid "The last entry in this example corresponds to a network filesystem (NFS): the <filename>/shared/</filename> directory on the <emphasis>arrakis</emphasis> server is mounted at <filename>/shared/</filename> on the local machine. The format of the <filename>/etc/fstab</filename> file is documented on the <citerefentry><refentrytitle>fstab</refentrytitle><manvolnum>5</manvolnum></citerefentry> man page."
msgstr "此例的最後一個款目對應於網路檔案系統 (NFS)：<filename>/shared/</filename> 資料夾位於 <emphasis>arrakis</emphasis> 伺服器掛載於本地機器的 <filename>/shared/</filename>。<filename>/etc/fstab</filename> 檔案格式位於 <citerefentry><refentrytitle>fstab</refentrytitle><manvolnum>5</manvolnum></citerefentry> 手冊頁面。"

msgid "<emphasis>GOING FURTHER</emphasis> Auto-mounting"
msgstr "<emphasis>下一步</emphasis> 自動掛載"

msgid "The <emphasis>am-utils</emphasis> package provides the <command>amd</command> auto-mounting utility, able to mount removable media on demand when a user attempts to access their usual mount point. It will unmount these devices when no process is accessing them any longer."
msgstr "<emphasis>am-utils</emphasis> 套件提供 <command>amd</command> 自動載入公用程式，使月手者近用其慣用的掛載點時，可在需要時掛載移動式媒體。無法在不用時自動卸載該等設備。"

msgid "<primary><emphasis>am-utils</emphasis></primary>"
msgstr "<primary><emphasis>am-utils</emphasis></primary>"

msgid "<primary><command>amd</command></primary>"
msgstr "<primary><command>amd</command></primary>"

msgid "<primary><command>automount</command></primary>"
msgstr "<primary><command>automount</command></primary>"

msgid "<primary><emphasis>autofs</emphasis></primary>"
msgstr "<primary><emphasis>autofs</emphasis></primary>"

msgid "<primary>automounter</primary>"
msgstr "<primary>automounter</primary>"

msgid "Other auto-mounting utilities exist, such as <command>automount</command> in the <emphasis>autofs</emphasis> package."
msgstr "還有其他自動掛載公用程式，諸如 <command>automount</command> 位在 <emphasis>autofs</emphasis> 套件中。"

msgid "Note also that GNOME, KDE, and other graphical desktop environments work together with <emphasis>udisks</emphasis>, and can automatically mount removable media when they are connected."
msgstr "與 GNOME、KDE 及其他圖形桌面環境一起工作的 <emphasis>udisks</emphasis>，在連結移動媒體時，也可自動掛載。"

msgid "<command>locate</command> and <command>updatedb</command>"
msgstr "<command>locate</command> 與 <command>updatedb</command>"

msgid "<primary><command>locate</command></primary>"
msgstr "<primary><command>locate</command></primary>"

msgid "<primary><command>updatedb</command></primary>"
msgstr "<primary><command>updatedb</command></primary>"

msgid "<primary><command>mlocate</command></primary>"
msgstr "<primary><command>mlocate</command></primary>"

msgid "The <command>locate</command> command can find the location of a file when you only know part of the name. It sends a result almost instantaneously, since it consults a database that stores the location of all the files on the system; this database is updated daily by the <command>updatedb</command> command. There are multiple implementations of the <command>locate</command> command and Debian picked <emphasis role=\"pkg\">mlocate</emphasis> for its standard system."
msgstr "可以用 <command>locate</command> 命令找尋已知名稱的檔案。幾乎即時送回結果，因為它搜尋的資料庫儲存系統內所有檔案的位置；此資料庫由 <command>updatedb</command> 命令每日更新。<command>locate</command> 命令還有其他用途，Debian 選擇 <emphasis role=\"pkg\">mlocate</emphasis> 做為其標準系統。"

msgid "<command>mlocate</command> is smart enough to only return files which are accessible to the user running the command even though it uses a database that knows about all files on the system (since its <command>updatedb</command> implementation runs with root rights). For extra safety, the administrator can use <varname>PRUNEDPATHS</varname> in <filename>/etc/updatedb.conf</filename> to exclude some directories from being indexed."
msgstr "<command>mlocate</command> 很聰明，祗送回該命令使用者能夠近用的檔案，不會顯示系統內其他符合條件的檔案 (因為它以根權限執行 <command>updatedb</command> 命令)。為了提供額外的安全保護，管理者可以使用 <varname>PRUNEDPATHS</varname> 位於 <filename>/etc/updatedb.conf</filename>，排除已經索引的其他資料夾。"

msgid "Compiling a Kernel"
msgstr "編譯核心"

msgid "<primary>compilation</primary><secondary>of a kernel</secondary>"
msgstr "<primary>編譯</primary><secondary>核心</secondary>"

msgid "<primary>kernel</primary><secondary>compilation</secondary>"
msgstr "<primary>核心</primary><secondary>編譯</secondary>"

msgid "The kernels provided by Debian include the largest possible number of features, as well as the maximum of drivers, in order to cover the broadest spectrum of existing hardware configurations. This is why some users prefer to recompile the kernel in order to only include what they specifically need. There are two reasons for this choice. First, it may be to optimize memory consumption, since the kernel code, even if it is never used, occupies memory for nothing (and never “goes down” on the swap space, since it is actual RAM that it uses), which can decrease overall system performance. A locally compiled kernel can also limit the risk of security problems since only a fraction of the kernel code is compiled and run."
msgstr "Debian 的核心儘量納入所有的功能，以及最多的驅動程式，以便涵蓋現在的硬體組態。所以，有些使用者寧願自行編譯祗包括所需的核心。這麼做有兩個理由。第一，記憶體用量較小，核心程式碼，即使未用到，也佔有記憶體的空間 (而且永遠不 “離開” 置換記憶體，因為它用到實際的 RAM)，降低系統的整體效能。在地自行編譯的核心也限制了安全問題的範圍，因為祗編譯與執行部份核心碼。"

msgid "<emphasis>NOTE</emphasis> Security updates"
msgstr "<emphasis>說明</emphasis> 安全更新"

msgid "If you choose to compile your own kernel, you must accept the consequences: Debian cannot ensure security updates for your custom kernel. By keeping the kernel provided by Debian, you benefit from updates prepared by the Debian Project's security team."
msgstr "決定編譯自己的核心後，必須接受一個事實：Debian 不能確認客製化核心的安全更新。使用 Debian 的核心，可以使用 Debian 計畫提供的更新。"

msgid "Recompilation of the kernel is also necessary if you want to use certain features that are only available as patches (and not included in the standard kernel version)."
msgstr "使用祗在補丁內的功能 (不在標準的核心內) 時，就必須重新編譯核心。"

msgid "<emphasis>GOING FURTHER</emphasis> The Debian Kernel Handbook"
msgstr "<emphasis>進一步</emphasis> The Debian Kernel Handbook"

msgid "<primary><emphasis role=\"pkg\">debian-kernel-handbook</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">debian-kernel-handbook</emphasis></primary>"

msgid "The Debian kernel teams maintains the “Debian Kernel Handbook” (also available in the <emphasis role=\"pkg\">debian-kernel-handbook</emphasis> package) with comprehensive documentation about most kernel related tasks and about how official Debian kernel packages are handled. This is the first place you should look into if you need more information than what is provided in this section. <ulink type=\"block\" url=\"http://kernel-handbook.alioth.debian.org\" />"
msgstr "Debian 核心團隊維護的 “Debian Kernel Handbook” (全文見 <emphasis role=\"pkg\">debian-kernel-handbook</emphasis> 套件) 詳述核心相關的工作與 Debian 核心套件的處理方式。欲知可節所述事宜的詳情，請參見此網址。<ulink type=\"block\" url=\"http://kernel-handbook.alioth.debian.org\" />"

msgid "Introduction and Prerequisites"
msgstr "簡介和先決條件"

msgid "Unsurprisingly Debian manages the kernel in the form of a package, which is not how kernels have traditionally been compiled and installed. Since the kernel remains under the control of the packaging system, it can then be removed cleanly, or deployed on several machines. Furthermore, the scripts associated with these packages automate the interaction with the bootloader and the initrd generator."
msgstr "Debian 以套件方式管理核心，與傳統的編譯安裝不同調。核心還是在套件系統的控制下，可以被完整移除，或布建在多個機器上。與該等套件有關的腳本自動與啟動程式和 initrd 產生器互動。"

msgid "The upstream Linux sources contain everything needed to build a Debian package of the kernel. But you still need to install <emphasis role=\"pkg\">build-essential</emphasis> to ensure that you have the tools required to build a Debian package. Furthermore, the configuration step for the kernel requires the <emphasis role=\"pkg\">libncurses5-dev</emphasis> package. Finally, the <emphasis role=\"pkg\">fakeroot</emphasis> package will enable creation of the Debian package without using administrator's rights."
msgstr "上游的 Linux 原始碼包括建置 Debian 核心套件所需的一切。但是仍可再安裝 <emphasis role=\"pkg\">build-essential</emphasis> 以確保擁有建立 Debian 套件所需的所有工具。而且，組態核心時需要 <emphasis role=\"pkg\">libncurses5-dev</emphasis> 套件。最後，<emphasis role=\"pkg\">fakeroot</emphasis> 套件將在不使用管理者權限的前提下，啟用新增 Debian 套件。"

msgid "<emphasis>CULTURE</emphasis> The good old days of <emphasis role=\"pkg\">kernel-package</emphasis>"
msgstr "<emphasis>文化</emphasis> <emphasis role=\"pkg\">kernel-package</emphasis> 的美好歲月"

msgid "<primary><emphasis role=\"pkg\">kernel-package</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">kernel-package</emphasis></primary>"

msgid "Before the Linux build system gained the ability to build proper Debian packages, the recommended way to build such packages was to use <command>make-kpkg</command> from the <emphasis role=\"pkg\">kernel-package</emphasis> package."
msgstr "以 Linux 布建系統能夠建立適當的 Debian 套件前，使用 <command>make-kpkg</command>，來自 <emphasis role=\"pkg\">kernel-package</emphasis> 套件。"

msgid "Getting the Sources"
msgstr "取得原始碼"

msgid "<primary>Linux kernel sources</primary>"
msgstr "<primary>Linux 核心原始碼</primary>"

msgid "<primary>kernel</primary><secondary>sources</secondary>"
msgstr "<primary>核心</primary><secondary>原始碼</secondary>"

msgid "<primary>source</primary><secondary>of the Linux kernel</secondary>"
msgstr "<primary>原始碼</primary><secondary> Linux 核心</secondary>"

msgid "Like anything that can be useful on a Debian system, the Linux kernel sources are available in a package. To retrieve them, just install the <emphasis role=\"pkg\">linux-source-<replaceable>version</replaceable></emphasis> package. The <command>apt-cache search ^linux-source</command> command lists the various kernel versions packaged by Debian. The latest version is available in the <emphasis role=\"distribution\">Unstable</emphasis> distribution: you can retrieve them without much risk (especially if your APT is configured according to the instructions of <xref linkend=\"sect.apt-mix-distros\" />). Note that the source code contained in these packages does not correspond precisely with that published by Linus Torvalds and the kernel developers; like all distributions, Debian applies a number of patches, which might (or might not) find their way into the upstream version of Linux. These modifications include backports of fixes/features/drivers from newer kernel versions, new features not yet (entirely) merged in the upstream Linux tree, and sometimes even Debian specific changes."
msgstr "就像 Debian 系統內其他有用的東西，Linux 核心原始碼也位在套件內。祗要安裝 <emphasis role=\"pkg\">linux-source-<replaceable>version</replaceable></emphasis> 套件，就能取得全部的原始碼。<command>apt-cache search ^linux-source</command> 命令列出 Debian 內各種版本的核心套件。最新的版本在 <emphasis role=\"distribution\">Unstable</emphasis> 發行版內：可以毫不費力的取得 (尤其是把 APT 根據 <xref linkend=\"sect.apt-mix-distros\" /> 的指示組態後)。這些套件內的原始碼並未完全吻合 Linus Torvalds 與其他核心發展者釋出的內容；如同其他的發行版，Debian 以一系列的補丁搭配，這些補丁可能 (或不可能) 以自己的方法納入 Linux 上游的版本。包括從較新核心版本的 fixes/features/drivers 反向移殖，功能較新但尚未 (全部) 合併入上游的Linux 樹，甚至 Debian 特別的改變。"

msgid "The remainder of this section focuses on the 3.16 version of the Linux kernel, but the examples can, of course, be adapted to the particular version of the kernel that you want."
msgstr "本節其他內容以 Linux 核心 3.16 版為準，範例則不以此為限，可以調整為特定的核心版本。"

msgid "We assume the <emphasis role=\"pkg\">linux-source-3.16</emphasis> package has been installed. It contains <filename>/usr/src/linux-source-3.16.tar.xz</filename>, a compressed archive of the kernel sources. You must extract these files in a new directory (not directly under <filename>/usr/src/</filename>, since there is no need for special permissions to compile a Linux kernel): <filename>~/kernel/</filename> is appropriate."
msgstr "假設 <emphasis role=\"pkg\">linux-source-3.16</emphasis> 套件已安裝好了。包括 <filename>/usr/src/linux-source-3.16.tar.xz</filename>，核心原始碼的壓縮檔。在另個資料夾解縮 (不能直接在 <filename>/usr/src/</filename> 之下，因為不需特別的授權就可以重新編譯 Linux 核心)：<filename>~/kernel/</filename> 是個不錯的選擇。"

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>mkdir ~/kernel; cd ~/kernel</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>tar -xaf /usr/src/linux-source-3.16.tar.xz</userinput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>mkdir ~/kernel; cd ~/kernel</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>tar -xaf /usr/src/linux-source-3.16.tar.xz</userinput>"

msgid "<emphasis>CULTURE</emphasis> Location of kernel sources"
msgstr "<emphasis>文化</emphasis> 核心原始碼的位置"

msgid "Traditionally, Linux kernel sources would be placed in <filename>/usr/src/linux/</filename> thus requiring root permissions for compilation. However, working with administrator rights should be avoided when not needed. There is a <literal>src</literal> group that allows members to work in this directory, but working in <filename>/usr/src/</filename> should be avoided nevertheless. By keeping the kernel sources in a personal directory, you get security on all counts: no files in <filename>/usr/</filename> unknown to the packaging system, and no risk of misleading programs that read <filename>/usr/src/linux</filename> when trying to gather information on the used kernel."
msgstr "傳統上，Linux 核心原始碼置於 <filename>/usr/src/linux/</filename>，需要根權限才能編譯。然而，管理者的權限就夠了。<literal>src</literal> 群組的成員也可以使用該資料夾，但是應避免使用 <filename>/usr/src/</filename>。把核心原始碼置於個人資料夾時，應把安全置於第一位：在 <filename>/usr/</filename> 內的檔案都應明確其在套件系統內的作用，試圖聚集使用核心的資訊時，不能在讀取 <filename>/usr/src/linux</filename> 時誤導程式。"

msgid "Configuring the Kernel"
msgstr "組態核心"

msgid "<primary>kernel</primary><secondary>configuration</secondary>"
msgstr "<primary>核心</primary><secondary>組態</secondary>"

msgid "<primary>configuration</primary><secondary>of the kernel</secondary>"
msgstr "<primary>組態</primary><secondary>核心</secondary>"

msgid "<primary><filename>.config</filename></primary>"
msgstr "<primary><filename>.config</filename></primary>"

msgid "The next step consists of configuring the kernel according to your needs. The exact procedure depends on the goals."
msgstr "下個步驟是根據需要組態核心。確切的程序視需要而訂。"

msgid "When recompiling a more recent version of the kernel (possibly with an additional patch), the configuration will most likely be kept as close as possible to that proposed by Debian. In this case, and rather than reconfiguring everything from scratch, it is sufficient to copy the <filename>/boot/config-<replaceable>version</replaceable></filename> file (the version is that of the kernel currently used, which can be found with the <command>uname -r</command> command) into a <filename>.config</filename> file in the directory containing the kernel sources."
msgstr "重新編譯較新版本的核心 (可能連同其補丁) 時，應儘量採用 Debian 建議的組態。在此情況下，與其從最基本開始重新編譯，不妨複製 <filename>/boot/config-<replaceable>version</replaceable></filename> 檔案 (核心正在使用的版本，可以 <command>uname -r</command> 命令查看) 進入核心原始所在資料夾內的 <filename>.config</filename> 檔案。"

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>cp /boot/config-3.16.0-4-amd64 ~/kernel/linux-source-3.16/.config</userinput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>cp /boot/config-3.16.0-4-amd64 ~/kernel/linux-source-3.16/.config</userinput>"

msgid "Unless you need to change the configuration, you can stop here and skip to <xref linkend=\"sect.kernel-build\" />. If you need to change it, on the other hand, or if you decide to reconfigure everything from scratch, you must take the time to configure your kernel. There are various dedicated interfaces in the kernel source directory that can be used by calling the <command>make <replaceable>target</replaceable></command> command, where <replaceable>target</replaceable> is one of the values described below."
msgstr "需要改變組態的話，就跳至 <xref linkend=\"sect.kernel-build\" />。或者從基本開始重新組態，就需花時間組態核心。在核心原始碼的資料夾內有很多專屬介面，供呼叫 <command>make <replaceable>target</replaceable></command> 命令，讓 <replaceable>target</replaceable> 是下列的其中一個值。"

msgid "<command>make menuconfig</command> compiles and executes a text-mode interface (this is where the <emphasis role=\"pkg\">libncurses5-dev</emphasis> package is required) which allows navigating the options available in a hierarchical structure. Pressing the <keycap>Space</keycap> key changes the value of the selected option, and <keycap>Enter</keycap> validates the button selected at the bottom of the screen; <guibutton>Select</guibutton> returns to the selected sub-menu; <guibutton>Exit</guibutton> closes the current screen and moves back up in the hierarchy; <guibutton>Help</guibutton> will display more detailed information on the role of the selected option. The arrow keys allow moving within the list of options and buttons. To exit the configuration program, choose <guibutton>Exit</guibutton> from the main menu. The program then offers to save the changes you've made; accept if you are satisfied with your choices."
msgstr "<command>make menuconfig</command> 編譯並執行文字模式介面 (即 <emphasis role=\"pkg\">libncurses5-dev</emphasis> 套件必備) 以階層結構瀏覽可用的選項。按 <keycap>空格</keycap> 鍵改變選定的值，並按螢幕下方的 <keycap>Enter</keycap> 鈕；<guibutton>Select</guibutton> 送回選定的次選單；<guibutton>Exit</guibutton> 關閉當前的螢幕並回到上個階層；<guibutton>Help</guibutton> 顯示選項的詳細資訊。箭頭鍵在選項及按鈕清單內動。按主選單的 <guibutton>Exit</guibutton> 鈕，就可離開組態程式。此程式可儲存改變的組態；接受改變後的組態。"

msgid "Other interfaces have similar features, but they work within more modern graphical interfaces; such as <command>make xconfig</command> which uses a Qt graphical interface, and <command>make gconfig</command> which uses GTK+. The former requires <emphasis role=\"pkg\">libqt4-dev</emphasis>, while the latter depends on <emphasis role=\"pkg\">libglade2-dev</emphasis> and <emphasis role=\"pkg\">libgtk2.0-dev</emphasis>."
msgstr "其他的介面也有類似的功能，但在現代化的圖形介面運作；諸如 <command>make xconfig</command> 使用 Qt 圖形介面，而 <command>make gconfig</command> 使手 GTK+。前者用到 <emphasis role=\"pkg\">libqt4-dev</emphasis>，後者依賴 <emphasis role=\"pkg\">libglade2-dev</emphasis> 與 <emphasis role=\"pkg\">libgtk2.0-dev</emphasis>。"

msgid "When using one of those configuration interfaces, it is always a good idea to start from a reasonable default configuration. The kernel provides such configurations in <filename>arch/<replaceable>arch</replaceable>/configs/*_defconfig</filename> and you can put your selected configuration in place with a command like <command>make x86_64_defconfig</command> (in the case of a 64-bit PC) or <command>make i386_defconfig</command> (in the case of a 32-bit PC)."
msgstr "使用這些組態介面時，建議從合理的預設組態開始。提供該等組態的核心在 <filename>arch/<replaceable>arch</replaceable>/configs/*_defconfig</filename>，然後可將選定的組態置於像 <command>make x86_64_defconfig</command> (64 位元電腦) 或 <command>make i386_defconfig</command> (32 位元電腦) 這樣的命令。"

msgid "<emphasis>TIP</emphasis> Dealing with outdated <filename>.config</filename> files"
msgstr "<emphasis>秘訣</emphasis> 處理過時的 <filename>.config</filename> 檔案"

msgid "When you provide a <filename>.config</filename> file that has been generated with another (usually older) kernel version, you will have to update it. You can do so with <command>make oldconfig</command>, it will interactively ask you the questions corresponding to the new configuration options. If you want to use the default answer to all those questions you can use <command>make olddefconfig</command>. With <command>make oldnoconfig</command>, it will assume a negative answer to all questions."
msgstr "使用其他 (通常是較舊的) 核心版本的 <filename>.config</filename> 檔案時，需要先更新它。可以使用 <command>make oldconfig</command> 命令，以互動方式詢問對新組態的選擇。可以用 <command>make olddefconfig</command> 命令使用問題預設的答案。以 <command>make oldnoconfig</command> 命令，可以對問題提供預設的負面答案。"

msgid "Compiling and Building the Package"
msgstr "編譯與建立套件"

msgid "<primary><command>make deb-pkg</command></primary>"
msgstr "<primary><command>make deb-pkg</command></primary>"

msgid "<emphasis>NOTE</emphasis> Clean up before rebuilding"
msgstr "<emphasis>說明</emphasis> 建立前先清除"

msgid "If you have already compiled once in the directory and wish to rebuild everything from scratch (for example because you substantially changed the kernel configuration), you will have to run <command>make clean</command> to remove the compiled files. <command>make distclean</command> removes even more generated files, including your <filename>.config</filename> file too, so make sure to backup it first."
msgstr "若已在資料夾內編譯過，希望從基礎重新建立 (或許更換核心組態)，需執行 <command>make clean</command> 命令移除已編譯的檔案。<command>make distclean</command> 命令可移除更多的檔案，包括客製的 <filename>.config</filename> 檔案，別忘了先備份。"

msgid "Once the kernel configuration is ready, a simple <command>make deb-pkg</command> will generate up to 5 Debian packages: <emphasis role=\"pkg\">linux-image-<replaceable>version</replaceable></emphasis> that contains the kernel image and the associated modules, <emphasis role=\"pkg\">linux-headers-<replaceable>version</replaceable></emphasis> which contains the header files required to build external modules, <emphasis role=\"pkg\">linux-firmware-image-<replaceable>version</replaceable></emphasis> which contains the firmware files needed by some drivers (this package might be missing when you build from the kernel sources provided by Debian), <emphasis role=\"pkg\">linux-image-<replaceable>version</replaceable>-dbg</emphasis> which contains the debugging symbols for the kernel image and its modules, and <emphasis role=\"pkg\">linux-libc-dev</emphasis> which contains headers relevant to some user-space libraries like GNU glibc."
msgstr "核心組態完成後，<command>make deb-pkg</command> 命令可產生至多 5 個 Debian 套件：<emphasis role=\"pkg\">linux-image-<replaceable>version</replaceable></emphasis> 包括核心映像與相關的模組，<emphasis role=\"pkg\">linux-headers-<replaceable>version</replaceable></emphasis> 包括建立外部模組所需的標頭檔案，<emphasis role=\"pkg\">linux-firmware-image-<replaceable>version</replaceable></emphasis> 包括某些驅動程式所需的韌體 (由 Debian 提供的核心原始檔建立時，可能沒有該套件)，<emphasis role=\"pkg\">linux-image-<replaceable>version</replaceable>-dbg</emphasis> 包括供套件映像及其模組的除錯符號，以及<emphasis role=\"pkg\">linux-libc-dev</emphasis> 包括 GNU glibc 之類與使用者程式庫相關的標頭。"

msgid "The <replaceable>version</replaceable> is defined by the concatenation of the upstream version (as defined by the variables <literal>VERSION</literal>, <literal>PATCHLEVEL</literal>, <literal>SUBLEVEL</literal> and <literal>EXTRAVERSION</literal> in the <filename>Makefile</filename>), of the <literal>LOCALVERSION</literal> configuration parameter, and of the <literal>LOCALVERSION</literal> environment variable. The package version reuses the same version string with an appended revision that is regularly incremented (and stored in <filename>.version</filename>), except if you override it with the <literal>KDEB_PKGVERSION</literal> environment variable."
msgstr "<replaceable>version</replaceable> 由並列的上游版本決定 (如同變數 <literal>VERSION</literal>、<literal>PATCHLEVEL</literal>、<literal>SUBLEVEL</literal> 與 <literal>EXTRAVERSION</literal> 在 <filename>Makefile</filename> 內所定)、並列的 <literal>LOCALVERSION</literal> 組態參數、以及並列的 <literal>LOCALVERSION</literal> 環境變數。套件版本使用同版本字串以及新增的附加版本 (並儲存在 <filename>.version</filename>)，除非以 <literal>KDEB_PKGVERSION</literal> 環境變數覆寫它們。"

msgid ""
"<computeroutput>$ </computeroutput><userinput>make deb-pkg LOCALVERSION=-falcot KDEB_PKGVERSION=$(make kernelversion)-1\n"
"</userinput><computeroutput>[...]\n"
"$ </computeroutput><userinput>ls ../*.deb\n"
"</userinput><computeroutput>../linux-headers-3.16.7-ckt4-falcot_3.16.7-1_amd64.deb\n"
"../linux-image-3.16.7-ckt4-falcot_3.16.7-1_amd64.deb\n"
"../linux-image-3.16.7-ckt4-falcot-dbg_3.16.7-1_amd64.deb\n"
"../linux-libc-dev_3.16.7-1_amd64.deb\n"
"</computeroutput>"
msgstr ""
"<computeroutput>$ </computeroutput><userinput>make deb-pkg LOCALVERSION=-falcot KDEB_PKGVERSION=$(make kernelversion)-1\n"
"</userinput><computeroutput>[...]\n"
"$ </computeroutput><userinput>ls ../*.deb\n"
"</userinput><computeroutput>../linux-headers-3.16.7-ckt4-falcot_3.16.7-1_amd64.deb\n"
"../linux-image-3.16.7-ckt4-falcot_3.16.7-1_amd64.deb\n"
"../linux-image-3.16.7-ckt4-falcot-dbg_3.16.7-1_amd64.deb\n"
"../linux-libc-dev_3.16.7-1_amd64.deb\n"
"</computeroutput>"

msgid "Compiling External Modules"
msgstr "編譯外部模組"

msgid "<primary>kernel</primary><secondary>external modules</secondary>"
msgstr "<primary>核心</primary><secondary>外部模組</secondary>"

msgid "<primary>modules</primary><secondary>external kernel modules</secondary>"
msgstr "<primary>模組</primary><secondary>外部核心模組</secondary>"

msgid "<primary><command>dkms</command></primary>"
msgstr "<primary><command>dkms</command></primary>"

msgid "Some modules are maintained outside of the official Linux kernel. To use them, they must be compiled alongside the matching kernel. A number of common third party modules are provided by Debian in dedicated packages, such as <emphasis role=\"pkg\">xtables-addons-source</emphasis> (extra modules for iptables) or <emphasis role=\"pkg\">oss4-source</emphasis> (Open Sound System, some alternative audio drivers)."
msgstr "部份模組由 Linux 官方核心之外維護。使用時，必須與匹配的核心一起編譯。若干常見的第三方模組由 Debian 指定套件提供，諸如 <emphasis role=\"pkg\">xtables-addons-source</emphasis> (iptables 的外部模組) 或 <emphasis role=\"pkg\">oss4-source</emphasis> (Open Sound System，某些額外的音效驅動程式)。"

msgid "These external packages are many and varied and we won't list them all here; the <command>apt-cache search source$</command> command can narrow down the search field. However, a complete list isn't particularly useful since there is no particular reason for compiling external modules except when you know you need it. In such cases, the device's documentation will typically detail the specific module(s) it needs to function under Linux."
msgstr "這些外部套件極多且雜，在此無法全部列舉；<command>apt-cache search source$</command> 命令可縮小搜尋的範圍。然而，完整的清單沒什麼用處，祗有明確知道需要時，才會編譯特定的外部模組。在這個情況下，設備的文件會詳述 Linux 環境所需的模組。"

msgid "For example, let's look at the <emphasis role=\"pkg\">xtables-addons-source</emphasis> package: after installation, a <filename>.tar.bz2</filename> of the module's sources is stored in <filename>/usr/src/</filename>. While we could manually extract the tarball and build the module, in practice we prefer to automate all this using DKMS. Most modules offer the required DKMS integration in a package ending with a <literal>-dkms</literal> suffix. In our case, installing <emphasis role=\"pkg\">xtables-addons-dkms</emphasis> is all that is needed to compile the kernel module for the current kernel provided that we have the <emphasis role=\"pkg\">linux-headers-*</emphasis> package matching the installed kernel. For instance, if you use <emphasis role=\"pkg\">linux-image-amd64</emphasis>, you would also install <emphasis role=\"pkg\">linux-headers-amd64</emphasis>."
msgstr "以 <emphasis role=\"pkg\">xtables-addons-source</emphasis> 套件為例：安裝之後，模組原始檔 <filename>.tar.bz2</filename> 儲存在 <filename>/usr/src/</filename>。可以手動解開該壓縮檔並建立模組，也可用 DKMS 自動做它。大部份模組提供必要的 DKMS 以 <literal>-dkms</literal> 後置文字整合入套件。在本例中，安裝 <emphasis role=\"pkg\">xtables-addons-dkms</emphasis> 就是為當前核心編譯核心模組，前提是有匹配已安裝核心的 <emphasis role=\"pkg\">linux-headers-*</emphasis> 套件。例如，使用 <emphasis role=\"pkg\">linux-image-amd64</emphasis>，則應同時安裝 <emphasis role=\"pkg\">linux-headers-amd64</emphasis>。"

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>sudo apt install xtables-addons-dkms</userinput>\n"
"<computeroutput>\n"
"[...]\n"
"Setting up xtables-addons-dkms (2.6-1) ...\n"
"Loading new xtables-addons-2.6 DKMS files...\n"
"First Installation: checking all kernels...\n"
"Building only for 3.16.0-4-amd64\n"
"Building initial module for 3.16.0-4-amd64\n"
"Done.\n"
"\n"
"xt_ACCOUNT:\n"
"Running module version sanity check.\n"
" - Original module\n"
"   - No original module exists within this kernel\n"
" - Installation\n"
"   - Installing to /lib/modules/3.16.0-4-amd64/updates/dkms/\n"
"[...]\n"
"DKMS: install completed.\n"
"$ </computeroutput><userinput>sudo dkms status</userinput>\n"
"<computeroutput>xtables-addons, 2.6, 3.16.0-4-amd64, x86_64: installed\n"
"$ </computeroutput><userinput>sudo modinfo xt_ACCOUNT</userinput>\n"
"<computeroutput>filename:       /lib/modules/3.16.0-4-amd64/updates/dkms/xt_ACCOUNT.ko\n"
"license:        GPL\n"
"alias:          ipt_ACCOUNT\n"
"author:         Intra2net AG &lt;opensource@intra2net.com&gt;\n"
"description:    Xtables: per-IP accounting for large prefixes\n"
"[...]\n"
"</computeroutput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>sudo apt install xtables-addons-dkms</userinput>\n"
"<computeroutput>\n"
"[...]\n"
"Setting up xtables-addons-dkms (2.6-1) ...\n"
"Loading new xtables-addons-2.6 DKMS files...\n"
"First Installation: checking all kernels...\n"
"Building only for 3.16.0-4-amd64\n"
"Building initial module for 3.16.0-4-amd64\n"
"Done.\n"
"\n"
"xt_ACCOUNT:\n"
"Running module version sanity check.\n"
" - Original module\n"
"   - No original module exists within this kernel\n"
" - Installation\n"
"   - Installing to /lib/modules/3.16.0-4-amd64/updates/dkms/\n"
"[...]\n"
"DKMS: install completed.\n"
"$ </computeroutput><userinput>sudo dkms status</userinput>\n"
"<computeroutput>xtables-addons, 2.6, 3.16.0-4-amd64, x86_64: installed\n"
"$ </computeroutput><userinput>sudo modinfo xt_ACCOUNT</userinput>\n"
"<computeroutput>filename:       /lib/modules/3.16.0-4-amd64/updates/dkms/xt_ACCOUNT.ko\n"
"license:        GPL\n"
"alias:          ipt_ACCOUNT\n"
"author:         Intra2net AG &lt;opensource@intra2net.com&gt;\n"
"description:    Xtables: per-IP accounting for large prefixes\n"
"[...]\n"
"</computeroutput>"

msgid "<emphasis>ALTERNATIVE</emphasis> module-assistant"
msgstr "<emphasis>其他</emphasis> module-assistant"

msgid "<primary><emphasis role=\"pkg\">module-assistant</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">module-assistant</emphasis></primary>"

msgid "Before DKMS, <emphasis role=\"pkg\">module-assistant</emphasis> was the simplest solution to build and deploy kernel modules. It can still be used, in particular for packages lacking DKMS integration: with a simple command like <command>module-assistant auto-install xtables-addons</command> (or <command>m-a a-i xtables-addons</command> for short), the modules are compiled for the current kernel, put in a new Debian package, and that package gets installed on the fly."
msgstr "DKMS 出現以前，<emphasis role=\"pkg\">module-assistant</emphasis> 是建立與布署核心模組的最簡單解決方案。目前還能用，特別是缺少 DKMS 整合的情況：以 <command>module-assistant auto-install xtables-addons</command> (或較短的 <command>m-a a-i xtables-addons</command>) 命令，就能編譯出給當前核心使用的模繻，置於新的 Debian 套件，讓該套件可以即時安裝。"

msgid "Applying a Kernel Patch"
msgstr "使用核心補丁"

msgid "<primary>kernel</primary><secondary>patch</secondary>"
msgstr "<primary>核心</primary><secondary>補丁</secondary>"

msgid "<primary>patch of the kernel</primary>"
msgstr "<primary>核心的補丁</primary>"

msgid "Some features are not included in the standard kernel due to a lack of maturity or to some disagreement with the kernel maintainers. Such features may be distributed as patches that anyone is then free to apply to the kernel sources."
msgstr "因為不夠成熟或核心維護者意見不一致，很多功能未列入標準的核心。這種功能就以補丁的型式發行，任何人都可以自由地把它維入核心原始碼。"

msgid "Debian distributes some of these patches in <emphasis role=\"pkg\">linux-patch-*</emphasis> or <emphasis role=\"pkg\">kernel-patch-*</emphasis> packages (for instance, <emphasis role=\"pkg\">linux-patch-grsecurity2</emphasis>, which tightens some of the kernel's security policies). These packages install files in the <filename>/usr/src/kernel-patches/</filename> directory."
msgstr "Debian 以 <emphasis role=\"pkg\">linux-patch-*</emphasis> 或 <emphasis role=\"pkg\">kernel-patch-*</emphasis> 方式散布這些套件 (例如，<emphasis role=\"pkg\">linux-patch-grsecurity2</emphasis>，可以緊縮核心的安全政策)。這些套件安裝的檔案在 <filename>/usr/src/kernel-patches/</filename> 資料夾內。"

msgid "To apply one or more of these installed patches, use the <command>patch</command> command in the sources directory then start compilation of the kernel as described above."
msgstr "在原始檔資料夾內，以 <command>patch</command> 命令編譯核心，就能夠納入前述安裝的補丁。"

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>cd ~/kernel/linux-source-3.16</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>make clean</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>zcat /usr/src/kernel-patches/diffs/grsecurity2/grsecurity-3.0-3.17.1-201410250027.patch.gz | patch -p1</userinput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>cd ~/kernel/linux-source-3.16</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>make clean</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>zcat /usr/src/kernel-patches/diffs/grsecurity2/grsecurity-3.0-3.17.1-201410250027.patch.gz | patch -p1</userinput>"

msgid "Note that a given patch may not necessarily work with every version of the kernel; it is possible for <command>patch</command> to fail when applying them to kernel sources. An error message will be displayed and give some details about the failure; in this case, refer to the documentation available in the Debian package of the patch (in the <filename>/usr/share/doc/linux-patch-*/</filename> directory). In most cases, the maintainer indicates for which kernel versions their patch is intended."
msgstr "有些補丁不見得適用於每個核心版本；以 <command>patch</command> 可能無法應用於核心原始碼。將出現錯誤訊息且提示錯誤的原因；在此情況下，參照 Debian 補丁套件的文件 (位於 <filename>/usr/share/doc/linux-patch-*/</filename> 資料夾)。大部份的情況下，維護者會指出其補丁適用的核心版本。"

msgid "Installing a Kernel"
msgstr "安裝核心"

msgid "<primary>installation</primary><secondary>of a kernel</secondary>"
msgstr "<primary>安裝</primary><secondary>核心</secondary>"

msgid "<primary>kernel</primary><secondary>installation</secondary>"
msgstr "<primary>核心</primary><secondary>安裝</secondary>"

msgid "Features of a Debian Kernel Package"
msgstr "Debian 核心套件的特色"

msgid "<primary><filename>vmlinuz</filename></primary>"
msgstr "<primary><filename>vmlinuz</filename></primary>"

msgid "A Debian kernel package installs the kernel image (<filename>vmlinuz-<replaceable>version</replaceable></filename>), its configuration (<filename>config-<replaceable>version</replaceable></filename>) and its symbols table (<filename>System.map-<replaceable>version</replaceable></filename>) in <filename>/boot/</filename>. The symbols table helps developers understand the meaning of a kernel error message; without it, kernel “oopses” (an “oops” is the kernel equivalent of a segmentation fault for user-space programs, in other words messages generated following an invalid pointer dereference) only contain numeric memory addresses, which is useless information without the table mapping these addresses to symbols and function names. The modules are installed in the <filename>/lib/modules/<replaceable>version</replaceable>/</filename> directory."
msgstr "Debian 核心套件安裝核心映像 (<filename>vmlinuz-<replaceable>version</replaceable></filename>)、其組態 (<filename>config-<replaceable>version</replaceable></filename>) 與符號表 (<filename>System.map-<replaceable>version</replaceable></filename>) 於 <filename>/boot/</filename> 內。符號表協助發展者瞭解核心錯誤訊息的意義；少了心，核心 “oopses” (“oops” 是相當於給使用者程式的核心區段錯誤，換句話說，訊息加上錯誤指標) 祗有數字記憶體位址，沒有符號表對映該等位址至符號與功能的話，本身是無意義的。該等模組安裝在 <filename>/lib/modules/<replaceable>version</replaceable>/</filename> 資料夾。"

msgid "The package's configuration scripts automatically generate an initrd image, which is a mini-system designed to be loaded in memory (hence the name, which stands for “init ramdisk”) by the bootloader, and used by the Linux kernel solely for loading the modules needed to access the devices containing the complete Debian system (for example, the driver for SATA disks). Finally, the post-installation scripts update the symbolic links <filename>/vmlinuz</filename>, <filename>/vmlinuz.old</filename>, <filename>/initrd.img</filename> and <filename>/initrd.img.old</filename> so that they point to the latest two kernels installed, respectively, as well as the corresponding initrd images."
msgstr "套件的組態腳本自動產生 initrd 映像，此為由啟動程式載入記憶體的迷你系統 (其名稱源自於此，表示為 “init ramdisk”)，被 Linux 核心專用於載入包括完整 Debian 系統設備的模組 (例如，SATA 磁碟機的驅動程式)。最後，安裝後腳本更新符號連結 <filename>/vmlinuz</filename>、<filename>/vmlinuz.old</filename>、<filename>/initrd.img</filename> 與 <filename>/initrd.img.old</filename>，讓它們分別指向最新的兩個核心， 以及對映的 initrd 映像。"

msgid "Most of those tasks are offloaded to hook scripts in the <filename>/etc/kernel/*.d/</filename> directories. For instance, the integration with <command>grub</command> relies on <filename>/etc/kernel/postinst.d/zz-update-grub</filename> and <filename>/etc/kernel/postrm.d/zz-update-grub</filename> to call <command>update-grub</command> when kernels are installed or removed."
msgstr "大部份的這些工作卸載至 <filename>/etc/kernel/*.d/</filename> 資料夾內的腳本。例如，當已安裝或移除核心時，整合 <command>grub</command> 於 <filename>/etc/kernel/postinst.d/zz-update-grub</filename> 和 <filename>/etc/kernel/postrm.d/zz-update-grub</filename> 呼叫 <command>update-grub</command>。"

msgid "Installing with <command>dpkg</command>"
msgstr "與 <command>dpkg</command> 整合"

msgid "Using <command>apt</command> is so convenient that it makes it easy to forget about the lower-level tools, but the easiest way of installing a compiled kernel is to use a command such as <command>dpkg -i <replaceable>package</replaceable>.deb</command>, where <literal><replaceable>package</replaceable>.deb</literal> is the name of a <emphasis role=\"pkg\">linux-image</emphasis> package such as <filename>linux-image-3.16.7-ckt4-falcot_1_amd64.deb</filename>."
msgstr "使用 <command>apt</command> 極為便利，以致常忘記它是極為低階的工具，但是安裝被編譯的核心可使用更簡單的工具，諸如 <command>dpkg -i <replaceable>package</replaceable>.deb</command>，<literal><replaceable>package</replaceable>.deb</literal> 是 <emphasis role=\"pkg\">linux-image</emphasis> 套件的名稱，例如 <filename>linux-image-3.16.7-ckt4-falcot_1_amd64.deb</filename>。"

msgid "The configuration steps described in this chapter are basic and can lead both to a server system or a workstation, and it can be massively duplicated in semi-automated ways. However, it is not enough by itself to provide a fully configured system. A few pieces are still in need of configuration, starting with low-level programs known as the “Unix services”."
msgstr "本章描述供伺服器系統或工作站的基本組態，可以用半自動的方式大量複製。然而，本身還不足以提供完整的組態系統。還有若干部份需要進一步的組態，從 “Unix 服務” 之類的低階程式開始。"
