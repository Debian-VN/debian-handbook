#
# AUTHOR <EMAIL@ADDRESS>, YEAR.
# Ryuunosuke Ayanokouzi <i38w7i3@yahoo.co.jp>, 2015-2016.
# Kenshi Muto <kmuto@kmuto.jp>, 2015.
# Yoichi Chonan <cyoichi@maple.ocn.ne.jp>, 2015.
# YABUKI Youichi <yabuki@sraoss.co.jp>, 2015.
#
msgid ""
msgstr ""
"Project-Id-Version: 0\n"
"POT-Creation-Date: 2016-07-03 09:00+0900\n"
"PO-Revision-Date: 2016-07-03 09:00+0900\n"
"Last-Translator: AYANOKOUZI, Ryuunosuke <i38w7i3@yahoo.co.jp>\n"
"Language-Team: Japanese <https://github.com/l/debian-handbook/tree/master/translation_ja/push>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: application/x-publican; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "System boot"
msgstr "システム起動"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Initscripts"
msgstr "初期化スクリプト"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "SSH"
msgstr "SSH"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Telnet"
msgstr "Telnet"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Rights"
msgstr "権限"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Permissions"
msgstr "パーミッション"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Supervision"
msgstr "管理"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Inetd"
msgstr "inetd"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Cron"
msgstr "cron"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Backup"
msgstr "バックアップ"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Hotplug"
msgstr "ホットプラグ"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "PCMCIA"
msgstr "PCMCIA"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "APM"
msgstr "APM"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "ACPI"
msgstr "ACPI"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Unix Services"
msgstr "Unix サービス"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "This chapter covers a number of basic services that are common to many Unix systems. All administrators should be familiar with them."
msgstr "この章では、多くの Unix システムに共通する数多くの基本的なサービスをカバーします。すべての管理者はこれらの基本的なサービスに精通しているべきです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "System Boot"
msgstr "システム起動"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>booting</primary><secondary>the system</secondary>"
msgstr "<primary>起動</primary><secondary>システムの起動</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "When you boot the computer, the many messages scrolling by on the console display many automatic initializations and configurations that are being executed. Sometimes you may wish to slightly alter how this stage works, which means that you need to understand it well. That is the purpose of this section."
msgstr "コンピュータを起動する際、コンソール画面にスクロールされる多くのメッセージには、実行されている多くの自動初期化と自動設定に関する情報が表示されます。この段階の挙動を少し変えたいと思うことがあるかもしれません。これは起動処理をよく理解する必要があることを意味しています。この節の目的は起動処理をよく理解することにあります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "First, the BIOS takes control of the computer, detects the disks, loads the <emphasis>Master Boot Record</emphasis>, and executes the bootloader. The bootloader takes over, finds the kernel on the disk, loads and executes it. The kernel is then initialized, and starts to search for and mount the partition containing the root filesystem, and finally executes the first program — <command>init</command>. Frequently, this “root partition” and this <command>init</command> are, in fact, located in a virtual filesystem that only exists in RAM (hence its name, “initramfs”, formerly called “initrd” for “initialization RAM disk”). This filesystem is loaded in memory by the bootloader, often from a file on a hard drive or from the network. It contains the bare minimum required by the kernel to load the “true” root filesystem: this may be driver modules for the hard drive, or other devices without which the system cannot boot, or, more frequently, initialization scripts and modules for assembling RAID arrays, opening encrypted partitions, activating LVM volumes, etc. Once the root partition is mounted, the initramfs hands over control to the real init, and the machine goes back to the standard boot process."
msgstr "最初に BIOS がコンピュータを制御し、ディスクを検出し、<emphasis>マスターブートレコード</emphasis>を読み込み、ブートローダを実行します。以降、ブートローダが引き継ぎ、ディスクからカーネルを見つけ、カーネルを読み込んで実行します。そして、カーネルが初期化され、ルートファイルシステムを含むパーティションの検索とマウントを開始し、最後に最初のプログラムである <command>init</command> を実行します。「ルートパーティション」と <command>init</command> は RAM の中にだけ存在する仮想ファイルシステム (これは現在「initramfs」と呼ばれていますが、以前は「初期化 RAM ディスク」という意味で「initrd」と呼ばれていました) 上に置かれていることが多いです。多くの場合、initramfs はハードドライブのファイルかネットワークから、ブートローダによってメモリに読み込まれます。initramfs には、カーネルが「真の」ルートファイルシステムを読み込むために必要な最低限の要素が含まれています。具体的に言えば、ハードドライブやそれなしではシステムが起動できないその他のデバイスのドライバモジュール、より頻繁にあるのが、RAID アレイを組み立て、暗号化されたパーティションを開き、LVM ボリュームを有効化するなどの初期化スクリプトとモジュールが含まれています。一度ルートパーティションがマウントされたら、initramfs は制御を真の init に渡し、マシンは標準的な起動処理に戻ります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Boot sequence of a computer running Linux with systemd"
msgstr "systemd を使う Linux の動くコンピュータの起動シーケンス"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The systemd init system"
msgstr "systemd init システム"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The “real init” is currently provided by <emphasis role=\"pkg\">systemd</emphasis> and this section documents this init system."
msgstr "「init の実体」は現在 <emphasis role=\"pkg\">systemd</emphasis> によって提供されています。この節ではこの init システムに関して説明します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>CULTURE</emphasis> Before <command>systemd</command>"
msgstr "<emphasis>CULTURE</emphasis> <command>systemd</command> 以前"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<command>systemd</command> is a relatively recent “init system”, and although it was already available, to a certain extent, in <emphasis role=\"distribution\">Wheezy</emphasis>, it has only become the default in Debian <emphasis role=\"distribution\">Jessie</emphasis>. Previous releases relied, by default, on the “System V init” (in the <emphasis role=\"pkg\">sysv-rc</emphasis> package), a much more traditional system. We describe the System V init later on."
msgstr "<command>systemd</command> は比較的最近の「init システム」で、既に <emphasis role=\"distribution\">Wheezy</emphasis> ではある程度利用できましたが、Debian <emphasis role=\"distribution\">Jessie</emphasis> からデフォルトに採用されました。以前のリリースはデフォルトで「System V init」(<emphasis role=\"pkg\">sysv-rc</emphasis> パッケージに含まれます) を採用していました。System V init はより伝統的なシステムです。System V init については後で説明します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>ALTERNATIVE</emphasis> Other boot systems"
msgstr "<emphasis>ALTERNATIVE</emphasis> 他の起動システム"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "This book describes the boot system used by default in Debian <emphasis role=\"distribution\">Jessie</emphasis> (as implemented by the <emphasis role=\"pkg\">systemd</emphasis> package), as well as the previous default, <emphasis role=\"pkg\">sysvinit</emphasis>, which is derived and inherited from <emphasis>System V</emphasis> Unix systems; there are others."
msgstr "本書は Debian <emphasis role=\"distribution\">Jessie</emphasis> のデフォルト起動システム (<emphasis role=\"pkg\">systemd</emphasis> パッケージによる実装) および以前のデフォルト起動システム <emphasis role=\"pkg\">sysvinit</emphasis> について説明します。<emphasis role=\"pkg\">sysvinit</emphasis> は <emphasis>System V</emphasis> Unix システムから派生し受け継がれたものです。また、他の起動システムも存在します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis role=\"pkg\">file-rc</emphasis> is a boot system with a very simple process. It keeps the principle of runlevels, but replaces the directories and symbolic links with a configuration file, which indicates to <command>init</command> the processes that must be started and their launch order."
msgstr "<emphasis role=\"pkg\">file-rc</emphasis> は極めて単純なやり方を使う起動システムです。<emphasis role=\"pkg\">file-rc</emphasis> はランレベルの原則を守りますが、ディレクトリとシンボリックリンクを設定ファイルで置換します。この設定ファイルを使って <command>init</command> に対して起動するプロセスとその起動順を伝えます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <command>upstart</command> system is still not perfectly tested on Debian. It is event based: init scripts are no longer executed in a sequential order but in response to events such as the completion of another script upon which they are dependent. This system, started by Ubuntu, is present in Debian <emphasis role=\"distribution\">Jessie</emphasis>, but is not the default; it comes, in fact, as a replacement for <emphasis role=\"pkg\">sysvinit</emphasis>, and one of the tasks launched by <command>upstart</command> is to launch the scripts written for traditional systems, especially those from the <emphasis role=\"pkg\">sysv-rc</emphasis> package."
msgstr "Debian 上の <command>upstart</command> システムはまだ完全にテストされていません。<command>upstart</command> はイベントに基づく起動システムです。すなわち init スクリプトはもはや逐次的順序でなく、スクリプトの完了などのイベントに応じてそのスクリプトに依存していた別のスクリプトが起動されます。Ubuntu の始めた <command>upstart</command> システムは Debian <emphasis role=\"distribution\">Jessie</emphasis> に含まれますが、デフォルトではありません。実際のところ、<command>upstart</command> は <emphasis role=\"pkg\">sysvinit</emphasis> の代替として始まり、<command>upstart</command> の起動するタスクの 1 つが <emphasis role=\"pkg\">sysv-rc</emphasis> パッケージの提供する伝統的なシステム向けに書かれたスクリプトを起動するようになっています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "There are also other systems and other operating modes, such as <command>runit</command> or <command>minit</command>, but they are relatively specialized and not widespread."
msgstr "他の起動システムや他の動作モードも存在します。たとえば <command>runit</command> や <command>minit</command> などです。しかしこれらは比較的特殊で広く使われていません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>SPECIFIC CASE</emphasis> Booting from the network"
msgstr "<emphasis>SPECIFIC CASE</emphasis> ネットワークからの起動"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: PTAL;
msgid "In some configurations, the BIOS may be configured not to execute the MBR, but to seek its equivalent on the network, making it possible to build computers without a hard drive, or which are completely reinstalled on each boot. This option is not available on all hardware and it generally requires an appropriate combination of BIOS and network card."
msgstr "一部の設定では、BIOS が MBR を実行しないように設定され、その代わり MBR に相当するものをネットワークから探すように設定されているかもしれません。こうすることで、ハードドライブなしでコンピュータを組み立てたり、起動するたびに完全に再インストールすることが可能になります。このオプションは、すべてのハードウェアで利用できるというわけではありませんし、通常 BIOS とネットワークカードの適切な組み合わせが必要です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Booting from the network can be used to launch the <command>debian-installer</command> or FAI (see <xref linkend=\"sect.installation-methods\" />)."
msgstr "ネットワークからの起動は <command>debian-installer</command> や FAI (<xref linkend=\"sect.installation-methods\" />を参照してください) を起動するために使われます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> The process, a program instance"
msgstr "<emphasis>BACK TO BASICS</emphasis> プロセス、プログラムインスタンス"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>process</primary>"
msgstr "<primary>プロセス</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: PTAL;
msgid "A process is the representation in memory of a running program. It includes all of the information necessary for the proper execution of the software (the code itself, but also the data that it has in memory, the list of files that it has opened, the network connections it has established, etc.). A single program may be instantiated into several processes, not necessarily running under different user IDs."
msgstr "プロセスとは実行中のプログラムのメモリ内表現です。プロセスにはソフトウェアを適切に実行するために必要なすべての情報が含まれます (これにはソフトウェアのコードだけでなく、ソフトウェアが所有するメモリ内のデータ、ソフトウェアが開いたファイルのリスト、ソフトウェアが確立したネットワーク接続などが含まれます)。単独のプログラムが複数のプロセスを生成するかもしれませんし、ユーザはこの単独のプログラムを複数実行することも可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: $ man 7 bootparam;
# Tag: PTAL;
msgid "<emphasis>SECURITY</emphasis> Using a shell as <command>init</command> to gain root rights"
msgstr "<emphasis>SECURITY</emphasis> <command>init</command> にシェルを実行させて root 権限を獲得する"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "By convention, the first process that is booted is the <command>init</command> program (which is a symbolic link to <filename>/lib/systemd/systemd</filename> by default). However, it is possible to pass an <literal>init</literal> option to the kernel indicating a different program."
msgstr "慣例によれば、起動される最初のプロセスは <command>init</command> プログラムです (これはデフォルトで <filename>/lib/systemd/systemd</filename> へのシンボリックリンクです)。しかしながら、カーネルに <literal>init</literal> オプションを渡して別のプログラムを開始することも可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>init</command></primary>"
msgstr "<primary><command>init</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Any person who is able to access the computer can press the <keycap>Reset</keycap> button, and thus reboot it. Then, at the bootloader's prompt, it is possible to pass the <literal>init=/bin/sh</literal> option to the kernel to gain root access without knowing the administrator's password."
msgstr "コンピュータに触ることができる人は誰でも <keycap>Reset</keycap> ボタンを押してコンピュータを再起動することが可能です。そして、ブートローダプロンプトでカーネルに <literal>init=/bin/sh</literal> オプションを渡せば、管理者パスワードを知らなくても root 権限を取得できます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "To prevent this, you can protect the bootloader itself with a password. You might also think about protecting access to the BIOS (a password protection mechanism is almost always available), without which a malicious intruder could still boot the machine on a removable media containing its own Linux system, which they could then use to access data on the computer's hard drives."
msgstr "これを避けるため、パスワードでブートローダを保護することが可能です。さらに BIOS へのアクセスも保護したいと考えるかもしれません (BIOS に対するパスワード保護機能はほぼ必ず付いています)。BIOS に対するパスワード保護機能がなければ、悪意ある侵入者が自分の Linux システムを含むリムーバブルメディアからマシンを起動して、コンピュータのハードドライブのデータにアクセスするかもしれません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Finally, be aware that most BIOS have a generic password available. Initially intended for troubleshooting for those who have forgotten their password, these passwords are now public and available on the Internet (see for yourself by searching for “generic BIOS passwords” in a search engine). All of these protections will thus impede unauthorized access to the machine without being able to completely prevent it. There is no reliable way to protect a computer if the attacker can physically access it; they could dismount the hard drives to connect them to a computer under their own control anyway, or even steal the entire machine, or erase the BIOS memory to reset the password…"
msgstr "最後に、多くの BIOS では汎用的なパスワードが使えるという点に注意してください。当初、汎用パスワードはパスワードを忘れた人向けのトラブルシューティングを意図していましたが、今や汎用パスワードは公開されインターネットから入手できます (ご自分の手で、検索エンジンで「generic BIOS passwords」を検索してみてください)。前述した保護機能を使えば、マシンへの不正アクセスを完全に防ぐことはできないにせよ、それを遅らせることは可能でしょう。しかしながら、攻撃者が物理的にコンピュータにアクセスできる場合、確実にコンピュータを保護する方法は存在しません。すなわち、攻撃者は対象のコンピュータからハードドライブを取り外してそれを自分の制御下にあるコンピュータに接続したり、マシン本体ごと盗んだり、パスワードをリセットするために BIOS メモリを消去することも可能ということです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Systemd executes several processes, in charge of setting up the system: keyboard, drivers, filesystems, network, services. It does this while keeping a global view of the system as a whole, and the requirements of the components. Each component is described by a “unit file” (sometimes more); the general syntax is derived from the widely-used “*.ini files“ syntax, with <literal><replaceable>key</replaceable> = <replaceable>value</replaceable></literal> pairs grouped between <literal>[<replaceable>section</replaceable>]</literal> headers. Unit files are stored under <filename>/lib/systemd/system/</filename> and <filename>/etc/systemd/system/</filename>; they come in several flavours, but we will focus on “services” and “targets” here."
msgstr "Systemd はシステムの設定を担当している複数のプロセスを実行します。具体的に言えば、キーボード、ドライバ、ファイルシステム、ネットワーク、サービスなどの要素が設定されます。Systemd はシステム全体におよぶ包括的視点と各要素の要求条件を満足させながらプロセスを実行します。各要素は「ユニットファイル」によって定義されています (「ユニットファイル」以外のファイルが必要な場合もあります)。ユニットファイルの一般的な構文は広く使われている「*.ini ファイル」の構文から派生したもので、<literal>[<replaceable>section</replaceable>]</literal> ヘッダでグループ化された <literal><replaceable>key</replaceable> = <replaceable>value</replaceable></literal> ペアを使います。ユニットファイルは <filename>/lib/systemd/system/</filename> と <filename>/etc/systemd/system/</filename> の下に保存されます。ユニットファイルにはいくつかの形式がありますが、ここでは「service」型と「target」型に注目します。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: $ man 5 systemd.service;
msgid "A systemd “service file” describes a process managed by systemd. It contains roughly the same information as old-style init-scripts, but expressed in a declaratory (and much more concise) way. Systemd handles the bulk of the repetitive tasks (starting and stopping the process, checking its status, logging, dropping privileges, and so on), and the service file only needs to fill in the specifics of the process. For instance, here is the service file for SSH:"
msgstr "systemd の「service ファイル」は systemd が管理するプロセスを設定するファイルです。「service ファイル」には大ざっぱに言って古いスタイルの init スクリプトと同じ情報が含まれていますが、宣言的な方法 (そしてより簡潔な方法) を使ってその情報が記述されています。systemd は大半の繰り返しタスク (プロセスの開始と停止、状態確認、ログ記録、特権の取り消しなど) を処理しますので、service ファイルに記入する情報は対象プロセスに特有の情報だけで十分です。たとえば以下は SSH 用の service ファイルです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"[Unit]\n"
"Description=OpenBSD Secure Shell server\n"
"After=network.target auditd.service\n"
"ConditionPathExists=!/etc/ssh/sshd_not_to_be_run\n"
"\n"
"[Service]\n"
"EnvironmentFile=-/etc/default/ssh\n"
"ExecStart=/usr/sbin/sshd -D $SSHD_OPTS\n"
"ExecReload=/bin/kill -HUP $MAINPID\n"
"KillMode=process\n"
"Restart=on-failure\n"
"\n"
"[Install]\n"
"WantedBy=multi-user.target\n"
"Alias=sshd.service"
msgstr ""
"[Unit]\n"
"Description=OpenBSD Secure Shell server\n"
"After=network.target auditd.service\n"
"ConditionPathExists=!/etc/ssh/sshd_not_to_be_run\n"
"\n"
"[Service]\n"
"EnvironmentFile=-/etc/default/ssh\n"
"ExecStart=/usr/sbin/sshd -D $SSHD_OPTS\n"
"ExecReload=/bin/kill -HUP $MAINPID\n"
"KillMode=process\n"
"Restart=on-failure\n"
"\n"
"[Install]\n"
"WantedBy=multi-user.target\n"
"Alias=sshd.service"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "As you can see, there is very little code in there, only declarations. Systemd takes care of displaying progress reports, keeping track of the processes, and even restarting them when needed."
msgstr "ご覧の通り、コードはとても少なく宣言だけで構成されています。systemd は作業進行状況を表示したり、プロセスを監視したり、必要な時にプロセスを再起動することを担当します。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: $ man 5 systemd.target;
# Ref: $ man 5 systemd.unit;
# Tag: PTAL;
msgid "A systemd “target file” describes a state of the system, where a set of services are known to be operational. It can be thought of as an equivalent of the old-style runlevel. One of the targets is <literal>local-fs.target</literal>; when it is reached, the rest of the system can assume that all local filesystems are mounted and accessible. Other targets include <literal>network-online.target</literal> and <literal>sound.target</literal>. The dependencies of a target can be listed either within the target file (in the <literal>Requires=</literal> line), or using a symbolic link to a service file in the <literal>/lib/systemd/system/<replaceable>targetname</replaceable>.target.wants/</literal> directory. For instance, <filename>/etc/systemd/system/printer.target.wants/</filename> contains a link to <filename>/lib/systemd/system/cups.service</filename>; systemd will therefore ensure CUPS is running in order to reach <literal>printer.target</literal>."
msgstr "systemd の「target ファイル」はシステムの状態を記述するファイルで、管理者はこのファイルを使って利用できる状態にされていなければならないサービス群を指定します。「target ファイル」は昔ながらのランレベルに相当するものとして考えることが可能です。target ファイルの 1 つに <literal>local-fs.target</literal> があります。<literal>local-fs.target</literal> で定義された状態に到達した場合、残りのシステムはすべてのローカルファイルシステムがマウントされアクセスできるようになっている状態を仮定することが可能です。また別の target ファイルに <literal>network-online.target</literal> と <literal>sound.target</literal> があります。ある target ファイルの依存関係は対象の target ファイルの中 (<literal>Requires=</literal> 行) に依存関係にある service ファイルを記述するか、対象の <literal>/lib/systemd/system/<replaceable>targetname</replaceable>.target.wants/</literal> ディレクトリの中に依存関係にある service ファイルを指すシンボリックリンクを作ることで指定します。たとえば、<filename>/etc/systemd/system/printer.target.wants/</filename> には <filename>/lib/systemd/system/cups.service</filename> へのリンクが含まれます。そしてこのため systemd は <literal>printer.target</literal> を処理する前に CUPS が実行されていることを保証するでしょう。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Since unit files are declarative rather than scripts or programs, they cannot be run directly, and they are only interpreted by systemd; several utilities therefore allow the administrator to interact with systemd and control the state of the system and of each component."
msgstr "ユニットファイルは宣言型の設定ファイルでありスクリプトやプログラムではないため、ユニットファイルを直接実行することは不可能で、ユニットファイルは systemd によってのみ解釈されます。いくつかのユーティリティを使うことで、管理者は systemd と情報をやり取りして、システムおよびシステム部品の状態を制御することが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The first such utility is <command>systemctl</command>. When run without any arguments, it lists all the unit files known to systemd (except those that have been disabled), as well as their status. <command>systemctl status</command> gives a better view of the services, as well as the related processes. If given the name of a service (as in <command>systemctl status ntp.service</command>), it returns even more details, as well as the last few log lines related to the service (more on that later)."
msgstr "systemd と情報をやり取りする 1 番目のユーティリティとして <command>systemctl</command> が挙げられます。<command>systemctl</command> を引数なしで実行した場合、systemd が把握しているすべてのユニットファイル (無効化されているものを除きます) およびその状態が表示されます。<command>systemctl status</command> を使うことで、サービスおよび関連するプロセスをよりわかりやすく表示することが可能です。サービスの名前を指定した場合 (<command>systemctl status ntp.service</command> のように指定した場合)、<command>systemctl</command> はさらに詳しい情報および指定したサービスに関連するログの最後の数行を表示します (後から詳しく説明します)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Starting a service by hand is a simple matter of running <command>systemctl start <replaceable>servicename</replaceable>.service</command>. As one can guess, stopping the service is done with <command>systemctl stop <replaceable>servicename</replaceable>.service</command>; other subcommands include <command>reload</command> and <command>restart</command>."
msgstr "手作業でサービスを開始するのは簡単で、<command>systemctl start <replaceable>servicename</replaceable>.service</command> を実行するだけです。予想通り、サービスを停止するには <command>systemctl stop <replaceable>servicename</replaceable>.service</command> を使います。また、他のサブコマンドには <command>reload</command> と <command>restart</command> があります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "To control whether a service is active (i.e. whether it will get started automatically on boot), use <command>systemctl enable <replaceable>servicename</replaceable>.service</command> (or <command>disable</command>). <command>is-enabled</command> allows checking the status of the service."
msgstr "サービスを有効化するには (たとえば起動時に自動的にサービスを開始するには)、<command>systemctl enable <replaceable>servicename</replaceable>.service</command> を使います (無効化するには <command>disable</command> を使います)。<command>is-enabled</command> を使えば、サービスの状態を確認することが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "An interesting feature of systemd is that it includes a logging component named <command>journald</command>. It comes as a complement to more traditional logging systems such as <command>syslogd</command>, but it adds interesting features such as a formal link between a service and the messages it generates, and the ability to capture error messages generated by its initialisation sequence. The messages can be displayed later on, with a little help from the <command>journalctl</command> command. Without any arguments, it simply spews all log messages that occurred since system boot; it will rarely be used in such a manner. Most of the time, it will be used with a service identifier:"
msgstr "systemd が備える興味深い機能として、<command>journald</command> と名付けられたログ記録機能が挙げられます。<command>journald</command> は <command>syslogd</command> などのより伝統的なログ記録システムを補完するために誕生しましたが、サービスとサービスが生成したメッセージを正しく関連付けたり初期化シーケンスが生成するエラーメッセージを保存する能力などの興味深い機能を追加しています。<command>journalctl</command> コマンドの助けを少し借りるだけで、メッセージを後から表示することが可能になります。引数なしで実行した場合、<command>journalctl</command> は起動後に発生したすべてのログメッセージを表示しますが、引数を与えずに実行することはほとんどないでしょう。ほとんどの場合、以下のようにサービス識別子を与えて <command>journalctl</command> を実行します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"<computeroutput># </computeroutput><userinput>journalctl -u ssh.service\n"
"</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --\n"
"Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.\n"
"Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.\n"
"Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.\n"
"Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2\n"
"Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)\n"
"</computeroutput>"
msgstr ""
"<computeroutput># </computeroutput><userinput>journalctl -u ssh.service\n"
"</userinput><computeroutput>-- Logs begin at 火 2015-03-31 17:08:49 JST, end at 水 2015-04-01 00:06:02 JST. --\n"
" 3月 31 17:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.\n"
" 3月 31 17:08:55 mirtuel sshd[430]: Server listening on :: port 22.\n"
" 3月 31 17:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.\n"
" 3月 31 17:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.\n"
" 3月 31 17:09:00 mirtuel sshd[430]: Server listening on :: port 22.\n"
" 3月 31 17:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2\n"
" 3月 31 17:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)\n"
"</computeroutput>"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: PTAL;
# Ref: man 1 journalctl;
msgid "Another useful command-line flag is <command>-f</command>, which instructs <command>journalctl</command> to keep displaying new messages as they are emitted (much in the manner of <command>tail -f <replaceable>file</replaceable></command>)."
msgstr "その他の役に立つコマンドラインオプションとして <command>-f</command> が挙げられます。これを使った場合、<command>journalctl</command> は新しいメッセージを受け取ったらそのメッセージを表示し続けます (これは <command>tail -f <replaceable>file</replaceable></command> とほぼ同じやり方です)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "If a service doesn't seem to be working as expected, the first step to solve the problem is to check that the service is actually running with <command>systemctl status</command>; if it is not, and the messages given by the first command are not enough to diagnose the problem, check the logs gathered by journald about that service. For instance, assume the SSH server doesn't work:"
msgstr "サービスが期待通りに動いていないように見える場合、問題解決に向けて手始めに <command>systemctl status</command> を実行し、今現在サービスが動いているか否かを確認します。サービスが実行されておらず、<command>systemctl status</command> の表示したメッセージが問題の原因を解明するのに十分でない場合、journald が収集したサービスに関連するログを確認します。たとえば、SSH サービスが動いていないと仮定すると、以下の手順で状況を確認します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"<computeroutput># </computeroutput><userinput>systemctl status ssh.service\n"
"</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server\n"
"   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)\n"
"   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago\n"
"  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)\n"
"  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)\n"
" Main PID: 1188 (code=exited, status=255)\n"
"\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"# </computeroutput><userinput>journalctl -u ssh.service\n"
"</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --\n"
"Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.\n"
"Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.\n"
"Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.\n"
"Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2\n"
"Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)\n"
"Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"# </computeroutput><userinput>vi /etc/ssh/sshd_config\n"
"</userinput><computeroutput># </computeroutput><userinput>systemctl start ssh.service\n"
"</userinput><computeroutput># </computeroutput><userinput>systemctl status ssh.service\n"
"</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server\n"
"   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)\n"
"   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago\n"
"  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)\n"
" Main PID: 1222 (sshd)\n"
"   CGroup: /system.slice/ssh.service\n"
"           └─1222 /usr/sbin/sshd -D\n"
"# </computeroutput>"
msgstr ""
"<computeroutput># </computeroutput><userinput>systemctl status ssh.service\n"
"</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server\n"
"   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)\n"
"   Active: failed (Result: start-limit) since 水 2015-04-01 00:30:36 JST; 1s ago\n"
"  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)\n"
"  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)\n"
" Main PID: 1188 (code=exited, status=255)\n"
"\n"
" 4月  1 00:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
" 4月  1 00:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
" 4月  1 00:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.\n"
" 4月  1 00:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.\n"
" 4月  1 00:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"# </computeroutput><userinput>journalctl -u ssh.service\n"
"</userinput><computeroutput>-- Logs begin at 水 2015-04-01 00:29:27 JST, end at 水 2015-04-01 00:30:36 JST. --\n"
" 4月  1 00:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.\n"
" 4月  1 00:29:27 mirtuel sshd[424]: Server listening on :: port 22.\n"
" 4月  1 00:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.\n"
" 4月  1 00:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.\n"
" 4月  1 00:29:29 mirtuel sshd[424]: Server listening on :: port 22.\n"
" 4月  1 00:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2\n"
" 4月  1 00:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)\n"
" 4月  1 00:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
" 4月  1 00:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
" 4月  1 00:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
" 4月  1 00:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
" 4月  1 00:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
" 4月  1 00:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
" 4月  1 00:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
" 4月  1 00:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
" 4月  1 00:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
" 4月  1 00:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
" 4月  1 00:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
" 4月  1 00:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
" 4月  1 00:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
" 4月  1 00:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
" 4月  1 00:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
" 4月  1 00:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.\n"
" 4月  1 00:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.\n"
" 4月  1 00:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"# </computeroutput><userinput>vi /etc/ssh/sshd_config\n"
"</userinput><computeroutput># </computeroutput><userinput>systemctl start ssh.service\n"
"</userinput><computeroutput># </computeroutput><userinput>systemctl status ssh.service\n"
"</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server\n"
"   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)\n"
"   Active: active (running) since 水 2015-04-01 00:31:09 JST; 2s ago\n"
"  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)\n"
" Main PID: 1222 (sshd)\n"
"   CGroup: /system.slice/ssh.service\n"
"           └─1222 /usr/sbin/sshd -D\n"
"# </computeroutput>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "After checking the status of the service (failed), we went on to check the logs; they indicate an error in the configuration file. After editing the configuration file and fixing the error, we restart the service, then verify that it is indeed running."
msgstr "ここでは SSH サービスの状態が失敗状態であることを確認した後、ログの確認作業に進みました。その結果、ログは設定ファイル内にエラーがあることを示しています。そこで設定ファイルを編集してエラーを修正した後、SSH サービスを再起動し、SSH サービスが本当に動いていることを確認しました。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>GOING FURTHER</emphasis> Other types of unit files"
msgstr "<emphasis>GOING FURTHER</emphasis> ユニットファイルの他の型"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "We have only described the most basic of systemd's capabilities in this section. It offers many other interesting features; we will only list a few here:"
msgstr "この節では、systemd の最も基本的な機能だけを説明しました。systemd は他にも多くの興味深い機能を備えていますが、ここでは一部だけを紹介します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "socket activation: a “socket” unit file can be used to describe a network or Unix socket managed by systemd; this means that the socket will be created by systemd, and the actual service may be started on demand when an actual connection attempt comes. This roughly replicates the feature set of <command>inetd</command>. See <citerefentry><refentrytitle>systemd.socket</refentrytitle><manvolnum>5</manvolnum></citerefentry>."
msgstr "ソケットの活性化。「socket」型のユニットファイルを使えば、systemd が管理するネットワークや Unix ソケットを表現することが可能です。これは systemd がソケットを作成し、実際のサービスは実際の接続要求を受信した時に要求に応じて開始されることを意味しています。この機能は大ざっぱに言って <command>inetd</command> の機能群を再現するものです。詳しくは <citerefentry><refentrytitle>systemd.socket</refentrytitle><manvolnum>5</manvolnum></citerefentry> を参照してください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "timers: a “timer” unit file describes events that occur with a fixed frequency or on specific times; when a service is linked to such a timer, the corresponding task will be executed whenever the timer fires. This allows replicating part of the <command>cron</command> features. See <citerefentry><refentrytitle>systemd.timer</refentrytitle><manvolnum>5</manvolnum></citerefentry>."
msgstr "タイマ。「timer」型のユニットファイルを使えば、固定周期および特定時刻に発動するイベントを表現することが可能です。さらにサービスをタイマに関連付けた場合、タイマが発動するたびにサービスに対応するタスクを実行します。これを使うことで、<command>cron</command> 機能の一部を置き換えることが可能です。詳しくは <citerefentry><refentrytitle>systemd.timer</refentrytitle><manvolnum>5</manvolnum></citerefentry> を参照してください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "network: a “network“ unit file describes a network interface, which allows configuring such interfaces as well as expressing that a service depends on one particular interface being up."
msgstr "ネットワーク。「network」型のユニットファイルを使えば、ネットワークインターフェースを表現することが可能です。これを使うことで、ネットワークインターフェースを設定したり、サービスが特定のネットワークインターフェースの状態に依存することを表現することが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The System V init system"
msgstr "System V init システム"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The System V init system (which we'll call init for brevity) executes several processes, following instructions from the <filename>/etc/inittab</filename> file. The first program that is executed (which corresponds to the <emphasis>sysinit</emphasis> step) is <command>/etc/init.d/rcS</command>, a script that executes all of the programs in the <filename>/etc/rcS.d/</filename> directory. <indexterm><primary><filename>/etc/init.d/rcS</filename></primary></indexterm> <indexterm><primary><filename>rcS</filename></primary></indexterm> <indexterm><primary><filename>/etc/init.d/rcS.d/</filename></primary></indexterm> <indexterm><primary><filename>rcS.d</filename></primary></indexterm>"
msgstr "System V init システム (これを短縮して init と呼びます) は <filename>/etc/inittab</filename> ファイルの指示に従って複数のプロセスを実行します。実行される最初のプログラム (<emphasis>sysinit</emphasis> 段階に相当します) は <command>/etc/init.d/rcS</command> で、これは <filename>/etc/rcS.d/</filename> ディレクトリに含まれるすべてのプログラムを起動するスクリプトです。<indexterm><primary><filename>/etc/init.d/rcS</filename></primary></indexterm><indexterm><primary><filename>rcS</filename></primary></indexterm><indexterm><primary><filename>/etc/init.d/rcS.d/</filename></primary></indexterm><indexterm><primary><filename>rcS.d</filename></primary></indexterm>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Among these, you will find successively programs in charge of:"
msgstr "<filename>/etc/rcS.d/</filename> ディレクトリに含まれるスクリプトは特に以下の点を担当します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "configuring the console's keyboard;"
msgstr "コンソールキーボードの設定。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "loading drivers: most of the kernel modules are loaded by the kernel itself as the hardware is detected; extra drivers are then loaded automatically when the corresponding modules are listed in <filename>/etc/modules</filename>;"
msgstr "ドライバの読み込み。ほとんどのカーネルモジュールはハードウェアを検出した時にカーネル自身によって読み込まれます。追加のドライバはそれに対応するモジュールが <filename>/etc/modules</filename> にリストされている場合に読み込まれます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "checking the integrity of filesystems;"
msgstr "ファイルシステムの整合性確認。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "mounting local partitions;"
msgstr "ローカルパーティションのマウント。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "configuring the network;"
msgstr "ネットワークの設定。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "mounting network filesystems (NFS)."
msgstr "ネットワークファイルシステム (NFS) のマウント。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> Kernel modules and options"
msgstr "<emphasis>BACK TO BASICS</emphasis> カーネルモジュールとオプション"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>modules</primary><secondary>kernel modules</secondary>"
msgstr "<primary>モジュール</primary><secondary>カーネルモジュール</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Kernel modules also have options that can be configured by putting some files in <filename>/etc/modprobe.d/</filename>. These options are defined with directives like this: <literal>options <replaceable>module-name</replaceable> <replaceable>option-name</replaceable>=<replaceable>option-value</replaceable></literal>. Several options can be specified with a single directive if necessary."
msgstr "カーネルモジュールにオプションを指定するには、<filename>/etc/modprobe.d/</filename> にファイルを追加してください。カーネルモジュールのオプションは <literal>options <replaceable>module-name</replaceable> <replaceable>option-name</replaceable>=<replaceable>option-value</replaceable></literal> のような指示文を使って定義します。場合によっては、いくつかのオプションは単独の指示文で指定することも可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "These configuration files are intended for <command>modprobe</command> — the program that loads a kernel module with its dependencies (modules can indeed call other modules). This program is provided by the <emphasis role=\"pkg\">kmod</emphasis> package."
msgstr "<filename>/etc/modprobe.d/</filename> 内の設定ファイルは <command>modprobe</command> によって使われます。すなわち <command>modprobe</command> が依存関係に従ってカーネルモジュールを読み込みます (モジュールは他のモジュールを呼ぶことができます)。<command>modprobe</command> は <emphasis role=\"pkg\">kmod</emphasis> パッケージに含まれています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>modprobe</command></primary>"
msgstr "<primary><command>modprobe</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis role=\"pkg\">kmod</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">kmod</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: https://www.debian.org/doc/manuals/debian-reference/ch03.html;
msgid "After this stage, <command>init</command> takes over and starts the programs enabled in the default runlevel (which is usually runlevel 2). It executes <command>/etc/init.d/rc 2</command>, a script that starts all services which are listed in <filename>/etc/rc2.d/</filename> and whose names start with the “S” letter. The two-figures number that follows had historically been used to define the order in which services had to be started, but nowadays the default boot system uses <command>insserv</command>, which schedules everything automatically based on the scripts' dependencies. Each boot script thus declares the conditions that must be met to start or stop the service (for example, if it must start before or after another service); <command>init</command> then launches them in the order that meets these conditions. The static numbering of scripts is therefore no longer taken into consideration (but they must always have a name beginning with “S” followed by two digits and the actual name of the script used for the dependencies). Generally, base services (such as logging with <command>rsyslog</command>, or port assignment with <command>portmap</command>) are started first, followed by standard services and the graphical interface (<command>gdm3</command>)."
msgstr "<command>/etc/init.d/rcS</command> の完了後、<command>init</command> が起動処理を引き継いで、デフォルトランレベル (通常ランレベル 2) で有効化されたプログラムを起動します。<command>init</command> は <command>/etc/init.d/rc 2</command> を実行します。これは <filename>/etc/rc2.d/</filename> に置かれて「S」で始まる名前のすべてのサービスを開始するコマンドです。歴史的なことを言えば、「S」の後に続く 2 桁の数字は起動するサービスの順番を定義するために使われていました。しかし現在では、デフォルトの起動システムは <command>insserv</command> を使ってスクリプト同士の依存関係に従った起動順を自動的に決定します。このため、各起動スクリプトはサービスを起動または終了させる時に満足しなければいけない条件を宣言します (たとえば、あるサービスは他のサービスの前または後に起動しなければいけないなどの条件を宣言します)。そして、<command>init</command> は条件を満足するようにサービスを起動します。このため、スクリプトの静的な番号付けはもはや考慮されません (しかしスクリプトの名前は必ず「S」で始まり、その後ろに 2 桁の番号と条件を宣言する際に使われる実際のスクリプトの名前を付けなければいけません)。一般に、基盤サービス (ログ記録を担当している <command>rsyslog</command> やポート割り当てを担当している <command>portmap</command>) が最初に起動され、その後に標準的なサービスとグラフィカルインターフェース (<command>gdm3</command>) が起動されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: https://wiki.debian.org/LSBInitScripts/DependencyBasedBoot;
# Ref: https://wiki.debian.org/LSBInitScripts;
msgid "This dependency-based boot system makes it possible to automate re-numbering, which could be rather tedious if it had to be done manually, and it limits the risks of human error, since scheduling is conducted according to the parameters that are indicated. Another benefit is that services can be started in parallel when they are independent from one another, which can accelerate the boot process."
msgstr "この依存関係に基づく起動システムのおかげで、起動順を自動的に再定義することが可能になります。これは手作業でやるにはちょっと退屈な作業で、人的ミスの危険性があります。なぜなら、起動順は宣言された依存関係に従って定義されるからです。他の長所として、他のサービスに依存しないサービスは並列して開始できるという点があります。このことにより、起動処理を加速できます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>runlevel</primary>"
msgstr "<primary>ランレベル</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>level, runlevel</primary>"
msgstr "<primary>レベル、ランレベル</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<command>init</command> distinguishes several runlevels, so it can switch from one to another with the <command>telinit <replaceable>new-level</replaceable></command> command. Immediately, <command>init</command> executes <command>/etc/init.d/rc</command> again with the new runlevel. This script will then start the missing services and stop those that are no longer desired. To do this, it refers to the content of the <filename>/etc/rc<replaceable>X</replaceable>.d</filename> (where <replaceable>X</replaceable> represents the new runlevel). Scripts starting with “S” (as in “Start”) are services to be started; those starting with “K” (as in “Kill”) are the services to be stopped. The script does not start any service that was already active in the previous runlevel."
msgstr "<command>init</command> はランレベルを見分けて処理を分岐させます。ランレベルを切り替えるには <command>telinit <replaceable>new-level</replaceable></command> コマンドを使います。このコマンドを実行すると <command>init</command> は即座に新しいランレベルを引数にして <command>/etc/init.d/rc</command> を再実行します。<command>/etc/init.d/rc</command> は欠けているサービスを開始し、既に不要となったサービスを停止します。これを行うために、<command>/etc/init.d/rc</command> は <filename>/etc/rc<replaceable>X</replaceable>.d</filename> ディレクトリの内容を参照します (ここで <replaceable>X</replaceable> は新しいランレベルです)。このディレクトリに含まれる (「Start」の)「S」で始まるスクリプトは開始されるサービスで、(「Kill」の)「K」で始まるスクリプトは停止されるサービスです。<command>/etc/init.d/rc</command> は切り替え前のランレベルで既に起動されているサービスは開始しません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "By default, System V init in Debian uses four different runlevels:"
msgstr "デフォルトで、Debian の System V init は 4 種類のランレベルを使います。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Level 0 is only used temporarily, while the computer is powering down. As such, it only contains many “K” scripts."
msgstr "レベル 0。これはコンピュータの電源を切る際に一時的に使われるだけです。このため「K」スクリプトしか含まれません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Level 1, also known as single-user mode, corresponds to the system in degraded mode; it includes only basic services, and is intended for maintenance operations where interactions with ordinary users are not desired."
msgstr "レベル 1。これはシングルユーザモードとしても知られ、システムの機能抑制モードに相当します。このモードは基本的なサービスだけを提供し、一般ユーザがマシンを利用していないメンテナンスの際に使われることを意図しています"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Level 2 is the level for normal operation, which includes networking services, a graphical interface, user logins, etc."
msgstr "レベル 2。これは通常動作用のモードで、ネットワークサービス、グラフィカルインターフェース、ユーザログインなどの機能を使うことが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Level 6 is similar to level 0, except that it is used during the shutdown phase that precedes a reboot."
msgstr "レベル 6。これはレベル 0 と似ていますが、再起動前のシャットダウン段階中に使われる点が異なります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Other levels exist, especially 3 to 5. By default they are configured to operate the same way as level 2, but the administrator can modify them (by adding or deleting scripts in the corresponding <filename>/etc/rc<replaceable>X</replaceable>.d</filename> directories) to adapt them to particular needs."
msgstr "その他のレベル。レベル 3 からレベル 5 までも存在します。デフォルトでこれらのランレベルはレベル 2 と同様に動作しますが、管理者はこれらのレベルを特定の要求に順応させるためのレベルに書き換えることが可能です (ランレベルに対応する <filename>/etc/rc<replaceable>X</replaceable>.d</filename> ディレクトリにスクリプトを追加したりおよび削除したりする必要があります)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Boot sequence of a computer running Linux with System V init"
msgstr "System V init を使う Linux の動くコンピュータの起動シーケンス"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>initialization script</primary>"
msgstr "<primary>初期化スクリプト</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: PTAL;
# Ref: $ man 8 update-rc.d;
msgid "All the scripts contained in the various <filename>/etc/rc<replaceable>X</replaceable>.d</filename> directories are really only symbolic links — created upon package installation by the <command>update-rc.d</command> program — pointing to the actual scripts which are stored in <filename>/etc/init.d/</filename>. The administrator can fine tune the services available in each runlevel by re-running <command>update-rc.d</command> with adjusted parameters. The <citerefentry><refentrytitle>update-rc.d</refentrytitle><manvolnum>1</manvolnum></citerefentry> manual page describes the syntax in detail. Please note that removing all symbolic links (with the <literal>remove</literal> parameter) is not a good method to disable a service. Instead you should simply configure it to not start in the desired runlevel (while preserving the corresponding calls to stop it in the event that the service runs in the previous runlevel). Since <command>update-rc.d</command> has a somewhat convoluted interface, you may prefer using <command>rcconf</command> (from the <emphasis role=\"pkg\">rcconf</emphasis> package) which provides a more user-friendly interface."
msgstr "各 <filename>/etc/rc<replaceable>X</replaceable>.d</filename> ディレクトリに含まれるすべてのスクリプトは <filename>/etc/init.d/</filename> に格納されたスクリプトの実体を指すシンボリックリンクに過ぎません (シンボリックリンクはパッケージのインストール時に <command>update-rc.d</command> プログラムによって作られます)。各ランレベルで利用できるサービスを微調整するには、管理者が調整パラメータを与えて <command>update-rc.d</command> を再実行する必要があります。<command>update-rc.d</command> の構文は <citerefentry><refentrytitle>update-rc.d</refentrytitle><manvolnum>1</manvolnum></citerefentry> マニュアルページに詳しく説明されています。サービスを無効化したい場合に (<literal>remove</literal> パラメータを与えて) すべてのシンボリックリンクを削除するのは悪い方法であるという点に注意してください。<literal>remove</literal> パラメータを使う代わりに、単純に希望するランレベルでそのサービスを起動しないよう <literal>disable</literal> を使って設定するべきです (同時に、万が一切り替え前のランレベルで対象のサービスが実行されている場合に備えて、切り替え後のランレベルでサービスを停止するために必要なシンボリックリンクを確保しておくべきです)。<command>update-rc.d</command> は複雑なインターフェースを持っているため、<command>rcconf</command> (<emphasis role=\"pkg\">rcconf</emphasis> パッケージに含まれます) を使いたいと思うかもしれません。<command>rcconf</command> はユーザにとってさらに使い勝手の良いインターフェースを提供します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>update-rc.d</command></primary>"
msgstr "<primary><command>update-rc.d</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>DEBIAN POLICY</emphasis> Restarting services"
msgstr "<emphasis>DEBIAN POLICY</emphasis> サービスの再起動"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>invoke-rc.d</command></primary>"
msgstr "<primary><command>invoke-rc.d</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>service</primary><secondary>restart</secondary>"
msgstr "<primary>サービス</primary><secondary>再起動</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>restarting services</primary>"
msgstr "<primary>サービスの再起動</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The maintainer scripts for Debian packages will sometimes restart certain services to ensure their availability or get them to take certain options into account. The command that controls a service — <command>service <replaceable>service</replaceable> <replaceable>operation</replaceable></command> — doesn't take runlevel into consideration, assumes (wrongly) that the service is currently being used, and may thus initiate incorrect operations (starting a service that was deliberately stopped, or stopping a service that is already stopped, etc.). Debian therefore introduced the <command>invoke-rc.d</command> program: this program must be used by maintainer scripts to run services initialization scripts and it will only execute the necessary commands. Note that, contrary to common usage, the <filename>.d</filename> suffix is used here in a program name, and not in a directory."
msgstr "Debian パッケージのメンテナスクリプトはサービスを確実に利用できるようにしたりサービスに特定のオプションを考慮させるためにそのサービスを再起動することがあります。サービスを操作するコマンドである <command>service <replaceable>service</replaceable> <replaceable>operation</replaceable></command> はランレベルを考慮しません。このコマンドはサービスが現在使用中であると (間違って) 仮定し、間違った操作 (故意に停止されたサービスの開始や既に停止されたサービスの停止など) を開始するかもしれません。このため Debian は <command>invoke-rc.d</command> プログラムを導入しました。すなわち、メンテナスクリプト内でサービス初期化スクリプトを実行する場合は、必ず <command>invoke-rc.d</command> プログラムを使わなければいけません。<command>invoke-rc.d</command> プログラムは必要なコマンドだけを実行します。通常の使い方と異なり、ディレクトリではなくプログラム名に <filename>.d</filename> サフィックスが使われている点に注意してください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Finally, <command>init</command> starts control programs for various virtual consoles (<command>getty</command>). It displays a prompt, waiting for a username, then executes <command>login <replaceable>user</replaceable></command> to initiate a session."
msgstr "最後に、<command>init</command> はさまざまな仮想コンソール用の制御プログラム (<command>getty</command>) を開始します。<command>getty</command> はプロンプトを表示し、ユーザ名の入力を待ち、セッションを開始するために <command>login <replaceable>user</replaceable></command> を実行します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>getty</command></primary>"
msgstr "<primary><command>getty</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>VOCABULARY</emphasis> Console and terminal"
msgstr "<emphasis>VOCABULARY</emphasis> コンソールと端末"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The first computers were usually separated into several, very large parts: the storage enclosure and the central processing unit were separate from the peripheral devices used by the operators to control them. These were part of a separate furniture, the “console”. This term was retained, but its meaning has changed. It has become more or less synonymous with “terminal”, being a keyboard and a screen."
msgstr "草創期のコンピュータは通常複数のとても大きな部品に分かれていました。すなわち、ストレージ収納装置と中央処理装置はそれらを操作するオペレータが使う周辺装置から離れた場所にありました。オペレータが使う周辺装置は分離された周辺装置「コンソール」の部分でした。現在「コンソール」という用語は意味を変えて残されています。「コンソール」はキーボードと画面を備える「端末」とほぼ同義語になっています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "With the development of computers, operating systems have offered several virtual consoles to allow for several independent sessions at the same time, even if there is only one keyboard and screen. Most GNU/Linux systems offer six virtual consoles (in text mode), accessible by typing the key combinations <keycombo action=\"simul\"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F1</keycap> </keycombo> through <keycombo action=\"simul\"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F6</keycap> </keycombo>."
msgstr "コンピュータの開発とともに、オペレーティングシステムは、たとえもしマシンに 1 台のキーボードと画面しか接続されていなかったとしても、複数の独立したセッションを同時に処理する目的で複数の仮想コンソールを提供するようになりました。多くの GNU/Linux システムでは (テキストモード時に)、<keycombo action=\"simul\"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F1</keycap> </keycombo> から <keycombo action=\"simul\"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F6</keycap> </keycombo> までのキーの組み合わせを入力することで 6 つの仮想コンソールを切り替えられます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "By extension, the terms “console” and “terminal” can also refer to a terminal emulator in a graphical X11 session (such as <command>xterm</command>, <command>gnome-terminal</command> or <command>konsole</command>)."
msgstr "転じて、「コンソール」と「端末」という用語はグラフィカル X11 セッションで使われる端末エミュレータ (<command>xterm</command>、<command>gnome-terminal</command>、<command>konsole</command> など) でも使われています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Remote Login"
msgstr "リモートログイン"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "It is essential for an administrator to be able to connect to a computer remotely. Servers, confined in their own room, are rarely equipped with permanent keyboards and monitors — but they are connected to the network."
msgstr "管理者にとってコンピュータにリモートから接続できることは不可欠な要素です。専用の部屋に閉じ込められているサーバにキーボードとモニタが常設されていることはめったにありません。しかしサーバはネットワークにつながっています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> Client, server"
msgstr "<emphasis>BACK TO BASICS</emphasis> クライアント、サーバ"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>client</primary><secondary>client/server architecture</secondary>"
msgstr "<primary>クライアント</primary><secondary>クライアント/サーバアーキテクチャ</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>server</primary><secondary>client/server architecture</secondary>"
msgstr "<primary>サーバ</primary><secondary>クライアント/サーバアーキテクチャ</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "A system where several processes communicate with each other is often described with the “client/server” metaphor. The server is the program that takes requests coming from a client and executes them. It is the client that controls operations, the server doesn't take any initiative of its own."
msgstr "複数のプロセスが互いに通信しているシステムはよく「クライアント/サーバ」に例えられます。サーバはクライアントからの要求に応じて、その要求を実行するプログラムです。操作を制御するのがクライアントで、サーバは制御の主導権を握りません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>login</primary><secondary>remote login</secondary>"
msgstr "<primary>ログイン</primary><secondary>リモートログイン</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>remote login</primary>"
msgstr "<primary>リモートログイン</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Secure Remote Login: SSH"
msgstr "安全なリモートログイン、SSH"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>SSH</primary>"
msgstr "<primary>SSH</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Secure Shell</primary>"
msgstr "<primary>Secure Shell</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <emphasis>SSH</emphasis> (Secure SHell) protocol was designed with security and reliability in mind. Connections using SSH are secure: the partner is authenticated and all data exchanges are encrypted."
msgstr "<emphasis>SSH</emphasis> (Secure SHell) プロトコルは安全性と信頼性を念頭に置いて設計されました。SSH を使う接続は安全です。つまり、通信相手は認証され、交換されるデータはすべて暗号化されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>CULTURE</emphasis> Telnet and RSH are obsolete"
msgstr "<emphasis>CULTURE</emphasis> Telnet と RSH は時代遅れです"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>telnet</command></primary>"
msgstr "<primary><command>telnet</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>rsh</command></primary>"
msgstr "<primary><command>rsh</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Before SSH, <emphasis>Telnet</emphasis> and <emphasis>RSH</emphasis> were the main tools used to login remotely. They are now largely obsolete and should no longer be used even if Debian still provides them."
msgstr "SSH 以前、<emphasis>Telnet</emphasis> と <emphasis>RSH</emphasis> がリモートからログインするために使われる主なツールでした。両者は今や大幅に時代遅れです。両者がまだ Debian から配布されているとしても、もはやそれを使うべきではありません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>VOCABULARY</emphasis> Authentication, encryption"
msgstr "<emphasis>VOCABULARY</emphasis> 認証、暗号化"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "When you need to give a client the ability to conduct or trigger actions on a server, security is important. You must ensure the identity of the client; this is authentication. This identity usually consists of a password that must be kept secret, or any other client could get the password. This is the purpose of encryption, which is a form of encoding that allows two systems to communicate confidential information on a public channel while protecting it from being readable to others."
msgstr "クライアントに対してサーバ上で作業を実行したり作業を自動的に開始したりすることを許可する必要がある場合、安全性が重要です。クライアントは必ず本人であることを確認されなければいけません。これが認証です。通常、本人確認はパスワードを使って行います。パスワードは人目に触れさせてはいけません。そうでなければ、他のクライアントがパスワードを取得できてしまうからです。これが暗号化の目的です。暗号化は符号化の形をしています。暗号化することで、2 つのシステムが公衆回線を使って秘密の情報を他人に読まれないように保護した状態でやり取りすることが可能になります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Authentication and encryption are often mentioned together, both because they are frequently used together, and because they are usually implemented with similar mathematical concepts."
msgstr "認証と暗号化はしばしば一緒に言及されます。なぜなら両者は同時に使われることが多く、よく似た数学的概念を基に実行されることが多いからです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "SSH also offers two file transfer services. <command>scp</command> is a command line tool that can be used like <command>cp</command>, except that any path to another machine is prefixed with the machine's name, followed by a colon."
msgstr "さらに SSH は 2 種類のファイル転送サービスを提供します。<command>scp</command> は <command>cp</command> のように使えるコマンドラインツールです。ただし、他のマシンへのパスを表記するにはパスの前にそのマシンの名前とコロンを付ける点が <command>cp</command> と異なります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<computeroutput>$ </computeroutput><userinput>scp file machine:/tmp/</userinput>"
msgstr "<computeroutput>$ </computeroutput><userinput>scp file machine:/tmp/</userinput>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<command>sftp</command> is an interactive command, similar to <command>ftp</command>. In a single session, <command>sftp</command> can transfer several files, and it is possible to manipulate remote files with it (delete, rename, change permissions, etc.)."
msgstr "<command>sftp</command> は対話型コマンドで <command>ftp</command> に似ています。<command>sftp</command> は単一のセッションの中で複数のファイルを転送したり、リモートのファイルを操作 (削除、リネーム、パーミッション変更など) したりすることが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>scp</command></primary>"
msgstr "<primary><command>scp</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>sftp</command></primary>"
msgstr "<primary><command>sftp</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Debian uses OpenSSH, a free version of SSH maintained by the <command>OpenBSD</command> project (a free operating system based on the BSD kernel, focused on security) and fork of the original SSH software developed by the SSH Communications Security Corp company, of Finland. This company initially developed SSH as free software, but eventually decided to continue its development under a proprietary license. The OpenBSD project then created OpenSSH to maintain a free version of SSH."
msgstr "Debian は OpenSSH を使います。OpenSSH は SSH のフリー版で <command>OpenBSD</command> (BSD カーネルに基づき、安全性を重要視するフリーなオペレーティングシステム) プロジェクトによってメンテナンスされており、フィンランドの SSH Communications Security Corp が開発した元祖 SSH ソフトウェアのフォークです。SSH Communications Security Corp は当初 SSH をフリーソフトウェアとして開発していましたが、結局プロプライエタリライセンスで開発を続けることを決定しました。そして OpenBSD プロジェクトが SSH のフリー版としてメンテナンスするために OpenSSH を作成しました。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>OpenSSH</primary>"
msgstr "<primary>OpenSSH</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> <foreignphrase>Fork</foreignphrase>"
msgstr "<emphasis>BACK TO BASICS</emphasis> <foreignphrase>フォーク</foreignphrase>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>fork</primary>"
msgstr "<primary>フォーク</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "A “fork”, in the software field, means a new project that starts as a clone of an existing project, and that will compete with it. From there on, both software will usually quickly diverge in terms of new developments. A fork is often the result of disagreements within the development team."
msgstr "ソフトウェアの分野で「フォーク」とは、既存のプロジェクトのクローンとして始まった新しいプロジェクトを意味しており、既存のプロジェクトの対抗馬です。通常、両方のソフトウェアは新しい開発という観点ですぐに別のものになっていきます。フォークは開発チーム内の意見の不一致によって起こることが多いです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The option to fork a project is a direct result of the very nature of free software; a fork is a healthy event when it enables the continuation of a project as free software (for example in case of license changes). A fork arising from technical or personal disagreements is often a waste of human resources; another resolution would be preferable. Mergers of two projects that previously went through a prior fork are not unheard of."
msgstr "プロジェクトをフォークするという選択肢はフリーソフトウェアの本質そのものから生じた直接的な結果です。フリーソフトウェアとしてのプロジェクトの存続を可能にするための (たとえばライセンスが変更された場合などの) フォークは健全な出来事です。技術的および個人的な意見の不一致によって起こるフォークは通常人的資源の無駄です。従って別の解決策が望まれます。過去にフォークした 2 つのプロジェクトの合併はいまだ前例がありません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "OpenSSH is split into two packages: the client part is in the <emphasis role=\"pkg\">openssh-client</emphasis> package, and the server is in the <emphasis role=\"pkg\">openssh-server</emphasis> package. The <emphasis role=\"pkg\">ssh</emphasis> meta-package depends on both parts and facilitates installation of both (<command>apt install ssh</command>)."
msgstr "OpenSSH は 2 つのパッケージに分割されています。すなわち、クライアント部分は <emphasis role=\"pkg\">openssh-client</emphasis> パッケージ、サーバ部分は <emphasis role=\"pkg\">openssh-server</emphasis> パッケージに分割されています。<emphasis role=\"pkg\">ssh</emphasis> メタパッケージは両方のパッケージに依存しており、これを使えば両方のインストールが簡単になります (<command>apt install ssh</command> だけでクライアントとサーバの両方がインストールされます)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Key-Based Authentication"
msgstr "鍵認証方式"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Each time someone logs in over SSH, the remote server asks for a password to authenticate the user. This can be problematic if you want to automate a connection, or if you use a tool that requires frequent connections over SSH. This is why SSH offers a key-based authentication system."
msgstr "リモートサーバはユーザを認証するために SSH でログインする人に対して毎回パスワードを尋ねます。これは、接続を自動化したい場合や SSH 経由で頻繁に接続を行うツールを使う場合に問題です。このため、SSH は鍵認証システムを提供しています。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: PTAL;
# Ref: $ man 1 ssh-agent;
msgid "The user generates a key pair on the client machine with <command>ssh-keygen -t rsa</command>; the public key is stored in <filename>~/.ssh/id_rsa.pub</filename>, while the corresponding private key is stored in <filename>~/.ssh/id_rsa</filename>. The user then uses <command>ssh-copy-id <replaceable>server</replaceable></command> to add their public key to the <filename>~/.ssh/authorized_keys</filename> file on the server. If the private key was not protected with a “passphrase” at the time of its creation, all subsequent logins on the server will work without a password. Otherwise, the private key must be decrypted each time by entering the passphrase. Fortunately, <command>ssh-agent</command> allows us to keep private keys in memory to not have to regularly re-enter the password. For this, you simply use <command>ssh-add</command> (once per work session) provided that the session is already associated with a functional instance of <command>ssh-agent</command>. Debian activates it by default in graphical sessions, but this can be deactivated by changing <filename>/etc/X11/Xsession.options</filename>. For a console session, you can manually start it with <command>eval $(ssh-agent)</command>."
msgstr "ユーザはクライアントマシンで <command>ssh-keygen -t rsa</command> を使って鍵ペアを生成します。この時公開鍵は <filename>~/.ssh/id_rsa.pub</filename> に保存され、一方で公開鍵に対応する秘密鍵は <filename>~/.ssh/id_rsa</filename> に保存されます。その後ユーザは <command>ssh-copy-id <replaceable>server</replaceable></command> を使って、自分の公開鍵をサーバの <filename>~/.ssh/authorized_keys</filename> ファイルに追加登録します。秘密鍵を生成した際に「パスフレーズ」で保護しなかった場合、公開鍵を登録したサーバに対する以降すべてのログインでパスワードは不要です。そうでなければ、秘密鍵を使う際は毎回パスフレーズを入力して秘密鍵を復号化しなければいけません。幸いにも、<command>ssh-agent</command> を使えば復号化された秘密鍵がメモリ内に保存され、パスワードをきちんと再入力する必要がなくなります。これを実現するには、セッションが既に機能する <command>ssh-agent</command> のインスタンスに関連付けられている条件下で、単純に (作業セッションごとに 1 回) <command>ssh-add</command> を使ってください。Debian はグラフィカルセッションではデフォルトで <command>ssh-agent</command> を有効化しますが、<filename>/etc/X11/Xsession.options</filename> を変更すれば無効化することも可能です。コンソールセッションでは手作業で <command>eval $(ssh-agent)</command> を実行することで <command>ssh-agent</command> を開始できます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>SECURITY</emphasis> Protection of the private key"
msgstr "<emphasis>SECURITY</emphasis> 秘密鍵の保護"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Whoever has the private key can login on the account thus configured. This is why access to the private key is protected by a “passphrase”. Someone who acquires a copy of a private key file (for example, <filename>~/.ssh/id_rsa</filename>) still has to know this phrase in order to be able to use it. This additional protection is not, however, impregnable, and if you think that this file has been compromised, it is best to disable that key on the computers in which it has been installed (by removing it from the <filename>authorized_keys</filename> files) and replacing it with a newly generated key."
msgstr "秘密鍵を持っていれば、誰でも対応する公開鍵を登録したアカウントにログインすることが可能です。このため、秘密鍵の利用は「パスフレーズ」で保護されています。秘密鍵ファイル (たとえば <filename>~/.ssh/id_rsa</filename>) のコピーを不正に入手した人が秘密鍵を使うためには、パスフレーズを知らなければいけません。しかしながら、「パスフレーズ」による追加的な保護は堅固なものではありません。秘密鍵ファイルが不正に使われていると感じたなら、その秘密鍵に対応する公開鍵をインストールしたコンピュータでその公開鍵の使用を停止し (<filename>authorized_keys</filename> ファイルから公開鍵を削除し)、新しく生成した鍵で公開鍵を置き換えるのが最良の対応策です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>CULTURE</emphasis> OpenSSL flaw in Debian <emphasis role=\"distribution\">Etch</emphasis>"
msgstr "<emphasis>CULTURE</emphasis> Debian <emphasis role=\"distribution\">Etch</emphasis> における OpenSSL の脆弱性"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The OpenSSL library, as initially provided in Debian <emphasis role=\"distribution\">Etch</emphasis>, had a serious problem in its random number generator (RNG). Indeed, the Debian maintainer had made a change so that applications using it would no longer generate warnings when analyzed by memory testing tools like <command>valgrind</command>. Unfortunately, this change also meant that the RNG was employing only one source of entropy corresponding to the process number (PID) whose 32,000 possible values do not offer enough randomness. <ulink type=\"block\" url=\"http://www.debian.org/security/2008/dsa-1571\" />"
msgstr "当初 Debian <emphasis role=\"distribution\">Etch</emphasis> から配布されていた OpenSSL ライブラリは乱数発生器 (RNG) に深刻な問題がありました。はっきり言うと、Debian メンテナによって <command>valgrind</command> などのメモリテストツールで OpenSSL ライブラリを使うアプリケーションを解析した際に警告を出さなくなるような変更が行われました。不幸なことに、この変更により RNG はエントロピーソースを 1 つしか使わなくなりました。ここで使われたエントロピーソースはプロセス ID (PID) に相当するもので、PID の取りうる値は 32,000 程度しかないため PID をソースとして用いたことにより十分な乱数度が得られなくなりました。<ulink type=\"block\" url=\"http://www.debian.org/security/2008/dsa-1571\" />"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Specifically, whenever OpenSSL was used to generate a key, it always produced a key within a known set of hundreds of thousands of keys (32,000 multiplied by a small number of key lengths). This affected SSH keys, SSL keys, and X.509 certificates used by numerous applications, such as OpenVPN. A cracker had only to try all of the keys to gain unauthorized access. To reduce the impact of the problem, the SSH daemon was modified to refuse problematic keys that are listed in the <emphasis role=\"pkg\">openssh-blacklist</emphasis> and <emphasis role=\"pkg\">openssh-blacklist-extra</emphasis> packages. Additionally, the <command>ssh-vulnkey</command> command allows identification of possibly compromised keys in the system."
msgstr "具体的に言えば、OpenSSL を使って鍵を生成した場合、生成された鍵は常に数十万 (鍵長種数の 32,000 倍) の既知の範囲内にある鍵のうちの 1 つになります。この脆弱性は、たとえば OpenVPN など数多くのアプリケーションが使う SSH 鍵、SSL 鍵、X.509 証明書に影響をおよぼしました。クラッカーは全種類の鍵を試すだけで不正アクセスを実行することが可能でした。この問題の影響を減らす目的で、SSH デーモンは <emphasis role=\"pkg\">openssh-blacklist</emphasis> と <emphasis role=\"pkg\">openssh-blacklist-extra</emphasis> パッケージにリストされている問題のある鍵を拒否するように変更されました。さらに、<command>ssh-vulnkey</command> コマンドを使えば、システム内からこの脆弱性の影響を受けているかもしれない鍵を識別することが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "A more thorough analysis of this incident brings to light that it is the result of multiple (small) problems, both within the OpenSSL project and with the Debian package maintainer. A widely used library like OpenSSL should — without modifications — not generate warnings when tested by <command>valgrind</command>. Furthermore, the code (especially the parts as sensitive as the RNG) should be better commented to prevent such errors. On Debian's side, the maintainer wanted to validate the modifications with the OpenSSL developers, but simply explained the modifications without providing the corresponding patch to review and failed to mention his role within Debian. Finally, the maintenance choices were sub-optimal: the changes made to the original code were not clearly documented; all the modifications were effectively stored in a Subversion repository, but they ended up all lumped into one single patch during creation of the source package."
msgstr "この出来事をいっそう詳しく調べると、これは OpenSSL プロジェクト内と Debian パッケージメンテナ双方にあった多数の (小さな) 問題の結果であるということが、明らかになります。OpenSSL のように広く使われるライブラリは (修正せずとも) <command>valgrind</command> でテストした時に警告を出すべきではありません。さらに、コード (特に RNG と同様に慎重に取り扱われるべき部分) はこのような誤解を避ける目的で詳しい注釈を付けられるべきです。Debian 側について言えば、メンテナは OpenSSL 開発者から修正に対する検証を受けることを望んでいながら、修正の検証に必要なパッチを OpenSSL 開発者に提供することもせずに自分の修正について簡単に説明しただけで、Debian 内における自分の役割を口にすることもしませんでした。そして最後に、メンテナンス方針が最適なものではありませんでした。具体的に言えば、元のコードに対して行った修正が文書中で明らかにされず、さらにすべての修正は Subversion リポジトリに効果的に保存されていましたが、最終的にすべての修正はソースパッケージの作成中に 1 つのパッチにまとめられていました。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "It is difficult under such conditions to find the corrective measures to prevent such incidents from recurring. The lesson to be learned here is that every divergence Debian introduces to upstream software must be justified, documented, submitted to the upstream project when possible, and widely publicized. It is from this perspective that the new source package format (“3.0 (quilt)”) and the Debian sources webservice were developed. <ulink type=\"block\" url=\"http://sources.debian.net\" />"
msgstr "このような状況下では、これと同様の出来事が繰り返されることを避けるための適切な矯正措置を見つけるのは難しいです。ここで覚えておくべき教訓は Debian が上流開発ソフトウェアに対して導入したすべての変更は正当化され、文書化され、可能であれば上流プロジェクトに提出され、広く公開されなければいけないということです。この視点から、新しいソースパッケージフォーマット (「3.0 (quilt)」) と Debian ソースウェブサービスが開発されました。<ulink type=\"block\" url=\"http://sources.debian.net\" />"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Using Remote X11 Applications"
msgstr "リモートの X11 アプリケーションを使う"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The SSH protocol allows forwarding of graphical data (“X11” session, from the name of the most widespread graphical system in Unix); the server then keeps a dedicated channel for those data. Specifically, a graphical program executed remotely can be displayed on the X.org server of the local screen, and the whole session (input and display) will be secure. Since this feature allows remote applications to interfere with the local system, it is disabled by default. You can enable it by specifying <literal>X11Forwarding yes</literal> in the server configuration file (<filename>/etc/ssh/sshd_config</filename>). Finally, the user must also request it by adding the <literal>-X</literal> option to the <command>ssh</command> command-line."
msgstr "SSH プロトコルを使うと、グラフィカルデータ (「X11」セッション、Unix で最も広く使われているグラフィカルシステム) を転送することが可能です。サーバはこれらのデータ専用の経路を開いたままにします。具体的に言うと、リモートで実行されたグラフィカルプログラムはローカル画面の X.org サーバ上に表示され、すべてのセッション (入力と表示) は保護されます。X11 転送機能によりリモートアプリケーションがローカルシステムに干渉することになるため、X11 転送機能はデフォルトで無効化されています。X11 転送機能を有効化するには、SSH サーバの設定ファイル (<filename>/etc/ssh/sshd_config</filename>) で <literal>X11Forwarding yes</literal> と指定してください。さらにユーザは <command>ssh</command> コマンドラインに <literal>-X</literal> オプションを追加して転送を要求しなければいけません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Creating Encrypted Tunnels with Port Forwarding"
msgstr "ポート転送を使った暗号化トンネルの作成"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>port forwarding</primary>"
msgstr "<primary>ポート転送</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Its <literal>-R</literal> and <literal>-L</literal> options allow <command>ssh</command> to create “encrypted tunnels” between two machines, securely forwarding a local TCP port (see sidebar <xref linkend=\"sidebar.tcp-udp\" />) to a remote machine or vice versa."
msgstr "<command>ssh</command> の <literal>-R</literal> と <literal>-L</literal> オプションを使うと、<command>ssh</command> が 2 台のマシン間で「暗号化トンネル」を作成することが可能です。「暗号化トンネル」を使えば、ローカル TCP ポート (補注<xref linkend=\"sidebar.tcp-udp\" />を参照してください) をリモートのマシンに安全に転送したりその逆を行うことも可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>VOCABULARY</emphasis> Tunnel"
msgstr "<emphasis>VOCABULARY</emphasis> トンネル"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>tunnel (SSH)</primary><seealso>VPN</seealso>"
msgstr "<primary>トンネル (SSH)</primary><seealso>VPN</seealso>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgstr "<primary>SSH トンネル</primary><seealso>VPN</seealso>"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: PTAL;
msgid "The Internet, and most LANs that are connected to it, operate in packet mode and not in connected mode, meaning that a packet issued from one computer to another is going to be stopped at several intermediary routers to find its way to its destination. You can still simulate a connected operation where the stream is encapsulated in normal IP packets. These packets follow their usual route, but the stream is reconstructed unchanged at the destination. We call this a “tunnel”, analogous to a road tunnel in which vehicles drive directly from the entrance (input) to the exit (output) without encountering any intersections, as opposed to a path on the surface that would involve intersections and changing direction."
msgstr "インターネットとインターネットに接続されているほとんどの LAN はパケットモードで動作しており、接続モードで動作していません。これは、一方のコンピュータから他方のコンピュータに向かって送信されたパケットは、宛先への経路を見つけるために複数の中間ルータで足止めされることを意味しています。とは言っても、接続モードを模倣することも可能です。接続モードではストリームを普通の IP パケットの中にカプセル化します。これらのパケットは通常の経路を通過しますが、ストリームは宛先を変えられることなく再構成されます。これは道路のトンネルにかけて「トンネル」と呼ばれています。道路のトンネルでは車両が入口 (入力) から出口 (出力) まで交差点に遭遇することなくまっすぐ進むのに対し、地上の経路を使うと車両は交差点を通過したり右折左折を繰り返しながら目的地まで進むことになります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "You can use this opportunity to add encryption to the tunnel: the stream that flows through it is then unrecognizable from the outside, but it is returned in decrypted form at the exit of the tunnel."
msgstr "トンネルに暗号化機能を追加することが可能です。すなわち、トンネルの中を流れるストリームは外から認識できませんが、トンネルの出口で復号化された形で返されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: man 1 ssh;
msgid "<command>ssh -L 8000:server:25 intermediary</command> establishes an SSH session with the <replaceable>intermediary</replaceable> host and listens to local port 8000 (see <xref linkend=\"figure.ssh-L\" />). For any connection established on this port, <command>ssh</command> will initiate a connection from the <replaceable>intermediary</replaceable> computer to port 25 on the <replaceable>server</replaceable>, and will bind both connections together."
msgstr "<command>ssh -L 8000:server:25 intermediary</command> を使うことで、ローカルの <command>ssh</command> に <replaceable>intermediary</replaceable> との SSH セッションを確立させ、ローカルの <command>ssh</command> にローカルのポート 8000 番をリッスンさせます (<xref linkend=\"figure.ssh-L\" />を参照してください)。ローカルのポート 8000 番を経由して接続が開始されたら、<replaceable>intermediary</replaceable> の <command>ssh</command> は <replaceable>intermediary</replaceable> から <replaceable>server</replaceable> のポート 25 番に接続し、ローカルから <replaceable>server</replaceable> への接続を中継します。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: man 1 ssh;
msgid "<command>ssh -R 8000:server:25 intermediary</command> also establishes an SSH session to the <replaceable>intermediary</replaceable> computer, but it is on this machine that <command>ssh</command> listens to port 8000 (see <xref linkend=\"figure.ssh-R\" />). Any connection established on this port will cause <command>ssh</command> to open a connection from the local machine on to port 25 of the <replaceable>server</replaceable>, and to bind both connections together."
msgstr "<command>ssh -R 8000:server:25 intermediary</command> を使うことで、ローカルの <command>ssh</command> に <replaceable>intermediary</replaceable> との SSH セッションを確立させ、<replaceable>intermediary</replaceable> の <command>ssh</command> に <replaceable>intermediary</replaceable> のポート 8000 番をリッスンさせます (<xref linkend=\"figure.ssh-R\" />を参照してください)。<replaceable>intermediary</replaceable> のポート 8000 番を経由して接続が開始されたら、ローカルの <command>ssh</command> はローカルから <replaceable>server</replaceable> のポート 25 番に接続し、<replaceable>intermediary</replaceable> から <replaceable>server</replaceable> への接続を中継します。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: PTAL;
msgid "In both cases, connections are made to port 25 on the <replaceable>server</replaceable> host, which pass through the SSH tunnel established between the local machine and the <replaceable>intermediary</replaceable> machine. In the first case, the entrance to the tunnel is local port 8000, and the data move towards the <replaceable>intermediary</replaceable> machine before being directed to the <replaceable>server</replaceable> on the “public” network. In the second case, the input and output in the tunnel are reversed; the entrance is port 8000 on the <replaceable>intermediary</replaceable> machine, the output is on the local host, and the data are then directed to the <replaceable>server</replaceable>. In practice, the server is usually either the local machine or the intermediary. That way SSH secures the connection from one end to the other."
msgstr "どちらの場合も、ローカルと <replaceable>intermediary</replaceable> の間に確立した SSH トンネルを介して、<replaceable>server</replaceable> のポート 25 番に接続します。最初の例の場合、トンネルの入口はローカルのポート 8000 番で、データはまず <replaceable>intermediary</replaceable> を目指し、その後に「公開」ネットワークを経由して <replaceable>server</replaceable> に向かいます。2 番目の例の場合、トンネルの入口と出口が逆になります。トンネルの入口は <replaceable>intermediary</replaceable> のポート 8000 番で、出口はローカルにあります。出口から出たデータは <replaceable>server</replaceable> に向かいます。現実的な話をすると、ここで使われている <replaceable>server</replaceable> にはローカルまたは <replaceable>intermediary</replaceable> を指定することが多いです。このようにして SSH は端から端までの接続を保護します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Forwarding a local port with SSH"
msgstr "SSH を使ったローカルポートの転送"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Forwarding a remote port with SSH"
msgstr "SSH を使ったリモートポートの転送"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Using Remote Graphical Desktops"
msgstr "リモートグラフィカルデスクトップの利用"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "VNC (Virtual Network Computing) allows remote access to graphical desktops."
msgstr "VNC (Virtual Network Computing) を使うとグラフィカルデスクトップにリモートからアクセスすることが可能になります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>VNC</primary>"
msgstr "<primary>VNC</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Virtual Network Computing</primary>"
msgstr "<primary>Virtual Network Computing</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>graphical desktop</primary><secondary>remote</secondary>"
msgstr "<primary>グラフィカルデスクトップ</primary><secondary>リモート</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>remote graphical desktop</primary>"
msgstr "<primary>リモートグラフィカルデスクトップ</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>desktop, remote graphical desktop</primary>"
msgstr "<primary>デスクトップ、リモートグラフィカルデスクトップ</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "This tool is mostly used for technical assistance; the administrator can see the errors that the user is facing, and show them the correct course of action without having to stand by them."
msgstr "VNC は技術支援に使われることが多いです。なぜなら、管理者はユーザが直面しているエラーを見ることが可能で、ユーザの側にいなくても正しい行動の仕方をユーザに示すことが可能だからです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis role=\"pkg\">vino</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">vino</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis role=\"pkg\">krfb</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">krfb</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis role=\"pkg\">x11vnc</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">x11vnc</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "First, the user must authorize sharing their session. The GNOME graphical desktop environment in <emphasis role=\"distribution\">Jessie</emphasis> includes that option in its configuration panel (contrary to previous versions of Debian, where the user had to install and run <command>vino</command>). KDE still requires using <command>krfb</command> to allow sharing an existing session over VNC. For other graphical desktop environments, the <command>x11vnc</command> command (from the Debian package of the same name) serves the same purpose; you can make it available to the user with an explicit icon."
msgstr "リモートデスクトップを使うには、最初にユーザが自分のセッションを共有することを認可しなければいけません。<emphasis role=\"distribution\">Jessie</emphasis> に含まれる GNOME グラフィカルデスクトップ環境の場合、設定パネル内にこれを行うオプションが含まれています (以前の Debian のバージョンではユーザが <command>vino</command> をインストールして実行しなければいけませんでした)。KDE の場合、既存のセッションを VNC を介して共有するには <command>krfb</command> を使う必要があります。他のグラフィカルデスクトップ環境の場合、<command>x11vnc</command> コマンド (同名の Debian パッケージに含まれます) を使います。さらに、管理者はわかりやすいアイコンを作ってユーザが <command>x11vnc</command> を実行できるようにすることが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis role=\"pkg\">vinagre</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">vinagre</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis role=\"pkg\">tsclient</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">tsclient</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis role=\"pkg\">krdc</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">krdc</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis role=\"pkg\">xvnc4viewer</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">xvnc4viewer</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "When the graphical session is made available by VNC, the administrator must connect to it with a VNC client. GNOME has <command>vinagre</command> and <command>remmina</command> for that, while KDE includes <command>krdc</command> (in the menu at <menuchoice> <guimenu>K</guimenu> <guisubmenu>Internet</guisubmenu> <guimenuitem>Remote Desktop Client</guimenuitem></menuchoice>). There are other VNC clients that use the command line, such as <command>xvnc4viewer</command> in the Debian package of the same name. Once connected, the administrator can see what is going on, work on the machine remotely, and show the user how to proceed."
msgstr "VNC がグラフィカルセッションを利用できるようにしたら、管理者は VNC クライアントでセッションに接続しなければいけません。VNC クライアントとして、GNOME には <command>vinagre</command> と <command>remmina</command> が、KDE には <command>krdc</command> (<menuchoice> <guimenu>K</guimenu> <guisubmenu>インターネット</guisubmenu> <guimenuitem>リモートデスクトップクライアント</guimenuitem></menuchoice>) が用意されています。コマンドラインを使う他の VNC クライアントもあります。たとえば、<command>xvnc4viewer</command> (同名の Debian パッケージに含まれます) などです。ひとたびセッションに接続したら、管理者は何が起きているか確認し、リモートでマシンの作業を行い、ユーザにその様子を見せることが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>SECURITY</emphasis> VNC over SSH"
msgstr "<emphasis>SECURITY</emphasis> VNC over SSH"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>SSH tunnel</primary><secondary>VNC</secondary>"
msgstr "<primary>SSH トンネル</primary><secondary>VNC</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "If you want to connect by VNC, and you don't want your data sent in clear text on the network, it is possible to encapsulate the data in an SSH tunnel (see <xref linkend=\"sect.ssh-port-forwarding\" />). You simply have to know that VNC uses port 5900 by default for the first screen (called “localhost:0”), 5901 for the second (called “localhost:1”), etc."
msgstr "VNC で接続したいけれども、データを平文でネットワークに流したくない場合、SSH トンネルでデータをカプセル化することが可能です (<xref linkend=\"sect.ssh-port-forwarding\" />を参照してください)。この時知っておかなければいけない点は、デフォルトで VNC は最初の画面 (「localhost:0」と呼ばれます) にポート 5900 番、2 番目の画面 (「localhost:1」と呼ばれます) にポート 5901 番を使うという点だけです。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Raf: $ man 1 ssh;
msgid "The <command>ssh -L localhost:5901:localhost:5900 -N -T <replaceable>machine</replaceable></command> command creates a tunnel between local port 5901 in the localhost interface and port 5900 of the <replaceable>machine</replaceable> host. The first “localhost” restricts SSH to listening to only that interface on the local machine. The second “localhost” indicates the interface on the remote machine which will receive the network traffic entering in “localhost:5901”. Thus <command>vncviewer localhost:1</command> will connect the VNC client to the remote screen, even though you indicate the name of the local machine."
msgstr "<command>ssh -L localhost:5901:localhost:5900 -N -T <replaceable>machine</replaceable></command> コマンドを使うことで、localhost インターフェースのポート 5901 番と <replaceable>machine</replaceable> のポート 5900 番の間にトンネルが作られます。最初の「localhost」はローカルのインターフェースのみをリッスンするように SSH を制限します。2 番目の「localhost」は「localhost:5901」に入ってきたネットワークトラフィックを受け取るリモート側のインターフェースを表します。そんなわけで、<command>vncviewer localhost:1</command> はローカルの名前を使っているにも関わらず VNC クライアントをリモートの画面に接続します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "When the VNC session is closed, remember to close the tunnel by also quitting the corresponding SSH session."
msgstr "VNC セッションを閉じたら、対応する SSH セッションを終了してトンネルを閉じることも忘れないでください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> Display manager"
msgstr "<emphasis>BACK TO BASICS</emphasis> ディスプレイマネージャ"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>gdm3</command></primary>"
msgstr "<primary><command>gdm3</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>kdm</command></primary>"
msgstr "<primary><command>kdm</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>xdm</command></primary>"
msgstr "<primary><command>xdm</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>lightdm</command></primary>"
msgstr "<primary><command>lightdm</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>manager</primary><secondary>display manager</secondary>"
msgstr "<primary>マネージャ</primary><secondary>ディスプレイマネージャ</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>display manager</primary>"
msgstr "<primary>ディスプレイマネージャ</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<command>gdm3</command>, <command>kdm</command>, <command>lightdm</command>, and <command>xdm</command> are Display Managers. They take control of the graphical interface shortly after boot in order to provide the user a login screen. Once the user has logged in, they execute the programs needed to start a graphical work session."
msgstr "<command>gdm3</command>、<command>kdm</command>、<command>lightdm</command>、<command>xdm</command> はディスプレイマネージャです。ディスプレイマネージャは起動直後にログイン画面をユーザに提供する目的でグラフィカルインターフェースを制御します。ユーザがログインしたら、ディスプレイマネージャはグラフィカルの作業セッションを始めるために必要なプログラムを実行します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "VNC also works for mobile users, or company executives, who occasionally need to login from their home to access a remote desktop similar to the one they use at work. The configuration of such a service is more complicated: you first install the <emphasis role=\"pkg\">vnc4server</emphasis> package, change the configuration of the display manager to accept <literal>XDMCP Query</literal> requests (for <command>gdm3</command>, this can be done by adding <literal>Enable=true</literal> in the “xdmcp” section of <filename>/etc/gdm3/daemon.conf</filename>), and finally, start the VNC server with <command>inetd</command> so that a session is automatically started when a user tries to login. For example, you may add this line to <filename>/etc/inetd.conf</filename>:"
msgstr "また、モバイルユーザや会社幹部のような自分が仕事場で使っているのとよく似たリモートデスクトップにアクセスするために時々自宅からログインする必要があるユーザにとって、VNC は都合の良いものです。そのようなサービス用の設定はより複雑です。具体的に言えば、管理者は最初に <emphasis role=\"pkg\">vnc4server</emphasis> パッケージをインストールし、<literal>XDMCP Query</literal> 要求を受け入れるようにディスプレイマネージャの設定を変更し (<command>gdm3</command> の場合、<filename>/etc/gdm3/daemon.conf</filename> の「xdmcp」セクションに <literal>Enable=true</literal> を追加し)、そして最後に <command>inetd</command> を使って VNC サーバを起動するように設定します。こうすることで、ユーザがログインを試行したらセッションが自動的に開始されるようになります。たとえば、以下の行を <filename>/etc/inetd.conf</filename> に追加します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none"
msgstr "5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Redirecting incoming connections to the display manager solves the problem of authentication, because only users with local accounts will pass the <command>gdm3</command> login screen (or equivalent <command>kdm</command>, <command>xdm</command>, etc.). As this operation allows multiple simultaneous logins without any problem (provided the server is powerful enough), it can even be used to provide complete desktops for mobile users (or for less powerful desktop systems, configured as thin clients). Users simply login to the server's screen with <command>vncviewer <replaceable>server</replaceable>:50</command>, because the port used is 5950."
msgstr "入ってくる接続をディスプレイマネージャに転送することにより、認証の問題が解決されます。なぜなら、ローカルアカウントを持つユーザだけが <command>gdm3</command> (または同等の <command>kdm</command>、<command>xdm</command> など) のログイン画面を突破できるからです。このやり方は (サーバの性能が十分高いなら) なんの問題もなく複数の同時ログインを許すため、完全なデスクトップをモバイルユーザに対して (またはシンクライアントとして設定された非力なデスクトップシステムに対して) 提供するという用途にも応用できます。ユーザは単純に <command>vncviewer <replaceable>server</replaceable>:50</command> でサーバの画面にログインするだけです。なぜなら、使われているポートは 5950 番だからです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis role=\"pkg\">vnc4server</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">vnc4server</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Managing Rights"
msgstr "権限の管理"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Linux is definitely a multi-user system, so it is necessary to provide a permission system to control the set of authorized operations on files and directories, which includes all the system resources and devices (on a Unix system, any device is represented by a file or directory). This principle is common to all Unix systems, but a reminder is always useful, especially as there are some interesting and relatively unknown advanced uses."
msgstr "Linux は完全なマルチユーザシステムです。このため、ユーザの権限に基づいてファイルやディレクトリに対する操作を制御するためにパーミッションシステムを提供することが必要です。このパーミッションシステムはすべてのシステムリソースとデバイスに対して適用されます (Unix システムではすべてのデバイスはファイルまたはディレクトリとして表現されます)。この原理はすべての Unix システムで共通ですが、特に興味深く比較的知られていない上級の使い方があるので、注意は常に必要です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>rights</primary>"
msgstr "<primary>権限</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>permissions</primary>"
msgstr "<primary>パーミッション</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>user</primary><secondary>owner</secondary>"
msgstr "<primary>ユーザ</primary><secondary>所有者</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>group</primary><secondary>owner</secondary>"
msgstr "<primary>グループ</primary><secondary>所有者</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>owner</primary><secondary>user</secondary>"
msgstr "<primary>所有者</primary><secondary>ユーザ</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>owner</primary><secondary>group</secondary>"
msgstr "<primary>所有者</primary><secondary>グループ</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Each file or directory has specific permissions for three categories of users:"
msgstr "ファイルとディレクトリには 3 種類のユーザ別に特定のパーミッションが付けられます。以下に 3 種類のユーザを挙げます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "its owner (symbolized by <literal>u</literal> as in “user”);"
msgstr "所有者 (「user」の <literal>u</literal> で表記されます)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "its owner group (symbolized by <literal>g</literal> as in “group”), representing all the members of the group;"
msgstr "所有グループ (「group」の <literal>g</literal> で表記されます)。これはグループに所属する全ユーザを意味しています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "the others (symbolized by <literal>o</literal> as in “other”)."
msgstr "その他 (「other」の <literal>o</literal> で表記されます)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Three types of rights can be combined:"
msgstr "3 種類の権限は組み合わせて使うことが可能です。以下に 3 種類の権限を挙げます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "reading (symbolized by <literal>r</literal> as in “read”);"
msgstr "読み込み (「read」の <literal>r</literal> で表記されます)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "writing (or modifying, symbolized by <literal>w</literal> as in “write”);"
msgstr "書き込み (または変更。「write」の <literal>w</literal> で表記されます)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "executing (symbolized by <literal>x</literal> as in “eXecute”)."
msgstr "実行 (「eXecute」の <literal>x</literal> で表記されます)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>read, right</primary>"
msgstr "<primary>読み込み、権限</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>write, right</primary>"
msgstr "<primary>書き込み、権限</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>modification, right</primary>"
msgstr "<primary>変更、権限</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>execution, right</primary>"
msgstr "<primary>実行、権限</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "In the case of a file, these rights are easily understood: read access allows reading the content (including copying), write access allows changing it, and execute access allows you to run it (which will only work if it is a program)."
msgstr "ファイルの場合、これらの権限は簡単に理解できます。すなわち、読み込み権限があれば、内容を読むことが可能です (コピーも可能です)。書き込み権限があれば、内容を変更することが可能です。実行権限があれば、内容を実行することが可能です (実行権限に意味があるのは対象がプログラムの場合に限ります)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>SECURITY</emphasis> <literal>setuid</literal> and <literal>setgid</literal> executables"
msgstr "<emphasis>SECURITY</emphasis> <literal>setuid</literal> と <literal>setgid</literal> 実行ファイル"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Two particular rights are relevant to executable files: <literal>setuid</literal> and <literal>setgid</literal> (symbolized with the letter “s”). Note that we frequently speak of “bit”, since each of these boolean values can be represented by a 0 or a 1. These two rights allow any user to execute the program with the rights of the owner or the group, respectively. This mechanism grants access to features requiring higher level permissions than those you would usually have."
msgstr "<literal>setuid</literal> と <literal>setgid</literal> (「s」で表記されます) は実行ファイルに関係する 2 種類の特別な権限です。<literal>setuid</literal> と <literal>setgid</literal> は 0 か 1 で表されるブール値のため、「ビット」と呼ばれることが多い点に注意してください。<literal>setuid</literal> および <literal>setgid</literal> 権限を使うと、実行されたプログラムは所有者および所有グループの権限で動くことになります。このメカニズムを使うと、プログラムはプログラムを実行したユーザが通常持っているよりも高位のパーミッションを要求する機能にアクセスできるようになります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><literal>setuid</literal>, right</primary>"
msgstr "<primary><literal>setuid</literal>、権限</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><literal>setgid</literal>, right</primary>"
msgstr "<primary><literal>setgid</literal>、権限</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Since a <literal>setuid</literal> root program is systematically run under the super-user identity, it is very important to ensure it is secure and reliable. Indeed, a user who would manage to subvert it to call a command of their choice could then impersonate the root user and have all rights on the system."
msgstr "root が所有者の <literal>setuid</literal> されたプログラムは一貫してスーパーユーザとして実行されるため、この種のプログラムが安全で信頼できるプログラムか否かという点はとても重要です。実際、好きなコマンドを呼び出すために root が所有者の <literal>setuid</literal> されたプログラムを破壊することで、ユーザは root ユーザになりすまし、システムのすべての権限を掌握することが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "A directory is handled differently. Read access gives the right to consult the list of its entries (files and directories), write access allows creating or deleting files, and execute access allows crossing through it (especially to go there with the <command>cd</command> command). Being able to cross through a directory without being able to read it gives permission to access the entries therein that are known by name, but not to find them if you do not know their existence or their exact name."
msgstr "ディレクトリは別のやり方で取り扱われます。読み込み権限があれば、そのエントリ (ファイルとディレクトリ) のリストを閲覧することが可能です。書き込み権限があれば、ファイルを作成および削除することが可能です。実行権限があれば、そのディレクトリを横断することが可能です (<command>cd</command> コマンドでそのディレクトリに移動できます)。ディレクトリの読み込み権限がなくてもディレクトリを横断できるならば、ディレクトリ内の名前を知っているエントリにアクセスすることが可能です。ただし、エントリの存在を知らないかエントリの完全な名前を知らない場合、そのエントリを見つけることはできません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>SECURITY</emphasis> <literal>setgid</literal> directory and <emphasis>sticky bit</emphasis>"
msgstr "<emphasis>SECURITY</emphasis> <literal>setgid</literal> ディレクトリと<emphasis>スティッキービット</emphasis>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><literal>setgid</literal> directory</primary>"
msgstr "<primary><literal>setgid</literal> ディレクトリ</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <literal>setgid</literal> bit also applies to directories. Any newly-created item in such directories is automatically assigned the owner group of the parent directory, instead of inheriting the creator's main group as usual. This setup avoids the user having to change its main group (with the <command>newgrp</command> command) when working in a file tree shared between several users of the same dedicated group."
msgstr "<literal>setgid</literal> ビットはディレクトリにも適用されます。<literal>setgid</literal> ビットが適用されたディレクトリの中に新しく作成されたアイテムは、作成者のメイングループを継承するのではなく、自動的に親ディレクトリの所有グループを割り当てられます。こうすることで、ユーザが同じ専用グループに所属する複数のユーザの間で共有されているファイルツリーの中で作業をしている場合、(<command>newgrp</command> コマンドを使って) 自分のメイングループを変更する必要がなくなります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>sticky bit</primary>"
msgstr "<primary>スティッキービット</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The “sticky” bit (symbolized by the letter “t”) is a permission that is only useful in directories. It is especially used for temporary directories where everybody has write access (such as <filename>/tmp/</filename>): it restricts deletion of files so that only their owner (or the owner of the parent directory) can do it. Lacking this, everyone could delete other users' files in <filename>/tmp/</filename>."
msgstr "「スティッキー」ビット (「t」で表記されます) とはディレクトリだけに有効なパーミッションです。これは特に誰もが書き込み権限を持つ一時ディレクトリ (<filename>/tmp/</filename> など) に使われます。すなわち、スティッキービットを付けられたディレクトリ以下に含まれるファイルの削除を制限できます。ファイルは所有者 (または親ディレクトリの所有者) だけが削除できるようになります。<filename>/tmp/</filename> にスティッキービットがなければ、<filename>/tmp/</filename> ディレクトリ以下にある他のユーザのファイルを誰でも削除できることになります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Three commands control the permissions associated with a file:"
msgstr "以下はファイルのパーミッションを制御する 3 種類のコマンドです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<command>chown <replaceable>user</replaceable> <replaceable>file</replaceable></command> changes the owner of the file;"
msgstr "<command>chown <replaceable>user</replaceable> <replaceable>file</replaceable></command>。これはファイルの所有者を変更します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<command>chgrp <replaceable>group</replaceable> <replaceable>file</replaceable></command> alters the owner group;"
msgstr "<command>chgrp <replaceable>group</replaceable> <replaceable>file</replaceable></command>。これはファイルの所有グループを変更します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<command>chmod <replaceable>rights</replaceable> <replaceable>file</replaceable></command> changes the permissions for the file."
msgstr "<command>chmod <replaceable>rights</replaceable> <replaceable>file</replaceable></command>。これはファイルのパーミッションを変更します。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: man 1 chmod;
msgid "There are two ways of presenting rights. Among them, the symbolic representation is probably the easiest to understand and remember. It involves the letter symbols mentioned above. You can define rights for each category of users (<literal>u</literal>/<literal>g</literal>/<literal>o</literal>), by setting them explicitly (with <literal>=</literal>), by adding (<literal>+</literal>), or subtracting (<literal>-</literal>). Thus the <literal>u=rwx,g+rw,o-r</literal> formula gives the owner read, write, and execute rights, adds read and write rights for the owner group, and removes read rights for other users. Rights not altered by the addition or subtraction in such a command remain unmodified. The letter <literal>a</literal>, for “all”, covers all three categories of users, so that <literal>a=rx</literal> grants all three categories the same rights (read and execute, but not write)."
msgstr "権限の指定方法には 2 種類あります。それらの中でも、記号指定が最もわかりやすく覚えやすいでしょう。これは上で述べた文字記号を使います。ユーザのカテゴリ (<literal>u</literal>/<literal>g</literal>/<literal>o</literal>) に対する権限を (<literal>=</literal> で) 明示したり、(<literal>+</literal> で) 追加したり、(<literal>-</literal> で) 取り除いたりできます。そんなわけで、<literal>u=rwx,g+rw,o-r</literal> 式は、所有者に読み込み、書き込み、実行権限を与え、所有グループに読み込み、書き込み権限を追加し、その他のユーザから読み込み権限を奪います。追加と削除によって変更されない権限はそのままです。「all」を意味する文字 <literal>a</literal> は 3 つのユーザカテゴリすべてを表現します。このため、<literal>a=rx</literal> はすべてのカテゴリのユーザに対して同じ権限を与えます (読み込みと実行権限を与え、書き込み権限を与えません)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>chmod</command></primary>"
msgstr "<primary><command>chmod</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>chown</command></primary>"
msgstr "<primary><command>chown</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>chgrp</command></primary>"
msgstr "<primary><command>chgrp</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>octal representation of rights</primary>"
msgstr "<primary>権限の 8 進数表記</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>rights</primary><secondary>octal representation</secondary>"
msgstr "<primary>権限</primary><secondary>8 進数表記</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The (octal) numeric representation associates each right with a value: 4 for read, 2 for write, and 1 for execute. We associate each combination of rights with the sum of the figures. Each value is then assigned to different categories of users by putting them end to end in the usual order (owner, group, others)."
msgstr "数値表記は各権限を値 (8 進数) で表現します。具体的に言えば、読み込みは 4、書き込みは 2、実行権限は 1 で表現します。権限を組み合わせるには組み合わせたい権限に対応する数字を合計します。ユーザの各カテゴリ (所有者、グループ、その他) に対して与える権限を同じ順番で連結して、それぞれの権限を表現します。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: $ man 1 chmod;
msgid "For instance, the <command>chmod 754 <replaceable>file</replaceable></command> command will set the following rights: read, write and execute for the owner (since 7 = 4 + 2 + 1); read and execute for the group (since 5 = 4 + 1); read-only for others. The <literal>0</literal> means no rights; thus <command>chmod 600 <replaceable>file</replaceable></command> allows for read/write rights for the owner, and no rights for anyone else. The most frequent right combinations are <literal>755</literal> for executable files and directories, and <literal>644</literal> for data files."
msgstr "たとえば、<command>chmod 754 <replaceable>file</replaceable></command> コマンドは以下の権限を設定します。すなわち、所有者に書き込み、読み込み、実行権限を設定し (7 = 4 + 2 + 1 なので)、さらに所有グループに読み込み、実行権限を設定し (5 = 4 + 1 なので)、さらにその他のユーザに読み込み権限を設定します。<literal>0</literal> はいかなる権限も与えないことを意味します。このため <command>chmod 600 <replaceable>file</replaceable></command> は所有者に読み込み、書き込み権限を設定し、所有者以外のユーザにはいかなる権限も与えません。最もよく使われる権限の組み合わせは、実行ファイルやディレクトリの場合 <literal>755</literal> で、データファイルの場合 <literal>644</literal> です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "To represent special rights, you can prefix a fourth digit to this number according to the same principle, where the <literal>setuid</literal>, <literal>setgid</literal> and <literal>sticky</literal> bits are 4, 2 and 1, respectively. <command>chmod 4754</command> will associate the <literal>setuid</literal> bit with the previously described rights."
msgstr "同じ原則に従って特別な権限を表す 4 番目の桁は先に説明した 3 桁の権限表記の前に付けます。<literal>setuid</literal>、<literal>setgid</literal>、<literal>sticky</literal> ビットがそれぞれ 4、2、1 に対応します。<command>chmod 4754</command> は前に説明した権限に加えて、<literal>setuid</literal> ビットを設定します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Note that the use of octal notation only allows to set all the rights at once on a file; you cannot use it to simply add a new right, such as read access for the group owner, since you must take into account the existing rights and compute the new corresponding numerical value."
msgstr "8 進数表記で権限を指定すると、対象のファイルに対するすべての権限が同じものに設定されます。すなわち、たとえば所有グループに読み込み権限を与えるなどの新しい権限を追加したい場合、8 進数表記は使えません。なぜなら、既に設定されている権限を考慮した新しい権限の数値表記が対象のファイルすべてで同じ数値表記になるとは限らないからです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>TIP</emphasis> Recursive operation"
msgstr "<emphasis>TIP</emphasis> 再帰的操作"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Sometimes we have to change rights for an entire file tree. All the commands above have a <literal>-R</literal> option to operate recursively in sub-directories."
msgstr "しばしばファイルツリー全体の権限を変更しなければいけない場合があります。<command>chown</command>、<command>chgrp</command>、<command>chmod</command> には、サブディレクトリ内で再帰的に操作を行うための <literal>-R</literal> オプションが用意されています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The distinction between directories and files sometimes causes problems with recursive operations. That is why the “X” letter has been introduced in the symbolic representation of rights. It represents a right to execute which applies only to directories (and not to files lacking this right). Thus, <command>chmod -R a+X <replaceable>directory</replaceable></command> will only add execute rights for all categories of users (<literal>a</literal>) for all of the sub-directories and files for which at least one category of user (even if their sole owner) already has execute rights."
msgstr "再帰的な操作を行う場合、ディレクトリとファイルの違いが原因で時々問題が起こることがあります。このため、「X」文字が権限の記号表記に導入されました。「X」文字はディレクトリ (と誰かが実行権限を持つファイル) だけに適用される実行権限を表します。このため、<command>chmod -R a+X <replaceable>directory</replaceable></command> は、すべてのサブディレクトリと少なくとも 1 つのカテゴリのユーザ (所有者、所有グループ、その他のユーザのうちの誰か一人) が既に実行権限を持っているすべてのファイルに対して、すべてのカテゴリのユーザ (<literal>a</literal>) の実行権限を追加します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>TIP</emphasis> Changing the user and group"
msgstr "<emphasis>TIP</emphasis> ユーザとグループの変更"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Frequently you want to change the group of a file at the same time that you change the owner. The <command>chown</command> command has a special syntax for that: <command>chown <replaceable>user</replaceable>:<replaceable>group</replaceable> <replaceable>file</replaceable></command>"
msgstr "しばしば、ファイルのグループと所有者を同時に変更したい場合があります。この用途向けに <command>chown</command> コマンドには特別な構文があります。具体的に言えば、<command>chown <replaceable>user</replaceable>:<replaceable>group</replaceable> <replaceable>file</replaceable></command> です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>GOING FURTHER</emphasis> <command>umask</command>"
msgstr "<emphasis>GOING FURTHER</emphasis> <command>umask</command>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "When an application creates a file, it assigns indicative permissions, knowing that the system automatically removes certain rights, given by the command <command>umask</command>. Enter <command>umask</command> in a shell; you will see a mask such as <computeroutput>0022</computeroutput>. This is simply an octal representation of the rights to be systematically removed (in this case, the write right for the group and other users)."
msgstr "アプリケーションがファイルを作成する際、ファイルには目安となるパーミッションが割り当てられます。このパーミッションは <command>umask</command> コマンドで表示される特定の権限を削除したパーミッションです。シェルで <command>umask</command> を実行すると、<computeroutput>0022</computeroutput> などのマスクが表示されます。これは権限の単純な 8 進数表記で、これで表される権限が体系的に削除されます (<computeroutput>0022</computeroutput> の場合、所有グループとその他のユーザに対する書き込み権限が削除されます)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>umask</primary>"
msgstr "<primary>umask</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>rights</primary><secondary>mask</secondary>"
msgstr "<primary>権限</primary><secondary>マスク</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>mask</primary><secondary>rights mask</secondary>"
msgstr "<primary>マスク</primary><secondary>権限マスク</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: man 1 bash;
msgid "If you give it a new octal value, the <command>umask</command> command modifies the mask. Used in a shell initialization file (for example, <filename>~/.bash_profile</filename>), it will effectively change the default mask for your work sessions."
msgstr "新しい 8 進数値でマスクを再設定したければ、<command>umask</command> コマンドでマスクを変更できます。シェル初期化ファイル (たとえば、<filename>~/.bash_profile</filename>) の中で <command>umask</command> コマンドを使った場合、作業セッション内で有効なデフォルトのマスクを変更します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Administration Interfaces"
msgstr "管理インターフェース"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>interface</primary><secondary>administration interface</secondary>"
msgstr "<primary>インターフェース</primary><secondary>管理インターフェース</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>administration, interfaces</primary>"
msgstr "<primary>管理、インターフェース</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Using a graphical interface for administration is interesting in various circumstances. An administrator does not necessarily know all the configuration details for all their services, and doesn't always have the time to go seeking out the documentation on the matter. A graphical interface for administration can thus accelerate the deployment of a new service. It can also simplify the setup of services which are hard to configure."
msgstr "管理にグラフィカルインターフェースを使うことはさまざまな状況で興味深いです。管理者はすべてのサービスのすべての設定の詳細を知る必要はありませんし、常に問題に関連する文書を探し出すための時間があるというわけでもありません。管理用のグラフィカルインターフェースを使うと、新しいサービスを素早く配備できるようになります。さらに、設定の難しいサービスのセットアップを単純に行うことが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Such an interface is only an aid, and not an end in itself. In all cases, the administrator must master its behavior in order to understand and work around any potential problem."
msgstr "グラフィカルインターフェースは補助でしかなく、インターフェース自身は目的ではありません。どんな場合でも管理者は、さまざまな潜在的問題を理解して対処するために、サービスの挙動に精通しなければいけません。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: PTAL;
msgid "Since no interface is perfect, you may be tempted to try several solutions. This is to be avoided as much as possible, since different tools are sometimes incompatible in their work methods. Even if they all aim to be very flexible and try to adopt the configuration file as a single reference, they are not always able to integrate external changes."
msgstr "どんなインターフェースも完璧ではありませんから、さまざまなインターフェースを試したくなるかもしれません。これは可能な限り避けるべきです。なぜなら、ツールが違えばそのやり方に互換性がないこともあるからです。すべてのツールが高い柔軟性を持つことを心がけ、特定の設定ファイルを基準に選ぼうとしている場合であっても、あるツールが自分以外のツールによって行われた変更を必ず統合できるとは限りません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Administrating on a Web Interface: <command>webmin</command>"
msgstr "ウェブインターフェースを使った管理、<command>webmin</command>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis>webmin</emphasis></primary>"
msgstr "<primary><emphasis>webmin</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "This is, without a doubt, one of the most successful administration interfaces. It is a modular system managed through a web browser, covering a wide array of areas and tools. Furthermore, it is internationalized and available in many languages."
msgstr "<command>webmin</command> が最も成功した管理インターフェースの 1 つであることは間違いないでしょう。<command>webmin</command> はウェブブラウザを介したモジュールシステムで、幅広い領域とツールをカバーしています。さらに、<command>webmin</command> は国際化されており、多くの言語で利用できます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Sadly, <command>webmin</command> is no longer part of Debian. Its Debian maintainer — Jaldhar H. Vyas — removed the packages he created because he no longer had the time required to maintain them at an acceptable quality level. Nobody has officially taken over, so <emphasis role=\"distribution\">Jessie</emphasis> does not have the <command>webmin</command> package."
msgstr "残念なことに、<command>webmin</command> はもはや Debian に含まれません。<command>webmin</command> の Debian メンテナを務めていた Jaldhar H. Vyas は自分の作ったパッケージを削除しました。なぜなら、彼にはもはや品質合格基準に達するだけの品質でメンテナンス作業を行うのに必要な時間がなかったからです。公式にパッケージを引き継ぐ人がいなかったため、<emphasis role=\"distribution\">Jessie</emphasis> には <command>webmin</command> パッケージが含まれません。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: http://www.webmin.com/download.html;
# Ref: http://www.webmin.com/deb.html;
msgid "There is, however, an unofficial package distributed on the <literal>webmin.com</literal> website. Contrary to the original Debian packages, this package is monolithic; all of its configuration modules are installed and activated by default, even if the corresponding service is not installed on the machine."
msgstr "しかしながら、非公式パッケージが <literal>webmin.com</literal> ウェブサイトから配布されています。元の Debian パッケージと異なり、このパッケージは柔軟性に欠けています。さらに対応するサービスがマシンにインストールされているか否かに関わらず、すべての設定モジュールがインストールされデフォルトで有効化されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>SECURITY</emphasis> Changing the root password"
msgstr "<emphasis>SECURITY</emphasis> <command>webmin</command> の root パスワードの変更"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "On the first login, identification is conducted with the root username and its usual password. It is recommended to change the password used for <command>webmin</command> as soon as possible, so that if it is compromised, the root password for the server will not be involved, even if this confers important administrative rights to the machine."
msgstr "<command>webmin</command> の管理インターフェースに初めてログインする際には、root というユーザ名とサーバの root のパスワードを使って身分証明します。そして可能な限り早く <command>webmin</command> の root パスワードをサーバの root パスワードと違うものにしておくことを推奨します。なぜなら、たとえ <command>webmin</command> の root パスワードを使うことでサーバに対する重要な管理上の権限が必要な操作が可能になるとしても、両者を違うものにしておけば <command>webmin</command> が不正アクセスを受けた場合でもサーバの root パスワードを守ることが可能だからです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Beware! Since <command>webmin</command> has so many features, a malicious user accessing it could compromise the security of the entire system. In general, interfaces of this kind are not recommended for important systems with strong security constraints (firewall, sensitive servers, etc.)."
msgstr "注意してください! <command>webmin</command> は多くの機能を持っていますから、悪意あるユーザが <command>webmin</command> を使って全システムのセキュリティを侵害することが可能です。一般に、この種のインターフェースを強固なセキュリティを要求される重要なシステム (ファイアウォール、外部向けサーバなど) で使うのは推奨されません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Webmin is used through a web interface, but it does not require Apache to be installed. Essentially, this software has its own integrated mini web server. This server listens by default on port 10000 and accepts secure HTTP connections."
msgstr "webmin はウェブインターフェースを介して使われますが、Apache をインストールする必要はありません。元から webmin には統合された小さなウェブサーバが含まれています。このサーバはデフォルトでポート 10000 番をリッスンし、安全な HTTP 接続を受け入れます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Included modules cover a wide variety of services, among which:"
msgstr "<command>webmin</command> に導入されているモジュールは多種多様なサービスをカバーしています。たとえば以下はそのリストです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "all base services: creation of users and groups, management of <filename>crontab</filename> files, init scripts, viewing of logs, etc."
msgstr "すべての基盤サービス。このモジュールはユーザとグループの作成、<filename>crontab</filename> ファイルの管理、init スクリプト、ログの閲覧などを担当します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "bind: DNS server configuration (name service);"
msgstr "bind。このモジュールは DNS サーバの設定 (ネームサービス) を担当します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "postfix: SMTP server configuration (e-mail);"
msgstr "postfix。このモジュールは SMTP サーバの設定 (電子メール) を担当します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "inetd: configuration of the <command>inetd</command> super-server;"
msgstr "inetd。このモジュールは <command>inetd</command> スーパーサーバの設定を担当します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "quota: user quota management;"
msgstr "quota。このモジュールはユーザクォータの管理を担当します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "dhcpd: DHCP server configuration;"
msgstr "dhcpd。このモジュールは DHCP サーバの設定を担当します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "proftpd: FTP server configuration;"
msgstr "proftpd。このモジュールは FTP サーバの設定を担当します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "samba: Samba file server configuration;"
msgstr "samba。このモジュールは Samba ファイルサーバの設定を担当します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "software: installation or removal of software from Debian packages and system updates."
msgstr "ソフトウェア。このモジュールは Debian パッケージを使ったソフトウェアのインストールと削除およびシステム更新を担当します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The administration interface is available in a web browser at <literal>https://localhost:10000</literal>. Beware! Not all the modules are directly usable. Sometimes they must be configured by specifying the locations of the corresponding configuration files and some executable files (program). Frequently the system will politely prompt you when it fails to activate a requested module."
msgstr "ウェブブラウザで <literal>https://localhost:10000</literal> にアクセスすれば管理インターフェースを使えます。注意してください! すべてのモジュールがすぐに使えるわけではありません。対応する設定ファイルと一部の実行ファイル (プログラム) の場所を指定して、モジュールを設定しなければいけない場合もあります。webmin システムが要求されたモジュールの有効化に失敗した場合、webmin システムは丁寧な指示を表示するでしょう。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>ALTERNATIVE</emphasis> GNOME control center"
msgstr "<emphasis>ALTERNATIVE</emphasis> GNOME コントロールセンター"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis role=\"pkg\">gnome-control-center</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">gnome-control-center</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: PTAL;
msgid "The GNOME project also provides multiple administration interfaces that are usually accessible via the “Settings” entry in the user menu on the top right. <command>gnome-control-center</command> is the main program that brings them all together but many of the system wide configuration tools are effectively provided by other packages (<emphasis role=\"pkg\">accountsservice</emphasis>, <emphasis role=\"pkg\">system-config-printer</emphasis>, etc.). Although they are easy to use, these applications cover only a limited number of base services: user management, time configuration, network configuration, printer configuration, and so on."
msgstr "GNOME プロジェクトは、通常右上に位置するシステムメニューの「設定」エントリから利用できる、複数の管理インターフェースを提供します。<command>gnome-control-center</command> は複数の管理インターフェースをひとまとめにしたメインプログラムですが、システム共通設定ツールの多くは他のパッケージによって提供されています (たとえば <emphasis role=\"pkg\">accountsservice</emphasis>、<emphasis role=\"pkg\">system-config-printer</emphasis> などが提供されています)。これらのアプリケーションは使いやすいのですが、基盤サービスの一部だけしかカバーされません。たとえば、ユーザ管理、時間設定、ネットワーク設定、プリンタ設定、などがカバーされます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Configuring Packages: <command>debconf</command>"
msgstr "パッケージの設定、<command>debconf</command>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>debconf</command></primary>"
msgstr "<primary><command>debconf</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>dpkg-reconfigure</command></primary>"
msgstr "<primary><command>dpkg-reconfigure</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Many packages are automatically configured after asking a few questions during installation through the Debconf tool. These packages can be reconfigured by running <command>dpkg-reconfigure <replaceable>package</replaceable></command>."
msgstr "多くのパッケージが、インストール中 Debconf ツールを使ってわずかな質問をした後に、自動的に設定されるようになっています。この種のパッケージは <command>dpkg-reconfigure <replaceable>package</replaceable></command> を実行すれば再設定できます。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: http://www.tldp.org/LDP/Linux-Filesystem-Hierarchy/html/etc.html;
# Ref: man 7 debconf-devel;
# Ref: https://wiki.debian.org/PackageConfigUpgrade;
# Ref: https://wiki.debian.org/ConfigPackages;
# Tag: PTAL;
msgid "For most cases, these settings are very simple; only a few important variables in the configuration file are changed. These variables are often grouped between two “demarcation” lines so that reconfiguration of the package only impacts the enclosed area. In other cases, reconfiguration will not change anything if the script detects a manual modification of the configuration file, in order to preserve these human interventions (because the script can't ensure that its own modifications will not disrupt the existing settings)."
msgstr "多くの場合、これらの設定はとても簡素です。すなわち、設定ファイル中のわずかな重要変数だけが変更されます。これらの重要変数は多くの場合 2 つの「境界」線で挟まれています。そうすれば、パッケージを再設定する際に影響をおよぼす箇所を境界線で挟まれた範囲だけに限定できるからです。「境界」線で挟まれていない場合、スクリプトが手作業で設定ファイルが変更されたことを検出したら、人間による設定変更を上書きしないよう、再設定しても何も変更されません (なぜなら、スクリプトは自分の修正が既存の設定を破壊しないことを保証できないからです)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>DEBIAN POLICY</emphasis> Preserving changes"
msgstr "<emphasis>DEBIAN POLICY</emphasis> 変更の保存"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: https://www.debian.org/doc/debian-policy/ch-files.html 10.7.3 Behavior;
msgid "The Debian Policy expressly stipulates that everything should be done to preserve manual changes made to a configuration file, so more and more scripts take precautions when editing configuration files. The general principle is simple: the script will only make changes if it knows the status of the configuration file, which is verified by comparing the checksum of the file against that of the last automatically generated file. If they are the same, the script is authorized to change the configuration file. Otherwise, it determines that the file has been changed and asks what action it should take (install the new file, save the old file, or try to integrate the new changes with the existing file). This precautionary principle has long been unique to Debian, but other distributions have gradually begun to embrace it."
msgstr "Debian ポリシーには、スクリプトは設定ファイルに対して行われた手作業の変更を保護するように作業を実行しなければいけないことが明確に規定されています。このため、ますます多くのスクリプトが設定ファイルを編集する際に事前注意を出します。一般的な原則は単純です。すなわち、スクリプトが修正を行うのは、設定ファイルの状態を検証して、修正しても問題ないと判断した場合だけです。設定ファイルの状態検証は、最後に自動的に生成された設定ファイルのチェックサムと現在の設定ファイルのチェックサムを比較することで行います。両者のチェックサムが同じ場合、スクリプトは設定ファイルを変更する権限を与えられます。チェックサムが違った場合、設定ファイルが変更されたと判断し、対応 (新しいファイルをインストールする、古いファイルを保存する、新しい変更を既存のファイルと統合しようとする) を尋ねます。この事前注意の原則は長きにわたり Debian に固有の原則でしたが、他のディストリビューションでも徐々にこの原則が採用され始めています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <command>ucf</command> program (from the Debian package of the same name) can be used to implement such a behavior."
msgstr "<command>ucf</command> プログラム (同名の Debian パッケージに含まれます) はこの原則を実行に移すために使われます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>ucf</command></primary>"
msgstr "<primary><command>ucf</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<command>syslog</command> System Events"
msgstr "<command>syslog</command> システムイベント"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>rsyslogd</command></primary>"
msgstr "<primary><command>rsyslogd</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>files</primary><secondary>log files</secondary>"
msgstr "<primary>ファイル</primary><secondary>ログファイル</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>logs</primary><secondary>dispatching</secondary>"
msgstr "<primary>ログ</primary><secondary>配送</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Principle and Mechanism"
msgstr "原理とメカニズム"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <command>rsyslogd</command> daemon is responsible for collecting service messages coming from applications and the kernel, then dispatching them into log files (usually stored in the <filename>/var/log/</filename> directory). It obeys the <filename>/etc/rsyslog.conf</filename> configuration file."
msgstr "<command>rsyslogd</command> デーモンはアプリケーションおよびカーネルからのサービスメッセージの収集を担当し、サービスメッセージをログファイルに配送します (通常 <filename>/var/log/</filename> ディレクトリに保存します)。<command>rsyslogd</command> デーモンは <filename>/etc/rsyslog.conf</filename> ファイルの設定に従います。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Each log message is associated with an application subsystem (called “facility” in the documentation):"
msgstr "各ログメッセージはアプリケーションサブシステム (文書中では「facility」と呼ばれます) に関連付けられます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>auth</literal> and <literal>authpriv</literal>: for authentication;"
msgstr "<literal>auth</literal> と <literal>authpriv</literal>。認証に関連するメッセージです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>cron</literal>: comes from task scheduling services, <command>cron</command> and <command>atd</command>;"
msgstr "<literal>cron</literal>。タスクスケジューリングサービスである <command>cron</command> と <command>atd</command> から受け取ったメッセージです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>daemon</literal>: affects a daemon without any special classification (DNS, NTP, etc.);"
msgstr "<literal>daemon</literal>。特に分類されていないデーモン (DNS、NTP、など) から受け取ったメッセージです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>ftp</literal>: concerns the FTP server;"
msgstr "<literal>ftp</literal>。FTP サーバから受け取ったメッセージです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>kern</literal>: message coming from the kernel;"
msgstr "<literal>kern</literal>。カーネルから受け取ったメッセージです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>lpr</literal>: comes from the printing subsystem;"
msgstr "<literal>lpr</literal>。印刷サブシステムから受け取ったメッセージです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>mail</literal>: comes from the e-mail subsystem;"
msgstr "<literal>mail</literal>。電子メールサブシステムから受け取ったメッセージです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>news</literal>: Usenet subsystem message (especially from an NNTP — Network News Transfer Protocol — server that manages newsgroups);"
msgstr "<literal>news</literal>。Usenet サブシステム (特にニュースグループを管理する NNTP (Network News Transfer Protocol) サーバ) から受け取ったメッセージです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>syslog</literal>: messages from the <command>syslogd</command> server, itself;"
msgstr "<literal>syslog</literal>。<command>syslogd</command> サーバ (自分) から受け取ったメッセージです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>user</literal>: user messages (generic);"
msgstr "<literal>user</literal>。ユーザメッセージ (一般的なメッセージ) に関連するメッセージです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>uucp</literal>: messages from the UUCP server (Unix to Unix Copy Program, an old protocol notably used to distribute e-mail messages);"
msgstr "<literal>uucp</literal>。UUCP (Unix to Unix Copy Program、とりわけ昔は電子メールメッセージの配送に使われていた古いプロトコル) サーバから受け取ったメッセージです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>local0</literal> to <literal>local7</literal>: reserved for local use."
msgstr "<literal>local0</literal> から <literal>local7</literal>。ローカル利用向けに予約されているサブシステムから受け取ったメッセージです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Each message is also associated with a priority level. Here is the list in decreasing order:"
msgstr "さらに各メッセージは優先度と関連付けられます。以下は優先度の高い順に挙げたリストです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>emerg</literal>: “Help!” There is an emergency, the system is probably unusable."
msgstr "<literal>emerg</literal>。システムが「助けてください!」と言っていることを示しています。これは非常事態で、おそらくシステムが不安定になっていることを示しています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>alert</literal>: hurry up, any delay can be dangerous, action must be taken immediately;"
msgstr "<literal>alert</literal>。システムが大至急対応を必要としており、遅れると危険な状態になることを示しています。この場合、すぐに何らかの措置を講じてください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>crit</literal>: conditions are critical;"
msgstr "<literal>crit</literal>。システムが危機的状態に陥っていることを示しています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>err</literal>: error;"
msgstr "<literal>err</literal>。システムにエラーが発生していることを示しています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>warn</literal>: warning (potential error);"
msgstr "<literal>warn</literal>。システムが警告 (潜在的エラー) を発していることを示しています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>notice</literal>: conditions are normal, but the message is important;"
msgstr "<literal>notice</literal>。システムが正常な状態とは言うものの、重要なメッセージを発していることを示しています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>info</literal>: informative message;"
msgstr "<literal>info</literal>。システムが有益なメッセージを発していることを示しています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>debug</literal>: debugging message."
msgstr "<literal>debug</literal>。システムがデバッグメッセージを発していることを示しています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The Configuration File"
msgstr "設定ファイル"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The syntax of the <filename>/etc/rsyslog.conf</filename> file is detailed in the <citerefentry><refentrytitle>rsyslog.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry> manual page, but there is also HTML documentation available in the <emphasis role=\"pkg\">rsyslog-doc</emphasis> package (<filename>/usr/share/doc/rsyslog-doc/html/index.html</filename>). The overall principle is to write “selector” and “action” pairs. The selector defines all relevant messages, and the actions describes how to deal with them."
msgstr "<filename>/etc/rsyslog.conf</filename> ファイルの構文は <citerefentry><refentrytitle>rsyslog.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry> マニュアルページで詳しく説明されています。しかし、<emphasis role=\"pkg\">rsyslog-doc</emphasis> パッケージから提供される HTML 文書 (<filename>/usr/share/doc/rsyslog-doc/html/index.html</filename>) も利用できます。全般的な原則は「セレクタ」と「アクション」の組を書くことです。セレクタはすべての関連するメッセージを定義し、アクションはそれらのメッセージをどのように取り扱うかを定義します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Syntax of the Selector"
msgstr "セレクタの構文"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The selector is a semicolon-separated list of <literal><replaceable>subsystem</replaceable>.<replaceable>priority</replaceable></literal> pairs (example: <literal>auth.notice;mail.info</literal>). An asterisk may represent all subsystems or all priorities (examples: <literal>*.alert</literal> or <literal>mail.*</literal>). Several subsystems can be grouped, by separating them with a comma (example: <literal>auth,mail.info</literal>). The priority indicated also covers messages of equal or higher priority; thus <literal>auth.alert</literal> indicates the <literal>auth</literal> subsystem messages of <literal>alert</literal> or <literal>emerg</literal> priority. Prefixed with an exclamation point (!), it indicates the opposite, in other words the strictly lower priorities; <literal>auth.!notice</literal>, thus, indicates messages issued from <literal>auth</literal>, with <literal>info</literal> or <literal>debug</literal> priority. Prefixed with an equal sign (=), it corresponds to precisely and only the priority indicated (<literal>auth.=notice</literal> only concerns messages from <literal>auth</literal> with <literal>notice</literal> priority)."
msgstr "セレクタは <literal><replaceable>subsystem</replaceable>.<replaceable>priority</replaceable></literal> の組からなるセミコロン区切りリストです (たとえば <literal>auth.notice;mail.info</literal> などです)。アスタリスクはすべてのサブシステムまたはすべての優先度を表します (たとえば <literal>*.alert</literal>、<literal>mail.*</literal> などのように使います)。コンマで区切れば複数のサブシステムをグループ化することが可能です (たとえば <literal>auth,mail.info</literal> などのように使います)。優先度は指定した優先度と同じかより高い優先度を持つメッセージを意味しています。このため <literal>auth.alert</literal> は <literal>alert</literal> および <literal>emerg</literal> 優先度を持つ <literal>auth</literal> サブシステムメッセージを表現します。優先度の前に感嘆符 (!) を付けると否定を表します。言い換えれば、その優先度より低い優先度です。このため <literal>auth.!notice</literal> は <literal>auth</literal> サブシステムメッセージの内 <literal>info</literal> および <literal>debug</literal> 優先度を持つメッセージを表現します。優先度の前に等号 (=) を付けると、指定した優先度だけを表します (<literal>auth.=notice</literal> は <literal>auth</literal> サブシステムメッセージの内 <literal>notice</literal> 優先度を持つメッセージを表現します)。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: $ man 3 syslog;
# Ref: http://tools.ietf.org/html/rfc5424;
# Tag: PTAL;
msgid "Each element in the list on the selector overrides previous elements. It is thus possible to restrict a set or to exclude certain elements from it. For example, <literal>kern.info;kern.!err</literal> means messages from the kernel with priority between <literal>info</literal> and <literal>warn</literal>. The <literal>none</literal> priority indicates the empty set (no priorities), and may serve to exclude a subsystem from a set of messages. Thus, <literal>*.crit;kern.none</literal> indicates all the messages of priority equal to or higher than <literal>crit</literal> not coming from the kernel."
msgstr "セレクタリスト内の各要素は前の要素を上書きします。このため、セレクタリストからある組を制限したり、特定の要素だけを除外することが可能です。たとえば、<literal>kern.info;kern.!err</literal> はカーネルから受け取った <literal>info</literal> 以上 <literal>warn</literal> 以下の優先度を持つメッセージを意味します。<literal>none</literal> 優先度は空の組を意味し (優先度を指定しないことを意味し)、あるサブシステムだけをメッセージの組から除外するのに役立つかもしれません。そんなわけで、<literal>*.crit;kern.none</literal> はカーネルから受け取った <literal>crit</literal> 以上の優先度を持つメッセージを意味します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Syntax of Actions"
msgstr "アクションの構文"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> The named pipe, a persistent pipe"
msgstr "<emphasis>BACK TO BASICS</emphasis> 名前付きパイプ、永続的なパイプ"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>named pipe</primary>"
msgstr "<primary>名前付きパイプ</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>pipe, named pipe</primary>"
msgstr "<primary>パイプ、名前付きパイプ</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "A named pipe is a particular type of file that operates like a traditional pipe (the pipe that you make with the “|” symbol on the command line), but via a file. This mechanism has the advantage of being able to relate two unrelated processes. Anything written to a named pipe blocks the process that writes until another process attempts to read the data written. This second process reads the data written by the first, which can then resume execution."
msgstr "名前付きパイプは特殊なファイル型で、古典的なパイプ (コマンドラインで「|」文字を使って表すパイプ) のように振る舞いますが、ファイルを経由します。名前付きパイプのメカニズムは 2 つの別々のプロセスを関連付けることが可能という利点を持っています。別のプロセスが名前付きパイプに書き込まれるデータを読む準備を整えるまで、名前付きパイプに書き込むプロセスはブロックされます。読み込み側のプロセスが書き込み側のプロセスの書き込んだデータを読み込むと、書き込み側のプロセスのブロックが解除されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Such a file is created with the <command>mkfifo</command> command."
msgstr "名前付きパイプは <command>mkfifo</command> コマンドで作成します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The various possible actions are:"
msgstr "以下に指定できるさまざまなアクションを挙げます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "add the message to a file (example: <filename>/var/log/messages</filename>);"
msgstr "ファイルにメッセージを追記します (たとえば <filename>/var/log/messages</filename> などのように指定します)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "send the message to a remote <command>syslog</command> server (example: <literal>@log.falcot.com</literal>);"
msgstr "メッセージをリモートの <command>syslog</command> サーバに送信します (たとえば <literal>@log.falcot.com</literal> などのように指定します)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "send the message to an existing named pipe (example: <literal>|/dev/xconsole</literal>);"
msgstr "既存の名前付きパイプにメッセージを送信します (たとえば <literal>|/dev/xconsole</literal> などのように指定します)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "send the message to one or more users, if they are logged in (example: <literal>root,rhertzog</literal>);"
msgstr "ログイン中の個人または複数人のユーザにメッセージを送信します (たとえば <literal>root,rhertzog</literal> などのように指定します)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "send the message to all logged in users (example: <literal>*</literal>);"
msgstr "ログイン中の全ユーザにメッセージを送信します (たとえば <literal>*</literal> などのように指定します)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "write the message in a text console (example: <literal>/dev/tty8</literal>)."
msgstr "テキストコンソールにメッセージを書き込みます (たとえば <literal>/dev/tty8</literal> などのように指定します)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>SECURITY</emphasis> Forwarding logs"
msgstr "<emphasis>SECURITY</emphasis> ログの転送"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>log</primary><secondary>forwarding</secondary>"
msgstr "<primary>ログ</primary><secondary>転送</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "It is a good idea to record the most important logs on a separate machine (perhaps dedicated for this purpose), since this will prevent any possible intruder from removing traces of their intrusion (unless, of course, they also compromise this other server). Furthermore, in the event of a major problem (such as a kernel crash), you have the logs available on another machine, which increases your chances of determining the sequence of events that caused the crash."
msgstr "最重要のログを別のマシン (ログ記録専用マシン) に記録することは良い考えです。なぜなら、そうすることで侵入者に不正侵入の形跡を削除されないようにすることが可能だからです (形跡を削除するにはもちろん、ログ記録専用の別のマシンに不正アクセスするしかありません)。さらに、深刻な問題 (カーネルクラッシュなど) が起きた場合に、別のマシンにログを記録しておけば、クラッシュを引き起こす一連の出来事を決定できる可能性を増やすことが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "To accept log messages sent by other machines, you must reconfigure <emphasis>rsyslog</emphasis>: in practice, it is sufficient to activate the ready-for-use entries in <filename>/etc/rsyslog.conf</filename> (<literal>$ModLoad imudp</literal> and <literal>$UDPServerRun 514</literal>)."
msgstr "他のマシンから送信されたログメッセージを受け入れるには、<emphasis>rsyslog</emphasis> を再設定しなければいけません。具体的に言えば、<filename>/etc/rsyslog.conf</filename> の中ですぐに利用できる状態になっているエントリ (<literal>$ModLoad imudp</literal> と <literal>$UDPServerRun 514</literal>) を有効化するだけで十分です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <command>inetd</command> Super-Server"
msgstr "<command>inetd</command> スーパーサーバ"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Inetd (often called “Internet super-server”) is a server of servers. It executes rarely used servers on demand, so that they do not have to run continuously."
msgstr "inetd (通常「インターネットスーパーサーバ」と呼ばれます) はサーバのサーバです。inetd は要求に応じてまれに使われるサーバを実行します。そうすれば、まれにしか使われないサーバを常に実行しておく必要がなくなります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>inetd</command></primary>"
msgstr "<primary><command>inetd</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>super-server</primary>"
msgstr "<primary>スーパーサーバ</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <filename>/etc/inetd.conf</filename> file lists these servers and their usual ports. The <command>inetd</command> command listens to all of them; when it detects a connection to any such port, it executes the corresponding server program."
msgstr "<filename>/etc/inetd.conf</filename> ファイルには、要求に応じて起動するサーバとサーバの使うポート番号が書かれています。<command>inetd</command> コマンドはここで書かれたすべてのポートをリッスンします。さらに、<command>inetd</command> はポートに対する接続を検出したら、対応するサーバプログラムを実行します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>DEBIAN POLICY</emphasis> Register a server in <filename>inetd.conf</filename>"
msgstr "<emphasis>DEBIAN POLICY</emphasis> <filename>inetd.conf</filename> へのサーバの登録"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Packages frequently want to register a new server in the <filename>/etc/inetd.conf</filename> file, but Debian Policy prohibits any package from modifying a configuration file that it doesn't own. This is why the <command>update-inetd</command> script (in the package with the same name) was created: It manages the configuration file, and other packages can thus use it to register a new server to the super-server's configuration."
msgstr "多くの場合 inetd を使うサーバのパッケージは <filename>/etc/inetd.conf</filename> ファイルに自分を登録することを望むのですが、Debian ポリシーはパッケージが自分の持ち物でない設定ファイルを修正することを禁止しています。このため、<command>update-inetd</command> スクリプト (同名のパッケージに含まれます) が作成されました。すなわち <command>update-inetd</command> スクリプトが設定ファイルを管理し、他のパッケージは <command>update-inetd</command> を使ってスーパーサーバの設定に新しいサーバを登録します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Each significant line of the <filename>/etc/inetd.conf</filename> file describes a server through seven fields (separated by spaces):"
msgstr "<filename>/etc/inetd.conf</filename> ファイルの有効な各行は (空白で区切られた) 7 つのフィールドで 1 つのサーバを表現します。各フィールドの意味は以下の通りです。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: http://manpages.ubuntu.com/manpages/dapper/man5/inetd.conf.5.html;
msgid "The TCP or UDP port number, or the service name (which is mapped to a standard port number with the information contained in the <filename>/etc/services</filename> file)."
msgstr "TCP か UDP のポート番号、またはサービス名 (この場合、<filename>/etc/services</filename> ファイルに含まれる情報を使って標準的なポート番号に置換されます)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The socket type: <literal>stream</literal> for a TCP connection, <literal>dgram</literal> for UDP datagrams."
msgstr "ソケットタイプ。このフィールドは TCP 接続の場合 <literal>stream</literal>、UDP データグラムの場合 <literal>dgram</literal> を指定します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The protocol: <literal>tcp</literal> or <literal>udp</literal>."
msgstr "プロトコル。このフィールドは <literal>tcp</literal> または <literal>udp</literal> を指定します。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: https://www.freebsd.org/doc/handbook/network-inetd.html
msgid "The options: two possible values: <literal>wait</literal> or <literal>nowait</literal>, to tell <command>inetd</command> whether it should wait or not for the end of the launched process before accepting another connection. For TCP connections, easily multiplexable, you can usually use <literal>nowait</literal>. For programs responding over UDP, you should use <literal>nowait</literal> only if the server is capable of managing several connections in parallel. You can suffix this field with a period, followed by the maximum number of connections authorized per minute (the default limit is 256)."
msgstr "オプション。このフィールドに指定できる値は <literal>wait</literal> または <literal>nowait</literal> の 2 種類です。これらの値を使って、<command>inetd</command> に対して他の接続を受け入れる前に既に起動中のプロセスの終了を待つ (<literal>wait</literal>) か待たない (<literal>nowait</literal>) かを指定します。簡単に多重送信対応できる TCP 接続の場合、通常 <literal>nowait</literal> を使います。UDP を使って応答するプログラムに対しては、サーバが複数接続の並列化を管理する機能を持っている場合に限り <literal>nowait</literal> を使うべきです。この後にピリオドで区切りながら子プロセスの最大数、さらに 1 分間に認められる接続の最大数 (デフォルトの値は 256) を指定することが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The user name of the user under whose identity the server will run."
msgstr "ユーザ名。サーバはこのユーザの権限で実行されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The full path to the server program to execute."
msgstr "実行するサーバプログラムのフルパス。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The arguments: this is a complete list of the program's arguments, including its own name (<literal>argv[0]</literal> in C)."
msgstr "引数。このフィールドはプログラムの引数の完全なリストを指定し、サーバプログラムの名前 (C 言語で言えば <literal>argv[0]</literal>) を含みます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The following example illustrates the most common cases:"
msgstr "最も一般的な場合、以下の例のようになります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Excerpt from <filename>/etc/inetd.conf</filename>"
msgstr "<filename>/etc/inetd.conf</filename> からの抜粋"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"talk   dgram  udp wait    nobody.tty /usr/sbin/in.talkd in.talkd\n"
"finger stream tcp nowait  nobody     /usr/sbin/tcpd     in.fingerd\n"
"ident  stream tcp nowait  nobody     /usr/sbin/identd   identd -i"
msgstr ""
"talk   dgram  udp wait    nobody.tty /usr/sbin/in.talkd in.talkd\n"
"finger stream tcp nowait  nobody     /usr/sbin/tcpd     in.fingerd\n"
"ident  stream tcp nowait  nobody     /usr/sbin/identd   identd -i"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>tcpd</command></primary>"
msgstr "<primary><command>tcpd</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: $ man 8 tcpd;
msgid "The <command>tcpd</command> program is frequently used in the <filename>/etc/inetd.conf</filename> file. It allows limiting incoming connections by applying access control rules, documented in the <citerefentry><refentrytitle>hosts_access</refentrytitle><manvolnum>5</manvolnum></citerefentry> manual page, and which are configured in the <filename>/etc/hosts.allow</filename> and <filename>/etc/hosts.deny</filename> files. Once it has been determined that the connection is authorized, <command>tcpd</command> executes the real server (like <command>in.fingerd</command> in our example). It is worth noting that <command>tcpd</command> relies on the name under which it was invoked (that is the first argument, <literal>argv[0]</literal>) to identify the real program to run. So you should not start the arguments list with <literal>tcpd</literal> but with the program that must be wrapped."
msgstr "<filename>/etc/inetd.conf</filename> ファイルの中では <command>tcpd</command> プログラムを使うことが多いです。<command>tcpd</command> プログラムを使うと、アクセス制御ルールを適用して到着する接続を制限することが可能です。アクセス制御ルールは <citerefentry><refentrytitle>hosts_access</refentrytitle><manvolnum>5</manvolnum></citerefentry> マニュアルページで説明されており、<filename>/etc/hosts.allow</filename> と <filename>/etc/hosts.deny</filename> ファイルの中で設定されます。<command>tcpd</command> は接続を確認し、認証が済んだら実際のサーバを実行します (以下の例では <command>in.fingerd</command> を実行しています)。<command>tcpd</command> はそれが実行された時の名前 (1 番目の引数 <literal>argv[0]</literal>) を頼りに実際に実行するプログラムを識別します。この点に注意してください。そのため、引数リストは <literal>tcpd</literal> で始めるのではなく、ラップされなければいけないプログラムの名前で始めるべきです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>COMMUNITY</emphasis> Wietse Venema"
msgstr "<emphasis>COMMUNITY</emphasis> Wietse Venema"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Wietse Venema</primary>"
msgstr "<primary>Wietse Venema</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Venema, Wietse</primary>"
msgstr "<primary>Venema, Wietse</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Wietse Venema, whose expertise in security has made him a renowned programmer, is the author of the <command>tcpd</command> program. He is also the main creator of Postfix, the modular e-mail server (SMTP, Simple Mail Transfer Protocol), designed to be safer and more reliable than <command>sendmail</command>, which features a long history of security vulnerabilities."
msgstr "Wietse Venema は <command>tcpd</command> プログラムの作者で、セキュリティ分野における専門知識によって名を挙げたプログラマです。彼はまた Postfix の主な創案者でもあります。Postfix はモジュール式電子メールサーバ (SMTP、Simple Mail Transfer Protocol) で、セキュリティ脆弱性の長い歴史を特徴付ける <command>sendmail</command> よりも安全で信頼性が高くなるように設計されました。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>ALTERNATIVE</emphasis> Other <command>inetd</command> commands"
msgstr "<emphasis>ALTERNATIVE</emphasis> 他の <command>inetd</command> コマンド"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: PTAL;
msgid "While Debian installs <emphasis role=\"pkg\">openbsd-inetd</emphasis> by default, there is no lack of alternatives: we can mention <emphasis role=\"pkg\">inetutils-inetd</emphasis>, <emphasis role=\"pkg\">micro-inetd</emphasis>, <emphasis role=\"pkg\">rlinetd</emphasis> and <emphasis role=\"pkg\">xinetd</emphasis>."
msgstr "Debian はデフォルトで <emphasis role=\"pkg\">openbsd-inetd</emphasis> をインストールしますが、他にも数多くの代替品があります。たとえば <emphasis role=\"pkg\">inetutils-inetd</emphasis>、<emphasis role=\"pkg\">micro-inetd</emphasis>、<emphasis role=\"pkg\">rlinetd</emphasis>、<emphasis role=\"pkg\">xinetd</emphasis> などの代替品が存在します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "This last incarnation of a super-server offers very interesting possibilities. Most notably, its configuration can be split into several files (stored, of course, in the <filename>/etc/xinetd.d/</filename> directory), which can make an administrator's life easier."
msgstr "<emphasis role=\"pkg\">xinetd</emphasis> は大変興味深い機能を持っています。中でも注目すべきは、<emphasis role=\"pkg\">xinetd</emphasis> の設定を複数のファイル (これはもちろん <filename>/etc/xinetd.d/</filename> ディレクトリの中に保存されています) に分割できるという点です。このおかげで、管理がもっと楽になります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Last but not least, it is even possible to emulate <command>inetd</command>'s behaviour with <command>systemd</command>'s socket-activation mechanism (see <xref linkend=\"sect.systemd\" />)."
msgstr "最後に重要なことですが、<command>systemd</command> のソケット有効化メカニズムを使えば、<command>inetd</command> の挙動をエミュレートすることも可能です (<xref linkend=\"sect.systemd\" />を参照してください)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Scheduling Tasks with <command>cron</command> and <command>atd</command>"
msgstr "<command>cron</command> と <command>atd</command> を使ったスケジューリングタスク"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>cron</command></primary>"
msgstr "<primary><command>cron</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>atd</command></primary>"
msgstr "<primary><command>atd</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>scheduled commands</primary>"
msgstr "<primary>スケジュールされたコマンド</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>command scheduling</primary>"
msgstr "<primary>コマンドのスケジューリング</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<command>cron</command> is the daemon responsible for executing scheduled and recurring commands (every day, every week, etc.); <command>atd</command> is that which deals with commands to be executed a single time, but at a specific moment in the future."
msgstr "<command>cron</command> は定期的に (毎日、毎週など) 実行するよう予定されたコマンドの実行を担当しているデーモンです。また、<command>atd</command> は未来の特定の時間に 1 回だけ実行するよう予定されたコマンドの実行を担当しているデーモンです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "In a Unix system, many tasks are scheduled for regular execution:"
msgstr "Unix システムでは、以下に挙げる多くのタスクが定期的に実行されるよう予定されています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "rotating the logs;"
msgstr "ログの循環。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "updating the database for the <command>locate</command> program;"
msgstr "<command>locate</command> プログラムの使うデータベースの更新。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "back-ups;"
msgstr "バックアップ。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "maintenance scripts (such as cleaning out temporary files)."
msgstr "メンテナンススクリプト (これは一時ファイルの掃除を行うスクリプトなどを指します)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "By default, all users can schedule the execution of tasks. Each user has thus their own <emphasis>crontab</emphasis> in which they can record scheduled commands. It can be edited by running <command>crontab -e</command> (its content is stored in the <filename>/var/spool/cron/crontabs/<replaceable>user</replaceable></filename> file)."
msgstr "デフォルトで、すべてのユーザはタスク実行の予定を入れることが可能です。各ユーザは自分専用の <emphasis>crontab</emphasis> を持っており、これを使ってコマンド実行の予定を登録することが可能です。<emphasis>crontab</emphasis> を編集するには <command>crontab -e</command> を実行します (<emphasis>crontab</emphasis> は <filename>/var/spool/cron/crontabs/<replaceable>user</replaceable></filename> ファイルに保存されます)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>SECURITY</emphasis> Restricting <command>cron</command> or <command>atd</command>"
msgstr "<emphasis>SECURITY</emphasis> <command>cron</command> または <command>atd</command> の使用制限"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "You can restrict access to <command>cron</command> by creating an explicit authorization file (whitelist) in <filename>/etc/cron.allow</filename>, in which you indicate the only users authorized to schedule commands. All others will automatically be deprived of this feature. Conversely, to only block one or two troublemakers, you could write their username in the explicit prohibition file (blacklist), <filename>/etc/cron.deny</filename>. This same feature is available for <command>atd</command>, with the <filename>/etc/at.allow</filename> and <filename>/etc/at.deny</filename> files."
msgstr "実行を許可するユーザを明示するファイル (ホワイトリスト) <filename>/etc/cron.allow</filename> の中にコマンドの予定を入れることを許可するユーザを書けば、<command>cron</command> へのアクセスを制限することが可能です。その他のユーザは自動的にスケジューリングタスク機能を使えなくなります。反対に、実行を禁止するユーザを明示するファイル (ブラックリスト) <filename>/etc/cron.deny</filename> の中にユーザ名を書けば、1 人か 2 人の問題児だけをブロックすることが可能です。<command>atd</command> に対しても <filename>/etc/at.allow</filename> と <filename>/etc/at.deny</filename> ファイルを使って同等の機能が利用できます。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: $ man 5 crontab;
msgid "The root user has their own <emphasis>crontab</emphasis>, but can also use the <filename>/etc/crontab</filename> file, or write additional <emphasis>crontab</emphasis> files in the <filename>/etc/cron.d</filename> directory. These last two solutions have the advantage of being able to specify the user identity to use when executing the command."
msgstr "root ユーザは自分専用の <emphasis>crontab</emphasis> を持っていますが、<filename>/etc/crontab</filename> ファイルを使ったり、追加的な <emphasis>crontab</emphasis> ファイルを <filename>/etc/cron.d</filename> ディレクトリに置くことが可能です。最後の 2 つの解決策には、コマンドを実行するユーザを明示できるという利点があります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <emphasis>cron</emphasis> package includes by default some scheduled commands that execute:"
msgstr "デフォルトで <emphasis>cron</emphasis> パッケージには、いくつかのスケジュール済みコマンドが含まれています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "programs in the <filename>/etc/cron.hourly/</filename> directory once per hour;"
msgstr "<filename>/etc/cron.hourly/</filename> ディレクトリ内のプログラムは 1 時間に 1 回実行されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "programs in <filename>/etc/cron.daily/</filename> once per day;"
msgstr "<filename>/etc/cron.daily/</filename> ディレクトリ内のプログラムは 1 日に 1 回実行されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "programs in <filename>/etc/cron.weekly/</filename> once per week;"
msgstr "<filename>/etc/cron.weekly/</filename> ディレクトリ内のプログラムは 1 週間に 1 回実行されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "programs in <filename>/etc/cron.monthly/</filename> once per month."
msgstr "<filename>/etc/cron.monthly/</filename> ディレクトリ内のプログラムは 1 カ月に 1 回実行されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Many Debian packages rely on this service: by putting maintenance scripts in these directories, they ensure optimal operation of their services."
msgstr "多くの Debian パッケージは cron のサービスに頼っています。すなわち、メンテナンススクリプトをこれらのディレクトリに入れて、サービスの最適な動作を保証しています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Format of a <filename>crontab</filename> File"
msgstr "<filename>crontab</filename> ファイルの書式"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><filename>crontab</filename></primary>"
msgstr "<primary><filename>crontab</filename></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>TIP</emphasis> Text shortcuts for <command>cron</command>"
msgstr "<emphasis>TIP</emphasis> <command>cron</command> のテキストショートカット"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<command>cron</command> recognizes some abbreviations which replace the first five fields in a <filename>crontab</filename> entry. They correspond to the most classic scheduling options:"
msgstr "<command>cron</command> はいくつかの略語を認識します。略語は <filename>crontab</filename> エントリの最初の 5 つのフィールドを置き換えます。略語は最も古典的なスケジューリングオプションに対応します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>@yearly</literal>: once per year (January 1, at 00:00);"
msgstr "<literal>@yearly</literal>。この略語は 1 年に 1 回 (1 月 1 日の 00:00) を意味しています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>@monthly</literal>: once per month (the 1st of the month, at 00:00);"
msgstr "<literal>@monthly</literal>。この略語は 1 カ月に 1 回 (毎月 1 日の 00:00) を意味しています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>@weekly</literal>: once per week (Sunday at 00:00);"
msgstr "<literal>@weekly</literal>。この略語は 1 週間に 1 回 (日曜日の 00:00) を意味しています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>@daily</literal>: once per day (at 00:00);"
msgstr "<literal>@daily</literal>。この略語は 1 日 1 回 (00:00) を意味しています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>@hourly</literal>: once per hour (at the beginning of each hour)."
msgstr "<literal>@hourly</literal>。この略語は 1 時間に 1 回 (毎時 0 分) を意味しています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>SPECIAL CASE</emphasis> <command>cron</command> and daylight savings time"
msgstr "<emphasis>SPECIAL CASE</emphasis> <command>cron</command> と夏時間"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "In Debian, <command>cron</command> takes the time change (for Daylight Savings Time, or in fact for any significant change in the local time) into account as best as it can. Thus, the commands that should have been executed during an hour that never existed (for example, tasks scheduled at 2:30 am during the Spring time change in France, since at 2:00 am the clock jumps directly to 3:00 am) are executed shortly after the time change (thus around 3:00 am DST). On the other hand, in autumn, when commands would be executed several times (2:30 am DST, then an hour later at 2:30 am standard time, since at 3:00 am DST the clock turns back to 2:00 am) are only executed once."
msgstr "Debian では、<command>cron</command> は可能な限り正確に時刻変化 (夏時間、実質的にはローカル時間の大幅な変更) に追従します。このため、決して存在しない 1 時間内に実行されるべきコマンド (たとえば、フランスで夏時間開始日の午前 2:30 に予定されているタスクです。夏時間に切り替わると標準時の午前 2:00 は夏時間の午後 3:00 になります) は時刻が変わった後すぐに実行されます (つまり夏時間で午前 3:00 頃に実行されます)。一方で、夏時間終了日に複数回実行されると思われるコマンド (夏時間の午前 2:30 とその 1 時間後の標準時の午前 2:30 に予定されているコマンド。標準時に戻ると夏時間の午前 3:00 は標準時の午前 2:00 になります) は 1 回だけ実行されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Be careful, however, if the order in which the different scheduled tasks and the delay between their respective executions matters, you should check the compatibility of these constraints with <command>cron</command>'s behavior; if necessary, you can prepare a special schedule for the two problematic nights per year."
msgstr "しかしながら気を付けてください、別にスケジュールされたタスクとの順番とそれぞれのタスク実行間の遅延が重要な問題の場合、それらの制約の互換性と <command>cron</command> の挙動を照合するべきです。必要ならば、夏時間開始日と夏時間終了日の夜専用の特別なスケジュールを用意することも可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Each significant line of a <emphasis>crontab</emphasis> describes a scheduled command with the six (or seven) following fields:"
msgstr "<emphasis>crontab</emphasis> の有効な各行は以下の 6 つ (または 7 つ) のフィールドを含むスケジュールされたコマンド表します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "the value for the minute (number from 0 to 59);"
msgstr "分 (0 から 59 までの数字を指定します)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "the value for the hour (from 0 to 23);"
msgstr "時間 (0 から 23 までの数字を指定します)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "the value for the day of the month (from 1 to 31);"
msgstr "月の日付 (1 から 31 までの数字を指定します)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "the value for the month (from 1 to 12);"
msgstr "月 (1 から 12 までの数字を指定します)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "the value for the day of the week (from 0 to 7, 1 corresponding to Monday, Sunday being represented by both 0 and 7; it is also possible to use the first three letters of the name of the day of the week in English, such as <literal>Sun</literal>, <literal>Mon</literal>, etc.);"
msgstr "曜日 (0 から 7 までの数字、月曜日は 1、日曜日は 0 と 7 の両方、さらに英語で書いた曜日の最初の 3 文字 <literal>Sun</literal>、<literal>Mon</literal> などを使うことも可能です)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "the user name under whose identity the command must be executed (in the <filename>/etc/crontab</filename> file and in the fragments located in <filename>/etc/cron.d/</filename>, but not in the users' own crontab files);"
msgstr "コマンドを実行するユーザ名 (<filename>/etc/crontab</filename> ファイルと <filename>/etc/cron.d/</filename> にある分割されたファイルでは必要ですが、各ユーザ専用のファイルでは不要です)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "the command to execute (when the conditions defined by the first five columns are met)."
msgstr "実行するコマンド (最初の 5 つのフィールドで定義された条件が満足されたら実行します)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "All these details are documented in the <citerefentry><refentrytitle>crontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry> man page."
msgstr "すべての詳細は <citerefentry><refentrytitle>crontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry> man ページに書かれています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Each value can be expressed in the form of a list of possible values (separated by commas). The syntax <literal>a-b</literal> describes the interval of all the values between <literal>a</literal> and <literal>b</literal>. The syntax <literal>a-b/c</literal> describes the interval with an increment of <literal>c</literal> (example: <literal>0-10/2</literal> means <literal>0,2,4,6,8,10</literal>). An asterisk <literal>*</literal> is a wildcard, representing all possible values."
msgstr "各値は設定できる値の (コンマ区切り) リストの形で表現することが可能です。<literal>a-b</literal> 構文は <literal>a</literal> と <literal>b</literal> の間にあるすべての値を表現します。<literal>a-b/c</literal> 構文は <literal>a</literal> から <literal>c</literal> ずつ増加させて <literal>b</literal> までのすべての値を表現します (たとえば <literal>0-10/2</literal> は <literal>0,2,4,6,8,10</literal> を意味します)。アスタリスク <literal>*</literal> はワイルドカードで、とり得るすべての値を意味します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Sample <filename>crontab</filename> file"
msgstr "単純な <filename>crontab</filename> ファイル"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"#Format\n"
"#min hour day mon dow  command\n"
"\n"
"# Download data every night at 7:25 pm\n"
" 25  19   *   *   *    $HOME/bin/get.pl\n"
"\n"
"# 8:00 am, on weekdays (Monday through Friday)\n"
" 00  08   *   *   1-5  $HOME/bin/dosomething\n"
"\n"
"# Restart the IRC proxy after each reboot\n"
"@reboot /usr/bin/dircproxy"
msgstr ""
"#フォーマット\n"
"#分 時 日付 月 曜日  コマンド\n"
"\n"
"# 毎日深夜午前 7 時 25 分にデータをダウンロード\n"
" 25  19   *   *   *    $HOME/bin/get.pl\n"
"\n"
"# 平日 (月曜日から金曜日) 午前 8 時 0 分\n"
" 00  08   *   *   1-5  $HOME/bin/dosomething\n"
"\n"
"# 起動直後に IRC プロキシを再始動\n"
"@reboot /usr/bin/dircproxy"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>TIP</emphasis> Executing a command on boot"
msgstr "<emphasis>TIP</emphasis> 起動時にコマンドを実行"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "To execute a command a single time, just after booting the computer, you can use the <literal>@reboot</literal> macro (a simple restart of <command>cron</command> does not trigger a command scheduled with <literal>@reboot</literal>). This macro replaces the first five fields of an entry in the <emphasis>crontab</emphasis>."
msgstr "コンピュータを起動した後に毎回コマンドを実行するためには、<literal>@reboot</literal> マクロを使ってください (<command>cron</command> を単純に再起動しただけでは <literal>@reboot</literal> でスケジュールされたコマンドは実行されません)。<literal>@reboot</literal> マクロを使うには <emphasis>crontab</emphasis> 内の最初の 5 つのフィールドを <literal>@reboot</literal> で置換してください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>ALTERNATIVE</emphasis> Emulating <command>cron</command> with <command>systemd</command>"
msgstr "<emphasis>ALTERNATIVE</emphasis> <command>systemd</command> を使った <command>cron</command> のエミュレート"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "It is possible to emulate part of <command>cron</command>'s behaviour with <command>systemd</command>'s timer mechanism (see <xref linkend=\"sect.systemd\" />)."
msgstr "<command>systemd</command> のタイマメカニズムを使えば <command>cron</command> の挙動の一部をエミュレートすることが可能です (<xref linkend=\"sect.systemd\" />を参照してください)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Using the <command>at</command> Command"
msgstr "<command>at</command> コマンドの利用"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>at</command></primary>"
msgstr "<primary><command>at</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <command>at</command> executes a command at a specified moment in the future. It takes the desired time and date as command-line parameters, and the command to be executed in its standard input. The command will be executed as if it had been entered in the current shell. <command>at</command> even takes care to retain the current environment, in order to reproduce the same conditions when it executes the command. The time is indicated by following the usual conventions: <literal>16:12</literal> or <literal>4:12pm</literal> represents 4:12 pm. The date can be specified in several European and Western formats, including <literal>DD.MM.YY</literal> (<literal>27.07.15</literal> thus representing 27 July 2015), <literal>YYYY-MM-DD</literal> (this same date being expressed as <literal>2015-07-27</literal>), <literal>MM/DD/[CC]YY</literal> (ie., <literal>12/25/15</literal> or <literal>12/25/2015</literal> will be December 25, 2015), or simple <literal>MMDD[CC]YY</literal> (so that <literal>122515</literal> or <literal>12252015</literal> will, likewise, represent December 25, 2015). Without it, the command will be executed as soon as the clock reaches the time indicated (the same day, or tomorrow if that time has already passed on the same day). You can also simply write “today” or “tomorrow”, which is self-explanatory."
msgstr "<command>at</command> は未来の特定の時点にコマンドを実行します。<command>at</command> は時刻と日付をコマンドラインパラメータで受け取り、実行するコマンドを標準入力で受け取ります。<command>at</command> を使って実行予約を登録したコマンドはあたかも <command>at</command> を実行した現在のシェルで実行されたかのように実行されます。<command>at</command> はコマンドを実行する際に現在と同じ状況を再現するために、現在の環境を保存するように気を付けます。時刻は以下のように普通の慣例に従って表現されます。すなわち <literal>16:12</literal> または <literal>4:12pm</literal> は午後 4 時 12 分を意味します。日付はヨーロッパと西洋で使われるいくつかの書式で指定します。<literal>DD.MM.YY</literal> (<literal>27.07.15</literal> は 2015 年 7 月 27 日を意味します)、<literal>YYYY-MM-DD</literal> (<literal>2015-07-27</literal> は上と同じ日付を意味します)、<literal>MM/DD/[CC]YY</literal> (<literal>12/25/15</literal> や <literal>12/25/2015</literal> は 2015 年 12 月 25 日を意味します)、または単純な <literal>MMDD[CC]YY</literal> (<literal>122515</literal> や <literal>12252015</literal> は同様に 2015 年 12 月 25 日を意味します) などです。日付の指定がなければ、コマンドは最も早く到達した指定時刻に実行されます (当日、または指定時刻が既に過ぎていれば明日に実行されます)。読んで字の通り「today」(今日)、「tomorrow」(明日) などと簡単に書くことも可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: L-CFMD;
msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>at 09:00 27.07.15 &lt;&lt;END</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>echo \"Don't forget to wish a Happy Birthday to Raphaël!\" \\</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>  | mail lolando@debian.org</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>END</userinput>\n"
"<computeroutput>warning: commands will be executed using /bin/sh\n"
"job 31 at Mon Jul 27 09:00:00 2015</computeroutput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>at 09:00 27.07.15 &lt;&lt;END</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>echo \"Don't forget to wish a Happy Birthday to Raphaël!\" \\</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>  | mail lolando@debian.org</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>END</userinput>\n"
"<computeroutput>warning: commands will be executed using /bin/sh\n"
"job 31 at Mon Jul 27 09:00:00 2015</computeroutput>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "An alternative syntax postpones the execution for a given duration: <command>at now + <replaceable>number</replaceable> <replaceable>period</replaceable></command>. The <replaceable>period</replaceable> can be <literal>minutes</literal>, <literal>hours</literal>, <literal>days</literal>, or <literal>weeks</literal>. The <replaceable>number</replaceable> simply indicates the number of said units that must elapse before execution of the command."
msgstr "与えられた期間だけ実行を先延ばしにする構文もあります。たとえば <command>at now + <replaceable>number</replaceable> <replaceable>period</replaceable></command> です。<replaceable>period</replaceable> には <literal>minutes</literal>、<literal>hours</literal>、<literal>days</literal>、<literal>weeks</literal> を指定することが可能です。<replaceable>number</replaceable> は単純に <replaceable>period</replaceable> で指定した単位の量を表し、この量だけコマンドの実行が先延ばしされます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "To cancel a task scheduled by <command>cron</command>, simply run <command>crontab -e</command> and delete the corresponding line in the <emphasis>crontab</emphasis> file. For <command>at</command> tasks, it is almost as easy: run <command>atrm <replaceable>task-number</replaceable></command>. The task number is indicated by the <command>at</command> command when you scheduled it, but you can find it again with the <command>atq</command> command, which gives the current list of scheduled tasks."
msgstr "<command>cron</command> でスケジュールされたタスクを中止するには、単純に <command>crontab -e</command> を実行し、<emphasis>crontab</emphasis> ファイルから対応する行を削除してください。<command>at</command> タスクの場合、削除はとても簡単です。すなわち <command>atrm <replaceable>task-number</replaceable></command> を実行してください。タスク番号は <command>at</command> コマンドで予定を登録した際に表示されたものです。改めて確認するには <command>atq</command> コマンドを実行してください。これはスケジュールされたタスクの現在のリストを表示します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>atrm</command></primary>"
msgstr "<primary><command>atrm</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>atq</command></primary>"
msgstr "<primary><command>atq</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Scheduling Asynchronous Tasks: <command>anacron</command>"
msgstr "非同期タスクのスケジューリング、<command>anacron</command>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<command>anacron</command> is the daemon that completes <command>cron</command> for computers that are not on at all times. Since regular tasks are usually scheduled for the middle of the night, they will never be executed if the computer is off at that time. The purpose of <command>anacron</command> is to execute them, taking into account periods in which the computer is not working."
msgstr "<command>anacron</command> はデーモンで、常に起動されていないコンピュータの <command>cron</command> を完成させるものです。定期的なタスクは通常真夜中に予定されているため、その時間にコンピュータの電源が切れていればタスクは決して実行されません。<command>anacron</command> の目的は、コンピュータの電源が切れている期間を考慮して、その期間中に予定されていたタスクを実行することです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>anacron</command></primary>"
msgstr "<primary><command>anacron</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Please note that <command>anacron</command> will frequently execute such activity a few minutes after booting the machine, which can render the computer less responsive. This is why the tasks in the <filename>/etc/anacrontab</filename> file are started with the <command>nice</command> command, which reduces their execution priority and thus limits their impact on the rest of the system. Beware, the format of this file is not the same as that of <filename>/etc/crontab</filename>; if you have particular needs for <command>anacron</command>, see the <citerefentry><refentrytitle>anacrontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry> manual page."
msgstr "<command>anacron</command> は通常そのようなタスクをマシンの起動数分後に実行します。このことにより、コンピュータの反応が遅くなります。このため、<filename>/etc/anacrontab</filename> ファイルに載せられたタスクは <command>nice</command> コマンドと一緒に開始されます。こうすることで、タスクの優先度を低くして実行できるので、システムの残りの部分に対する影響を減らすことが可能です。<filename>/etc/anacrontab</filename> ファイルの書式は <filename>/etc/crontab</filename> と異なる点に注意してください。さらに <command>anacron</command> を使う特別な理由がある場合、<citerefentry><refentrytitle>anacrontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry> マニュアルページをご覧ください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> Priorities and <command>nice</command>"
msgstr "<emphasis>BACK TO BASICS</emphasis> 実行優先度と <command>nice</command>"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: PTAL;
msgid "Unix systems (and thus Linux) are multi-tasking and multi-user systems. Indeed, several processes can run in parallel, and be owned by different users: the kernel mediates access to the resources between the different processes. As a part of this task, it has a concept of priority, which allows it to favor certain processes over others, as needed. When you know that a process can run in low priority, you can indicate so by running it with <command>nice <replaceable>program</replaceable></command>. The program will then have a smaller share of the CPU, and will have a smaller impact on other running processes. Of course, if no other processes needs to run, the program will not be artificially held back."
msgstr "Unix システム (および Linux) はマルチタスクのマルチユーザシステムです。実際、複数のプロセスは平行して実行され別のユーザに所有されます。そして、カーネルは異なるプロセス間でリソースへのアクセスを仲介します。このタスクの一部として、カーネルは実行優先度という概念を持ちます。実行優先度に基づき、カーネルは必要に応じてあるプロセスを特別扱いします。あるプログラムを低い優先度で実行しても構わないと分かっている場合、そのプログラムに低い優先度を与えて実行を開始するには <command>nice <replaceable>program</replaceable></command> を使います。<command>nice</command> を使って実行を開始されたプログラムは CPU への負担を低く設定され、他の実行中プロセスに対する影響を低く抑えられるでしょう。もちろん、他に実行中のプロセスがない場合、このプログラムの実行は妨げられません。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: $ man 1 nice;
# Ref: $ man 2 nice;
msgid "<command>nice</command> works with levels of “niceness”: the positive levels (from 1 to 19) progressively lower the priority, while the negative levels (from -1 to -20) will increase it — but only root can use these negative levels. Unless otherwise indicated (see the <citerefentry><refentrytitle>nice</refentrytitle> <manvolnum>1</manvolnum></citerefentry> manual page), <command>nice</command> increases the current level by 10."
msgstr "<command>nice</command> は「niceness」と呼ばれる優先度と連動します。ここで正の優先度 (1 から 19) は低い優先度、これに対して、負の優先度 (-1 から -20) は高い優先度を意味します。負の (高い) 優先度を使えるのは root だけです。「niceness」を与えなければ (<citerefentry><refentrytitle>nice</refentrytitle> <manvolnum>1</manvolnum></citerefentry> マニュアルページを参照してください)、<command>nice</command> は現在の優先度を正方向に 10 だけ増加します (優先度を下げます)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "If you discover that an already running task should have been started with <command>nice</command> it is not too late to fix it; the <command>renice</command> command changes the priority of an already running process, in either direction (but reducing the “niceness” of a process is reserved for the root user)."
msgstr "既に実行中のタスクの中に <command>nice</command> で開始するべきプロセスを発見した場合、今からでも優先度を修正することが可能です。<command>renice</command> コマンドは実行中のプロセスの優先度を変更します。優先度を低くすることも高くすることも可能です (ただし、「niceness」を減らす (優先度を高くする) ことができるのは root だけです)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Installation of the <emphasis role=\"pkg\">anacron</emphasis> package deactivates execution by <command>cron</command> of the scripts in the <filename>/etc/cron.hourly/</filename>, <filename>/etc/cron.daily/</filename>, <filename>/etc/cron.weekly/</filename>, and <filename>/etc/cron.monthly/</filename> directories. This avoids their double execution by <command>anacron</command> and <command>cron</command>. The <command>cron</command> command remains active and will continue to handle the other scheduled tasks (especially those scheduled by users)."
msgstr "<emphasis role=\"pkg\">anacron</emphasis> パッケージをインストールすることにより、<command>cron</command> は <filename>/etc/cron.hourly/</filename>、<filename>/etc/cron.daily/</filename>、<filename>/etc/cron.weekly/</filename>、<filename>/etc/cron.monthly/</filename> ディレクトリに含まれるスクリプトを実行しなくなります。これは <command>anacron</command> と <command>cron</command> がスクリプトを二重に実行することを避けるためです。<command>cron</command> コマンドはまだ有効で、他のスケジュールされたタスク (特にユーザがスケジュールしたタスク) を取り扱うことが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Quotas"
msgstr "クォータ"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>quota</primary>"
msgstr "<primary>クォータ</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The quota system allows limiting disk space allocated to a user or group of users. To set it up, you must have a kernel that supports it (compiled with the <varname>CONFIG_QUOTA</varname> option) — as is the case with Debian kernels. The quota management software is found in the <emphasis role=\"pkg\">quota</emphasis> Debian package."
msgstr "クォータシステムを使うことで、ユーザまたはユーザグループに割り当てられたディスク領域を制限することが可能です。クォータを設定するには、クォータをサポートする (<varname>CONFIG_QUOTA</varname> オプションを有効化してコンパイルされた) カーネルを使わなければいけません。Debian カーネルはクォータをサポートしています。クォータ管理ソフトウェアは <emphasis role=\"pkg\">quota</emphasis> Debian パッケージに含まれています。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: https://www.centos.org/docs/5/html/Deployment_Guide-en-US/ch-disk-quotas.html;
msgid "To activate quota in a filesystem, you have to indicate the <literal>usrquota</literal> and <literal>grpquota</literal> options in <filename>/etc/fstab</filename> for the user and group quotas, respectively. Rebooting the computer will then update the quotas in the absence of disk activity (a necessary condition for proper accounting of already used disk space)."
msgstr "あるファイルシステムでクォータを有効化するには、<filename>/etc/fstab</filename> の中で <literal>usrquota</literal> (ユーザ用クォータ) および <literal>grpquota</literal> (グループ用クォータ) オプションを指定します。この後コンピュータを再起動すると、ディスク活動のない時にクォータが更新されます (これは使用済みディスク領域を適切に計量する必要条件です)。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: http://linux.die.net/man/8/edquota;
msgid "The <command>edquota <replaceable>user</replaceable></command> (or <command>edquota -g <replaceable>group</replaceable></command>) command allows you to change the limits while examining current disk space usage."
msgstr "<command>edquota <replaceable>user</replaceable></command> (または <command>edquota -g <replaceable>group</replaceable></command>) コマンドを使うと、現在のディスク領域使用量を検査している最中に、制限を変更することが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>edquota</command></primary>"
msgstr "<primary><command>edquota</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>GOING FURTHER</emphasis> Defining quotas with a script"
msgstr "<emphasis>GOING FURTHER</emphasis> スクリプトを使ったクォータの定義"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>setquota</command></primary>"
msgstr "<primary><command>setquota</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <command>setquota</command> program can be used in a script to automatically change many quotas. Its <citerefentry><refentrytitle>setquota</refentrytitle> <manvolnum>8</manvolnum></citerefentry> manual page details the syntax to use."
msgstr "<command>setquota</command> プログラムを使うことで、スクリプトの中で自動的に多くのクォータを変更することが可能です。構文の使い方は <citerefentry><refentrytitle>setquota</refentrytitle> <manvolnum>8</manvolnum></citerefentry> マニュアルページをご覧ください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The quota system allows you to set four limits:"
msgstr "クォータシステムを使うと以下の 4 種類の制限を設定することが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "two limits (called “soft” and “hard”) refer to the number of blocks consumed. If the filesystem was created with a block-size of 1 kibibyte, a block contains 1024 bytes from the same file. Unsaturated blocks thus induce losses of disk space. A quota of 100 blocks, which theoretically allows storage of 102,400 bytes, will however be saturated with just 100 files of 500 bytes each, only representing 50,000 bytes in total."
msgstr "消費ブロック数に対する 2 種類の制限 (「ソフト」と「ハード」と呼ばれます)。もしファイルシステムが 1 キロバイトのブロックサイズで作られた場合、1 ブロックには、あるファイルの 1024 バイト分を入れることが可能です。飽和していないブロックがあると、ディスク領域の損失が生じます。100 ブロックのクォータは理論的には 102,400 バイトを保存できることを意味しますが、500 バイトのファイル 100 個 (合計 50,000 バイト) で上限に達することになります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "two limits (soft and hard) refer to the number of inodes used. Each file occupies at least one inode to store information about it (permissions, owner, timestamp of last access, etc.). It is thus a limit on the number of user files."
msgstr "i ノード数に対する 2 種類の制限 (ソフトとハード)。各ファイルはファイルの情報 (パーミッション、所有者、最後にアクセスされた時間、など) を保存するために少なくとも 1 つの i ノードを専有します。この性質を使うことで、ユーザファイルの数を制限することが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "A “soft” limit can be temporarily exceeded; the user will simply be warned that they are exceeding the quota by the <command>warnquota</command> command, which is usually invoked by <command>cron</command>. A “hard” limit can never be exceeded: the system will refuse any operation that will cause a hard quota to be exceeded."
msgstr "「ソフト」リミットは一時的に超過できます。しかし、ユーザは <command>warnquota</command> コマンドからクォータを超過していることに対して簡単な警告を受けます。<command>warnquota</command> コマンドは通常 <command>cron</command> コマンドによって呼び出されます。「ハード」リミットは決して超過できません。すなわち、システムはハードクォータを超過するような操作をすべて拒否します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>VOCABULARY</emphasis> Blocks and inodes"
msgstr "<emphasis>VOCABULARY</emphasis> ブロックと i ノード"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>block (disk)</primary>"
msgstr "<primary>ブロック (ディスク)</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>inode</primary>"
msgstr "<primary>i ノード</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The filesystem divides the hard drive into blocks — small contiguous areas. The size of these blocks is defined during creation of the filesystem, and generally varies between 1 and 8 kibibytes."
msgstr "ファイルシステムはハードドライブをブロック (小さく連続した領域) に分割します。ブロックのサイズはファイルシステムの作成時に定義され、一般的に 1 から 8 キロバイトまでの範囲を取ります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "A block can be used either to store the real data of a file, or for meta-data used by the filesystem. Among this meta-data, you will especially find the inodes. An inode uses a block on the hard drive (but this block is not taken into consideration in the block quota, only in the inode quota), and contains both the information on the file to which it corresponds (name, owner, permissions, etc.) and the pointers to the data blocks that are actually used. For very large files that occupy more blocks than it is possible to reference in a single inode, there is an indirect block system; the inode references a list of blocks that do not directly contain data, but another list of blocks."
msgstr "ブロックはファイルの実データまたはファイルシステムが使うメタデータのどちらか一方を保存するために使われます。メタデータの中でも特に、i ノードについて説明します。1 つの i ノードはハードドライブ上の 1 ブロックを使い (i ノードを保存するブロックはブロッククォータに考慮されず、i ノードクォータだけに考慮されます)、その i ノードに対応するファイルの情報 (名前、所有者、パーミッション、など) と実際に使われるデータブロックへのポインタ情報の両方を含みます。単一の i ノードで対応できないくらい多くのブロックを専有するとても大きなファイルのために、間接ブロックシステムがあります。この場合の i ノードは、実データではなく別のブロックのリストを保存しているブロックのリストを参照します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>warnquota</command></primary>"
msgstr "<primary><command>warnquota</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "With the <command>edquota -t</command> command, you can define a maximum authorized “grace period” within which a soft limit may be exceeded. After this period, the soft limit will be treated like a hard limit, and the user will have to reduce their disk space usage to within this limit in order to be able to write anything to the hard drive."
msgstr "<command>edquota -t</command> コマンドを使えば、ソフトリミットの超過を許す「猶予期間」の最長値を定義することが可能です。この期間の後、ソフトリミットはハードリミットと同様に扱われます。ユーザがハードドライブに何かを書き込むには、ディスク領域の使用量を減らしてクォータの制限内に収めなければいけません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>GOING FURTHER</emphasis> Setting up a default quota for new users"
msgstr "<emphasis>GOING FURTHER</emphasis> 新規ユーザのデフォルトクォータを設定する"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: PTAL;
msgid "To automatically setup a quota for new users, you have to configure a template user (with <command>edquota</command> or <command>setquota</command>) and indicate their user name in the <varname>QUOTAUSER</varname> variable in the <filename>/etc/adduser.conf</filename> file. This quota configuration will then be automatically applied to each new user created with the <command>adduser</command> command."
msgstr "新規ユーザ向けにクォータを自動設定するには、(<command>edquota</command> または <command>setquota</command> を使って) テンプレートユーザに対してクォータを設定し、<filename>/etc/adduser.conf</filename> ファイルの <varname>QUOTAUSER</varname> 変数にテンプレートユーザの名前をいれなければいけません。この後 <command>adduser</command> コマンドを使って新規ユーザを作成すれば、テンプレートユーザと同じクォータ設定が自動的に適用されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Making backups is one of the main responsibilities of any administrator, but it is a complex subject, involving powerful tools which are often difficult to master."
msgstr "バックアップを取ることは管理者の主要な責任の 1 つです。しかし、これは通常極めるのが難しい強力なツールを使う複雑な問題です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>backup</primary>"
msgstr "<primary>バックアップ</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>restoration</primary>"
msgstr "<primary>復元</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Many programs exist, such as <command>amanda</command>, <command>bacula</command>, <command>BackupPC</command>. Those are client/server system featuring many options, whose configuration is rather difficult. Some of them provide user-friendly web interfaces to mitigate this. But Debian contains dozens of other backup software covering all possible use cases, as you can easily confirm with <command>apt-cache search backup</command>."
msgstr "バックアップ作業に関して言えば <command>amanda</command>、<command>bacula</command>、<command>BackupPC</command> などの多くのプログラムが存在します。これらは多くの機能を備えるクライアント/サーバシステムで、その設定はかなり難しいです。いくつかのプログラムは難しさを和らげるためのユーザフレンドリーなウェブインターフェースを提供しています。しかし Debian には、すべての考え得る使用事例に対応できる、他の数多くのバックアップソフトウェアが含まれています。ソフトウェアを確認するには <command>apt-cache search backup</command> を使ってください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>amanda</command></primary>"
msgstr "<primary><command>amanda</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>bacula</command></primary>"
msgstr "<primary><command>bacula</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>BackupPC</command></primary>"
msgstr "<primary><command>BackupPC</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Rather than detailing some of them, this section will present the thoughts of the Falcot Corp administrators when they defined their backup strategy."
msgstr "この節ではプログラムの使い方を詳細に説明するのではなく、Falcot Corp の管理者がバックアップ戦略を定義する際にどのように考えたかを説明します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "At Falcot Corp, backups have two goals: recovering erroneously deleted files, and quickly restoring any computer (server or desktop) whose hard drive has failed."
msgstr "Falcot Corp では、バックアップには 2 つの目標があります。具体的に言えば、誤って削除したファイルを回復することと、ハードドライブに障害が起きた際にコンピュータ (サーバおよびデスクトップ) を素早く復元することです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Backing Up with <command>rsync</command>"
msgstr "<command>rsync</command> を使ったバックアップ"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Backups on tape having been deemed too slow and costly, data will be backed up on hard drives on a dedicated server, on which the use of software RAID (see <xref linkend=\"sect.raid-soft\" />) will protect the data from hard drive failure. Desktop computers are not backed up individually, but users are advised that their personal account on their department's file server will be backed up. The <command>rsync</command> command (from the package of the same name) is used daily to back up these different servers."
msgstr "テープへのバックアップは遅くて費用がかかりすぎるとみなされ、データは専用サーバのハードドライブにバックアップされることになりました。専用サーバはソフトウェア RAID (<xref linkend=\"sect.raid-soft\" />を参照してください) を使ってデータをハードウェア障害から守っています。デスクトップコンピュータは個別にバックアップされませんが、ユーザは部署のファイルサーバの個人アカウントはバックアップされると知らされています。毎日異なるサーバにバックアップを行う目的で、<command>rsync</command> コマンド (同名のパッケージに含まれます) が使われています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>rsync</command></primary>"
msgstr "<primary><command>rsync</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> The hard link, a second name for the file"
msgstr "<emphasis>BACK TO BASICS</emphasis> ハードリンク、ファイルの別名"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>link</primary><secondary>hard link</secondary>"
msgstr "<primary>リンク</primary><secondary>ハードリンク</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>hard link</primary>"
msgstr "<primary>ハードリンク</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "A hard link, as opposed to a symbolic link, cannot be differentiated from the linked file. Creating a hard link is essentially the same as giving an existing file a second name. This is why the deletion of a hard link only removes one of the names associated with the file. As long as another name is still assigned to the file, the data therein remain present on the filesystem. It is interesting to note that, unlike a copy, the hard link does not take up additional space on the hard drive."
msgstr "ハードリンクはシンボリックリンクと異なり、リンクされたファイルと区別できません。本質的に、ハードリンクの作成は既存のファイルに別名を与えることと同義です。そのため、ハードリンクの削除はそのファイルに関連する名前を削除するに過ぎません。他の名前がまだそのファイルに関連付けられている場合、データの実体はファイルシステムから削除されません。コピーと異なり、ハードリンクはハードドライブ上に追加的な領域を必要としない点について注意することは興味深いです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "A hard link is created with the <command>ln <replaceable>target</replaceable> <replaceable>link</replaceable></command> command. The <replaceable>link</replaceable> file is then a new name for the <replaceable>target</replaceable> file. Hard links can only be created on the same filesystem, while symbolic links are not subject to this limitation."
msgstr "ハードリンクは <command>ln <replaceable>target</replaceable> <replaceable>link</replaceable></command> コマンドで作成されます。ここで <replaceable>link</replaceable> ファイルは <replaceable>target</replaceable> ファイルの新しい名前です。ハードリンクは <replaceable>target</replaceable> と <replaceable>link</replaceable> が同じファイルシステム上にある場合に限り作成できます。対してシンボリックリンクはこの制限を受けません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The available hard drive space prohibits implementation of a complete daily backup. As such, the <command>rsync</command> command is preceded by a duplication of the content of the previous backup with hard links, which prevents usage of too much hard drive space. The <command>rsync</command> process then only replaces files that have been modified since the last backup. With this mechanism a great number of backups can be kept in a small amount of space. Since all backups are immediately available and accessible (for example, in different directories of a given share on the network), you can quickly make comparisons between two given dates."
msgstr "利用できるハードドライブの空き領域によっては、完全な日次バックアップができない場合があります。このため、まず <command>rsync</command> コマンドは今回のバックアップの内容を前回のバックアップの内容へのハードリンクの形で複製します。このおかげで、ハードドライブ領域を無駄に消費することがなくなります。そして <command>rsync</command> プロセスは前回のバックアップ以降に変更されたファイルだけを置き換えていきます。このメカニズムにより、多くのバックアップを少ない領域に保存することが可能です。すべてのバックアップは即座に利用できる上に即座にアクセスできるので (たとえば、ネットワーク共有されたディレクトリの中に置かれるので)、ある日付同士の違いを素早く比較できます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>copy, backup copy</primary>"
msgstr "<primary>コピー、バックアップコピー</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>backup</primary><secondary>copy</secondary>"
msgstr "<primary>バックアップ</primary><secondary>コピー</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis role=\"pkg\">dirvish</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">dirvish</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "This backup mechanism is easily implemented with the <command>dirvish</command> program. It uses a backup storage space (“bank” in its vocabulary) in which it places timestamped copies of sets of backup files (these sets are called “vaults” in the dirvish documentation)."
msgstr "<command>dirvish</command> プログラムを使えば、このバックアップメカニズムを簡単に実現できます。<command>dirvish</command> プログラムはバックアップストレージ領域 (dirvish 用語で「bank」) を使い、「bank」の中に一連のバックアップファイルのタイムスタンプを付けたコピー (dirvish の文書ではこれらを「vault」と呼びます) を置きます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The main configuration is in the <filename>/etc/dirvish/master.conf</filename> file. It defines the location of the backup storage space, the list of “vaults” to manage, and default values for expiration of the backups. The rest of the configuration is located in the <filename><replaceable>bank</replaceable>/<replaceable>vault</replaceable>/dirvish/default.conf</filename> files and contains the specific configuration for the corresponding set of files."
msgstr "主要な設定は <filename>/etc/dirvish/master.conf</filename> ファイルに書かれています。<filename>/etc/dirvish/master.conf</filename> ファイルでは、バックアップストレージ領域の場所、管理する「vault」のリスト、バックアップの保存期限のデフォルト値を定義します。残りの設定、すなわち <replaceable>vault</replaceable> でバックアップするファイルセットに固有の設定は <filename><replaceable>bank</replaceable>/<replaceable>vault</replaceable>/dirvish/default.conf</filename> ファイルに書かれています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <filename>/etc/dirvish/master.conf</filename> file"
msgstr "<filename>/etc/dirvish/master.conf</filename> ファイル"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: http://www.dirvish.org/dirvish.conf.5.html;
msgid ""
"bank:\n"
"    /backup\n"
"exclude:\n"
"    lost+found/\n"
"    core\n"
"    *~\n"
"Runall:\n"
"    root    22:00\n"
"expire-default: +15 days\n"
"expire-rule:\n"
"#   MIN HR    DOM MON       DOW  STRFTIME_FMT\n"
"    *   *     *   *         1    +3 months\n"
"    *   *     1-7 *         1    +1 year\n"
"    *   *     1-7 1,4,7,10  1"
msgstr ""
"bank:\n"
"    /backup\n"
"exclude:\n"
"    lost+found/\n"
"    core\n"
"    *~\n"
"Runall:\n"
"    root    22:00\n"
"expire-default: +15 days\n"
"expire-rule:\n"
"#   分  時    日  月        曜日 保存期限\n"
"    *   *     *   *         1    +3 months\n"
"    *   *     1-7 *         1    +1 year\n"
"    *   *     1-7 1,4,7,10  1"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: PTAL;
msgid "The <literal>bank</literal> setting indicates the directory in which the backups are stored. The <literal>exclude</literal> setting allows you to indicate files (or file types) to exclude from the backup. The <literal>Runall</literal> is a list of file sets to backup with a time-stamp for each set, which allows you to assign the correct date to the copy, in case the backup is not triggered at precisely the assigned time. You have to indicate a time just before the actual execution time (which is, by default, 10:04 pm in Debian, according to <filename>/etc/cron.d/dirvish</filename>). Finally, the <literal>expire-default</literal> and <literal>expire-rule</literal> settings define the expiration policy for backups. The above example keeps forever backups that are generated on the first Sunday of each quarter, deletes after one year those from the first Sunday of each month, and after 3 months those from other Sundays. Other daily backups are kept for 15 days. The order of the rules does matter, Dirvish uses the last matching rule, or the <literal>expire-default</literal> one if no other <literal>expire-rule</literal> matches."
msgstr "<literal>bank</literal> 設定はバックアップが保存されるディレクトリを表します。<literal>exclude</literal> 設定を使うと、バックアップからファイル (またはファイルタイプ) を除外することが可能です。<literal>Runall</literal> はタイムスタンプを付けてバックアップするファイルセットのリストです。これにより、万が一割り当てられた時間に正確にバックアップが実行されない場合でも、バックアップコピーに正確な時刻を割り当てることが可能です。ここで指定する時刻は実際の実行時刻の直前の時刻でなければいけません (<filename>/etc/cron.d/dirvish</filename> によれば、Debian では実際の実行時間はデフォルトで午後 10 時 4 分です)。最後に <literal>expire-default</literal> と <literal>expire-rule</literal> 設定でバックアップ保存期限ポリシーを定義します。上の例は、各四半期の最初の日曜日に作成されたバックアップを永久に保存し、それに当てはまらない各月の最初の日曜日に作成されたバックアップを 1 年経過後に削除し、それに当てはまらない日曜日に作成されたバックアップを 3 カ月経過後に削除します。その他の日次バックアップは 15 日間保存されます。ルールが適用される順番が問題です。Dirvish は最後にマッチしたルールを使い、<literal>expire-rule</literal> にマッチするものがなければ <literal>expire-default</literal> を使います。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>IN PRACTICE</emphasis> Scheduled expiration"
msgstr "<emphasis>IN PRACTICE</emphasis> 削除スケジュール"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The expiration rules are not used by <command>dirvish-expire</command> to do its job. In reality, the expiration rules are applied when creating a new backup copy to define the expiration date associated with that copy. <command>dirvish-expire</command> simply peruses the stored copies and deletes those for which the expiration date has passed."
msgstr "削除を担当している <command>dirvish-expire</command> は削除ルールを使いません。削除ルールが適用されるのは新しいバックアップコピーの作成時であり、バックアップコピーを削除する日付が削除ルールによって定義されます。<command>dirvish-expire</command> は保存されたコピーを単純に調べて、期限の過ぎているコピーを削除します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <filename>/backup/root/dirvish/default.conf</filename> file"
msgstr "<filename>/backup/root/dirvish/default.conf</filename> ファイル"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"client: rivendell.falcot.com\n"
"tree: /\n"
"xdev: 1\n"
"index: gzip\n"
"image-default: %Y%m%d\n"
"exclude:\n"
"    /var/cache/apt/archives/*.deb\n"
"    /var/cache/man/**\n"
"    /tmp/**\n"
"    /var/tmp/**\n"
"    *.bak"
msgstr ""
"client: rivendell.falcot.com\n"
"tree: /\n"
"xdev: 1\n"
"index: gzip\n"
"image-default: %Y%m%d\n"
"exclude:\n"
"    /var/cache/apt/archives/*.deb\n"
"    /var/cache/man/**\n"
"    /tmp/**\n"
"    /var/tmp/**\n"
"    *.bak"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The above example specifies the set of files to back up: these are files on the machine <emphasis>rivendell.falcot.com</emphasis> (for local data backup, simply specify the name of the local machine as indicated by <command>hostname</command>), especially those in the root tree (<literal>tree: /</literal>), except those listed in <literal>exclude</literal>. The backup will be limited to the contents of one filesystem (<literal>xdev: 1</literal>). It will not include files from other mount points. An index of saved files will be generated (<literal>index: gzip</literal>), and the image will be named according to the current date (<literal>image-default: %Y%m%d</literal>)."
msgstr "上の例では、バックアップするファイルセットを指定しています。具体的に言えば、バックアップ対象は <emphasis>rivendell.falcot.com</emphasis> マシン (ローカルデータをバックアップするには、単純に <command>hostname</command> の出力するローカルマシンの名前を指定します) にあるルートツリーの内容 (<literal>tree: /</literal>) から <literal>exclude</literal> で指定したものを除外したファイルです。さらに、バックアップ対象は <literal>tree</literal> と同一のファイルシステムの内容 (<literal>xdev: 1</literal>) に制限されます。他のマウントポイントのファイルはバックアップされません。保存されたファイルのインデックス (<literal>index: gzip</literal>) が生成され、イメージには現在の日付に関連する名前 (<literal>image-default: %Y%m%d</literal>) が付けられます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "There are many options available, all documented in the <citerefentry><refentrytitle>dirvish.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry> manual page. Once these configuration files are setup, you have to initialize each file set with the <command>dirvish --vault <replaceable>vault</replaceable> --init</command> command. From there on the daily invocation of <command>dirvish-runall</command> will automatically create a new backup copy just after having deleted those that expired."
msgstr "多くのオプションがあり、すべては <citerefentry><refentrytitle>dirvish.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry> マニュアルページに書かれています。一度これらの設定ファイルを作ったら、<command>dirvish --vault <replaceable>vault</replaceable> --init</command> コマンドを使って、各ファイルセットを初期化します。ここまでが済むと、毎日の <command>dirvish-runall</command> 実行時に期限切れになったバックアップコピーが削除され、その直後に自動的に新しいバックアップコピーが作成されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>IN PRACTICE</emphasis> Remote backup over SSH"
msgstr "<emphasis>IN PRACTICE</emphasis> SSH を使ったリモートバックアップ"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "When dirvish needs to save data to a remote machine, it will use <command>ssh</command> to connect to it, and will start <command>rsync</command> as a server. This requires the root user to be able to automatically connect to it. The use of an SSH authentication key allows precisely that (see <xref linkend=\"sect.ssh-key-based-auth\" />)."
msgstr "dirvish はリモートマシンにデータをバックアップする場合、<command>ssh</command> を使ってリモートマシンに接続し、<command>rsync</command> をサーバとして開始します。この場合、root ユーザとして自動的にリモートマシンに接続できなければいけません。これを実現するには、SSH 認証鍵を使ってください (<xref linkend=\"sect.ssh-key-based-auth\" />を参照してください)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Restoring Machines without Backups"
msgstr "バックアップなしのマシンの復元"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Desktop computers, which are not backed up, will be easy to reinstall from custom DVD-ROMs prepared with <emphasis>Simple-CDD</emphasis> (see <xref linkend=\"sect.simple-cdd\" />). Since this performs an installation from scratch, it loses any customization that can have been made after the initial installation. This is fine since the systems are all hooked to a central LDAP directory for accounts and most desktop applications are preconfigured thanks to dconf (see <xref linkend=\"sect.gnome-desktop\" /> for more information about this)."
msgstr "バックアップされていないデスクトップコンピュータに対しては <emphasis>Simple-CDD</emphasis> でカスタマイズされた DVD-ROM からシステムを再インストールするのが簡単でしょう (<xref linkend=\"sect.simple-cdd\" />を参照してください)。インストールを最初からやり直すので、初回インストール後に行われたすべての設定は失われます。これは問題ではありません。なぜなら、アカウントに関して言えばシステムはすべて中央 LDAP ディレクトリの情報を参照しており、ほとんどのデスクトップアプリケーションに関して言えば dconf のおかげで事前設定されているからです (詳しい情報は<xref linkend=\"sect.gnome-desktop\" />を参照してください)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The Falcot Corp administrators are aware of the limits in their backup policy. Since they can't protect the backup server as well as a tape in a fireproof safe, they have installed it in a separate room so that a disaster such as a fire in the server room won't destroy backups along with everything else. Furthermore, they do an incremental backup on DVD-ROM once per week — only files that have been modified since the last backup are included."
msgstr "Falcot Corp の管理者は自分たちのバックアップポリシーの限界を理解しています。テープを耐火金庫に入れるかのようにバックアップサーバを保護することができないため、管理者はバックアップサーバを他のサーバと別の部屋に設置しました。そうすればサーバルームの火事などの災害が起きてもその他のサーバと一緒にバックアップも破壊されることを避けられるからです。さらに、管理者は 1 週間に 1 回 DVD-ROM に増分バックアップ (最後のバックアップ以降に修正されたファイルだけのバックアップ) をとるようにしています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>GOING FURTHER</emphasis> Backing up SQL and LDAP services"
msgstr "<emphasis>GOING FURTHER</emphasis> SQL と LDAP サービスのバックアップ"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: PTAL;
msgid "Many services (such as SQL or LDAP databases) cannot be backed up by simply copying their files (unless they are properly interrupted during creation of the backups, which is frequently problematic, since they are intended to be available at all times). As such, it is necessary to use an “export” mechanism to create a “data dump” that can be safely backed up. These are often quite large, but they compress well. To reduce the storage space required, you will only store a complete text file per week, and a <command>diff</command> each day, which is created with a command of the type <command>diff <replaceable>file_from_yesterday</replaceable> <replaceable>file_from_today</replaceable></command>. The <command>xdelta</command> program produces incremental differences from binary dumps."
msgstr "多くのサービス (SQL や LDAP データベースなど) は単純にファイルをコピーするだけではバックアップできません (それらのサービスをバックアップの作成中に適切に中断しない限りバックアップできません。サービスの中断は通常問題です。なぜなら、サービスが常に利用できることを意図されているからです)。そのような場合、安全にバックアップできる「データダンプ」を作るために「エクスポート」メカニズムを使うことが必要です。データダンプは通常サイズのとても大きいファイルですが、データダンプのサイズは圧縮によってかなり小さくなります。要求されるストレージ領域を減らすために、完全なテキストファイルを保存するのを 1 週間に 1 回、<command>diff</command> を保存するのを毎日に制限しています。差分は <command>diff <replaceable>file_from_yesterday</replaceable> <replaceable>file_from_today</replaceable></command> で生成されます。バイナリダンプから増分差分を作成するには <command>xdelta</command> プログラムを使ってください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>xdelta</command></primary>"
msgstr "<primary><command>xdelta</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>diff</command></primary>"
msgstr "<primary><command>diff</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>dump</primary>"
msgstr "<primary>ダンプ</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>CULTURE</emphasis> <emphasis>TAR</emphasis>, the standard for tape backups"
msgstr "<emphasis>CULTURE</emphasis> <emphasis>TAR</emphasis>、テープバックアップ用の標準規格"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>backup</primary><secondary>on tape</secondary>"
msgstr "<primary>バックアップ</primary><secondary>テープへの</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>tape, backup</primary>"
msgstr "<primary>テープ、バックアップ</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>TAR</primary>"
msgstr "<primary>TAR</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Historically, the simplest means of making a backup on Unix was to store a <emphasis>TAR</emphasis> archive on a tape. The <command>tar</command> command even got its name from “Tape ARchive”."
msgstr "歴史的に言って、Unix で最も簡単にバックアップを作成する手段は <emphasis>TAR</emphasis> アーカイブをテープに保存する方法でした。<command>tar</command> コマンドは「Tape ARchive」から命名されています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Hot Plugging: <emphasis>hotplug</emphasis>"
msgstr "ホットプラグ機能、<emphasis>hotplug</emphasis>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Introduction"
msgstr "前書き"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <emphasis>hotplug</emphasis> kernel subsystem dynamically handles the addition and removal of devices, by loading the appropriate drivers and by creating the corresponding device files (with the help of <command>udevd</command>). With modern hardware and virtualization, almost everything can be hotplugged: from the usual USB/PCMCIA/IEEE 1394 peripherals to SATA hard drives, but also the CPU and the memory."
msgstr "<emphasis>hotplug</emphasis> カーネルサブシステムはデバイスの追加と削除を、<command>udevd</command> の助けを借りて適切なドライバを読み込んだり関連するデバイスファイルを作成することで、動的に取り扱います。現代的なハードウェアと仮想化を使えば、ほとんどすべてのデバイスはホットプラグ対応と言ってよいでしょう。具体的に言えば、USB/PCMCIA/IEEE 1394 周辺機器から SATA ハードドライブ、さらには CPU やメモリにいたるまでのほとんどすべてがホットプラグに対応しています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The kernel has a database that associates each device ID with the required driver. This database is used during boot to load all the drivers for the peripheral devices detected on the different buses, but also when an additional hotplug device is connected. Once the device is ready for use, a message is sent to <command>udevd</command> so it will be able to create the corresponding entry in <filename>/dev/</filename>."
msgstr "カーネルは必要なドライバとデバイス ID を関連付けるデータベースを持っています。このデータベースは起動中にさまざまなバスで検出された周辺機器用のすべてのドライバを読み込んだりする際、追加的なホットプラグデバイスが接続された際に使われます。デバイスの使用準備が整ったら、メッセージが <command>udevd</command> に送信され、<command>udevd</command> は対応するエントリを <filename>/dev/</filename> 内に作成します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis>hotplug</emphasis></primary>"
msgstr "<primary><emphasis>ホットプラグ</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>hotplug</primary>"
msgstr "<primary>ホットプラグ</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>USB</primary>"
msgstr "<primary>USB</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>IEEE 1394</primary>"
msgstr "<primary>IEEE 1394</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>PCMCIA</primary>"
msgstr "<primary>PCMCIA</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>SATA</primary>"
msgstr "<primary>SATA</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The Naming Problem"
msgstr "命名問題"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Before the appearance of hotplug connections, it was easy to assign a fixed name to a device. It was based simply on the position of the devices on their respective bus. But this is not possible when such devices can come and go on the bus. The typical case is the use of a digital camera and a USB key, both of which appear to the computer as disk drives. The first one connected may be <filename>/dev/sdb</filename> and the second <filename>/dev/sdc</filename> (with <filename>/dev/sda</filename> representing the computer's own hard drive). The device name is not fixed; it depends on the order in which devices are connected."
msgstr "ホットプラグ接続の出現前、デバイスに固定された名前を割り当てることは簡単でした。名前は単純にデバイスが接続されたバスの位置を基にしていました。しかしこのやり方はデバイスが接続されるバスの位置が決まっていない場合に問題となります。典型的な例は、コンピュータがディスクドライブとして認識するデジタルカメラや USB メモリを使う場合です。最初に接続されたデバイスは <filename>/dev/sdb</filename>、2 番目に接続されたデバイスは <filename>/dev/sdc</filename> と名付けられるかもしれません (<filename>/dev/sda</filename> はコンピュータのハードドライブを表します)。デバイスに対するデバイス名は固定されませんし、デバイス名はデバイスが接続された順番に依存します。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: PTAL;
msgid "Additionally, more and more drivers use dynamic values for devices' major/minor numbers, which makes it impossible to have static entries for the given devices, since these essential characteristics may vary after a reboot."
msgstr "さらに、デバイスのメジャー/マイナー番号に動的な値を使うドライバが増えています。動的なメジャー/マイナー番号を使うことで、あるデバイスに対する静的なエントリを持つことが不可能になります。なぜなら、これらのエントリは再起動の後に変化するかもしれないからです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>udev</emphasis> was created precisely to solve this problem."
msgstr "<emphasis>udev</emphasis> はまさにこの問題を解決するために作られました。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>IN PRACTICE</emphasis> Network card management"
msgstr "<emphasis>IN PRACTICE</emphasis> ネットワークカード管理"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Many computers have multiple network cards (sometimes two wired interfaces and a wifi interface), and with <emphasis>hotplug</emphasis> support on most bus types, the Linux kernel does not guarantee fixed naming of network interfaces. But users who want to configure their network in <filename>/etc/network/interfaces</filename> need a fixed name!"
msgstr "多くのコンピュータは複数のネットワークカードを持っています (2 つの有線インターフェースと 1 つの wifi インターフェース)。そして <emphasis>hotplug</emphasis> はほとんどのバスタイプをサポートするので Linux カーネルがネットワークインターフェースに対して割り当てる名前は流動的なものになります。しかしながら、<filename>/etc/network/interfaces</filename> の中でネットワークを設定する場合、ネットワークインターフェースの名前を固定する必要があります!"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "It would be difficult to ask every user to create their own <emphasis>udev</emphasis> rules to address this problem. This is why <emphasis>udev</emphasis> was configured in a rather peculiar manner; on first boot (and, more generally, each time that a new network card appears) it uses the name of the network interface and its MAC address to create new rules that will reassign the same name on subsequent boots. These rules are stored in <filename>/etc/udev/rules.d/70-persistent-net.rules</filename>."
msgstr "この問題を解決する目的で、各ユーザに自分の <emphasis>udev</emphasis> ルールを作るようにお願いするのは難しいでしょう。そのため <emphasis>udev</emphasis> は比較的独特なやり方で設定されました。つまり、最初の起動時に (より一般的に言えば、新しいネットワークカードが初めて見つかった時に)、<emphasis>udev</emphasis> はネットワークインターフェースの名前と MAC アドレスを基にして、2 度目の起動から同じ名前を割り当てられるような新しいルールを作ります。これらのルールは <filename>/etc/udev/rules.d/70-persistent-net.rules</filename> に保存されています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "This mechanism has some side effects that you should know about. Let's consider the case of a computer that has only one PCI network card. The network interface is named <literal>eth0</literal>, logically. Now say the card breaks down, and the administrator replaces it; the new card will have a new MAC address. Since the old card was assigned the name, <literal>eth0</literal>, the new one will be assigned <literal>eth1</literal>, even though the <literal>eth0</literal> card is gone for good (and the network will not be functional because <filename>/etc/network/interfaces</filename> likely configures an <literal>eth0</literal> interface). In this case, it is enough to simply delete the <filename>/etc/udev/rules.d/70-persistent-net.rules</filename> file before rebooting the computer. The new card will then be given the expected <literal>eth0</literal> name."
msgstr "このメカニズムにはいくつかの副作用がありますので、それについて知っておくべきです。コンピュータが PCI ネットワークカードを 1 つだけ持っている場合について考えましょう。このネットワークインターフェースは必然的に <literal>eth0</literal> と名付けられます。このカードが壊れて、管理者がそれを交換したとしましょう。しかし、新しいカードは古いカードと異なる MAC アドレスを持っています。古いカードには <literal>eth0</literal> という名前が割り当てられていたため、<literal>eth0</literal> カードが完全に消え去っているにも関わらず、新しいカードには <literal>eth1</literal> という名前が割り当てられます (ネットワークは機能しません。なぜなら、<filename>/etc/network/interfaces</filename> で <literal>eth0</literal> インターフェースを設定しているからです)。この場合、コンピュータの再起動前に単純に <filename>/etc/udev/rules.d/70-persistent-net.rules</filename> ファイルを削除すれば十分です。新しいカードはおそらく <literal>eth0</literal> という名前を与えられるでしょう。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "How <emphasis>udev</emphasis> Works"
msgstr "<emphasis>udev</emphasis> の動作原理"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "When <emphasis>udev</emphasis> is notified by the kernel of the appearance of a new device, it collects various information on the given device by consulting the corresponding entries in <filename>/sys/</filename>, especially those that uniquely identify it (MAC address for a network card, serial number for some USB devices, etc.)."
msgstr "<emphasis>udev</emphasis> は新しいデバイスの出現についてカーネルから通知を受けると、<filename>/sys/</filename> 内の対応するエントリを調べて、与えられたデバイスに関するさまざまな情報 (特にデバイスを一意に識別する情報 (ネットワークカードの MAC アドレス、USB デバイスのシリアル番号など)) を収集します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Armed with all of this information, <emphasis>udev</emphasis> then consults all of the rules contained in <filename>/etc/udev/rules.d/</filename> and <filename>/lib/udev/rules.d/</filename>. In this process it decides how to name the device, what symbolic links to create (to give it alternative names), and what commands to execute. All of these files are consulted, and the rules are all evaluated sequentially (except when a file uses “GOTO” directives). Thus, there may be several rules that correspond to a given event."
msgstr "この情報を武器にして、<emphasis>udev</emphasis> は <filename>/etc/udev/rules.d/</filename> と <filename>/lib/udev/rules.d/</filename> に含まれるすべてのルールを調査します。この過程で <emphasis>udev</emphasis> はデバイスに割り当てる名前、作成するシンボリックリンクの名前 (シンボリックリンクはデバイスに別名を与えるために作成されます)、実行するコマンドを決定します。上記ディレクトリに含まれるすべてのファイルが調査され、すべてのルールが順番に評価されます (「GOTO」指示文を使う場合を除きます)。そのため、与えられたイベントに対応する複数のルールがあるかもしれません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The syntax of rules files is quite simple: each row contains selection criteria and variable assignments. The former are used to select events for which there is a need to react, and the latter defines the action to take. They are all simply separated with commas, and the operator implicitly differentiates between a selection criterion (with comparison operators, such as <literal>==</literal> or <literal>!=</literal>) or an assignment directive (with operators such as <literal>=</literal>, <literal>+=</literal> or <literal>:=</literal>)."
msgstr "ルールの構文はとても単純です。つまり各行には、選択基準と変数代入命令が含まれます。選択基準は反応を必要とするイベントを選ぶのに使われ、変数代入命令はイベントに対して行う動作を定義します。選択基準と変数代入命令は単純にコンマで区切られており、演算子を使って選択基準 (<literal>==</literal> または <literal>!=</literal> などの比較演算子を付ける) と変数代入命令 (<literal>=</literal>、<literal>+=</literal>、<literal>:=</literal> などの演算子を付ける) を暗黙のうちに区別します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Comparison operators are used on the following variables:"
msgstr "比較演算子は以下の変数に使われます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>KERNEL</literal>: the name that the kernel assigns to the device;"
msgstr "<literal>KERNEL</literal>。カーネルがデバイスに割り当てた名前を意味します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>ACTION</literal>: the action corresponding to the event (“add” when a device has been added, “remove” when it has been removed);"
msgstr "<literal>ACTION</literal>。イベントに対する動作を意味します (デバイスが追加されたら「add」で、デバイスが取り外されたら「remove」です)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>DEVPATH</literal>: the path of the device's <filename>/sys/</filename> entry;"
msgstr "<literal>DEVPATH</literal>。デバイスの <filename>/sys/</filename> エントリのパスを意味します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>SUBSYSTEM</literal>: the kernel subsystem which generated the request (there are many, but a few examples are “usb”, “ide”, “net”, “firmware”, etc.);"
msgstr "<literal>SUBSYSTEM</literal>。要求を生成したカーネルサブシステムを意味します (たくさんの種類がありますが、「usb」、「ide」、「net」、「firmware」などがその例です)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>ATTR{<replaceable>attribute</replaceable>}</literal>: file contents of the <replaceable>attribute</replaceable> file in the <filename>/sys/<replaceable>$devpath</replaceable>/</filename> directory of the device. This is where you find the MAC address and other bus specific identifiers;"
msgstr "<literal>ATTR{<replaceable>attribute</replaceable>}</literal>。デバイスの <filename>/sys/<replaceable>$devpath</replaceable>/</filename> ディレクトリ内の <replaceable>attribute</replaceable> ファイルの内容を意味します。これで MAC アドレスやその他のバス固有識別子がわかります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>KERNELS</literal>, <literal>SUBSYSTEMS</literal> and <literal>ATTRS{<replaceable>attributes</replaceable>}</literal> are variations that will try to match the different options on one of the parent devices of the current device;"
msgstr "<literal>KERNELS</literal>、<literal>SUBSYSTEMS</literal>、<literal>ATTRS{<replaceable>attributes</replaceable>}</literal>。対象のデバイスの親デバイスの 1 つに対するさまざまなオプションに対して一致を検査します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>PROGRAM</literal>: delegates the test to the indicated program (true if it returns 0, false if not). The content of the program's standard output is stored so that it can be reused by the <literal>RESULT</literal> test;"
msgstr "<literal>PROGRAM</literal>。指定されたプログラムを使ってテストを実行することを意味します (プログラムが 0 を返したら真、それ以外を返したら偽になります)。プログラムの標準出力の内容は保存され、<literal>RESULT</literal> テストによって再利用されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>RESULT</literal>: execute tests on the standard output stored during the last call to <literal>PROGRAM</literal>."
msgstr "<literal>RESULT</literal>。<literal>PROGRAM</literal> が最後に呼び出された時に保存された標準出力に対してテストを実行することを意味します。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: $ man 7 udev;
msgid "The right operands can use pattern expressions to match several values at the same time. For instance, <literal>*</literal> matches any string (even an empty one); <literal>?</literal> matches any character, and <literal>[]</literal> matches the set of characters listed between the square brackets (or the opposite thereof if the first character is an exclamation point, and contiguous ranges of characters are indicated like <literal>a-z</literal>)."
msgstr "演算子の右側引数には、複数の値に同時にマッチするようなパターン式を使うことが可能です。たとえば、<literal>*</literal> は任意の文字列に (空文字列にも) マッチします。そして <literal>?</literal> は任意の文字にマッチし、<literal>[]</literal> は角括弧の間にリストされた文字セットにマッチします (最初の文字が <literal>!</literal> の場合は、その否定にマッチします。また、文字の連続範囲は <literal>a-z</literal> のように表記します)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Regarding the assignment operators, <literal>=</literal> assigns a value (and replaces the current value); in the case of a list, it is emptied and contains only the value assigned. <literal>:=</literal> does the same, but prevents later changes to the same variable. As for <literal>+=</literal>, it adds an item to a list. The following variables can be changed:"
msgstr "代入演算子に関して、<literal>=</literal> は値を代入します (そして現在の値を入れ替えます)。さらに、リストに代入する場合、リストを空にした後、割り当てた値だけを代入します。<literal>:=</literal> は同じことをしますが、後から値を変更できなくなります。<literal>+=</literal> はリストにアイテムを追加します。代入演算子を使って変更できる変数は以下です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>NAME</literal>: the device filename to be created in <filename>/dev/</filename>. Only the first assignment counts; the others are ignored;"
msgstr "<literal>NAME</literal>。<filename>/dev/</filename> 内に作成するデバイスファイル名を意味します。最初に代入された値だけが考慮され、他は無視されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>SYMLINK</literal>: the list of symbolic links that will point to the same device;"
msgstr "<literal>SYMLINK</literal>。同じデバイスを指すシンボリックリンクのリストです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>OWNER</literal>, <literal>GROUP</literal> and <literal>MODE</literal> define the user and group that owns the device, as well as the associated permission;"
msgstr "<literal>OWNER</literal>、<literal>GROUP</literal>、<literal>MODE</literal>。デバイスを所有するユーザとグループおよびパーミッションを定義します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>RUN</literal>: the list of programs to execute in response to this event."
msgstr "<literal>RUN</literal>。イベントに応答する際に実行するプログラムのリストを意味します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The values assigned to these variables may use a number of substitutions:"
msgstr "これらの変数に割り当てる値の中で、以下の置換変数を使うことが可能な場合があります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>$kernel</literal> or <literal>%k</literal>: equivalent to <literal>KERNEL</literal>;"
msgstr "<literal>$kernel</literal> または <literal>%k</literal>。<literal>KERNEL</literal> と同じ値です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>$number</literal> or <literal>%n</literal>: the order number of the device, for example, for <literal>sda3</literal>, it would be “3”;"
msgstr "<literal>$number</literal> または <literal>%n</literal>。デバイスの割り当て番号を意味します。たとえば、<literal>sda3</literal> の場合「3」です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>$devpath</literal> or <literal>%p</literal>: equivalent to <literal>DEVPATH</literal>;"
msgstr "<literal>$devpath</literal> または <literal>%p</literal>。<literal>DEVPATH</literal> と同じ値です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>$attr{<replaceable>attribute</replaceable>}</literal> or <literal>%s{<replaceable>attribute</replaceable>}</literal>: equivalent to <literal>ATTRS{<replaceable>attribute</replaceable>}</literal>;"
msgstr "<literal>$attr{<replaceable>attribute</replaceable>}</literal> または <literal>%s{<replaceable>attribute</replaceable>}</literal>。<literal>ATTRS{<replaceable>attribute</replaceable>}</literal> と同じ値です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>$major</literal> or <literal>%M</literal>: the kernel major number of the device;"
msgstr "<literal>$major</literal> または <literal>%M</literal>。デバイスのカーネルメジャー番号を意味します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>$minor</literal> or <literal>%m</literal>: the kernel minor number of the device;"
msgstr "<literal>$minor</literal> または <literal>%m</literal>。デバイスのカーネルマイナー番号を意味します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>$result</literal> or <literal>%c</literal>: the string output by the last program invoked by <literal>PROGRAM</literal>;"
msgstr "<literal>$result</literal> または <literal>%c</literal>。<literal>PROGRAM</literal> によって起動された最後のプログラムの出力文字列を意味します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "and, finally, <literal>%%</literal> and <literal>$$</literal> for the percent and dollar sign, respectively."
msgstr "そして最後に、<literal>%%</literal> と <literal>$$</literal>。それぞれパーセントとドル記号を意味します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The above lists are not complete (they include only the most important parameters), but the <citerefentry><refentrytitle>udev</refentrytitle><manvolnum>7</manvolnum></citerefentry> manual page should be exhaustive."
msgstr "上のリストは完全なものではありません (最も重要なパラメータの抜粋です)。完全なリストは <citerefentry><refentrytitle>udev</refentrytitle><manvolnum>7</manvolnum></citerefentry> マニュアルページをご覧ください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "A concrete example"
msgstr "具体例"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Let us consider the case of a simple USB key and try to assign it a fixed name. First, you must find the elements that will identify it in a unique manner. For this, plug it in and run <command>udevadm info -a -n /dev/sdc</command> (replacing <replaceable>/dev/sdc</replaceable> with the actual name assigned to the key)."
msgstr "単純な USB メモリに固定された名前を割り当てる場合を考えましょう。最初に、一意的な方法で USB メモリを識別するために必要な要素を見つけなければいけません。このために、USB メモリを取り付け、<command>udevadm info -a -n /dev/sdc</command> を実行してください (ここで、<replaceable>/dev/sdc</replaceable> は USB メモリに割り当てられた実際のデバイス名で置き換えてください)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"<computeroutput># </computeroutput><userinput>udevadm info -a -n /dev/sdc</userinput>\n"
"<computeroutput>[...]\n"
"  looking at device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0/block/sdc':\n"
"    KERNEL==\"sdc\"\n"
"    SUBSYSTEM==\"block\"\n"
"    DRIVER==\"\"\n"
"    ATTR{range}==\"16\"\n"
"    ATTR{ext_range}==\"256\"\n"
"    ATTR{removable}==\"1\"\n"
"    ATTR{ro}==\"0\"\n"
"    ATTR{size}==\"126976\"\n"
"    ATTR{alignment_offset}==\"0\"\n"
"    ATTR{capability}==\"53\"\n"
"    ATTR{stat}==\"      51      100     1208      256        0        0        0        0        0      192      25        6\"\n"
"    ATTR{inflight}==\"       0        0\"\n"
"[...]\n"
"  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0':\n"
"    KERNELS==\"9:0:0:0\"\n"
"    SUBSYSTEMS==\"scsi\"\n"
"    DRIVERS==\"sd\"\n"
"    ATTRS{device_blocked}==\"0\"\n"
"    ATTRS{type}==\"0\"\n"
"    ATTRS{scsi_level}==\"3\"\n"
"    ATTRS{vendor}==\"I0MEGA  \"\n"
"    ATTRS{model}==\"UMni64MB*IOM2C4 \"\n"
"    ATTRS{rev}==\"    \"\n"
"    ATTRS{state}==\"running\"\n"
"[...]\n"
"    ATTRS{max_sectors}==\"240\"\n"
"[...]\n"
"  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2':\n"
"    KERNELS==\"9:0:0:0\"\n"
"    SUBSYSTEMS==\"usb\"\n"
"    DRIVERS==\"usb\"\n"
"    ATTRS{configuration}==\"iCfg\"\n"
"    ATTRS{bNumInterfaces}==\" 1\"\n"
"    ATTRS{bConfigurationValue}==\"1\"\n"
"    ATTRS{bmAttributes}==\"80\"\n"
"    ATTRS{bMaxPower}==\"100mA\"\n"
"    ATTRS{urbnum}==\"398\"\n"
"    ATTRS{idVendor}==\"4146\"\n"
"    ATTRS{idProduct}==\"4146\"\n"
"    ATTRS{bcdDevice}==\"0100\"\n"
"[...]\n"
"    ATTRS{manufacturer}==\"USB Disk\"\n"
"    ATTRS{product}==\"USB Mass Storage Device\"\n"
"    ATTRS{serial}==\"M004021000001\"\n"
"[...]\n"
"</computeroutput>"
msgstr ""
"<computeroutput># </computeroutput><userinput>udevadm info -a -n /dev/sdc</userinput>\n"
"<computeroutput>[...]\n"
"  looking at device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0/block/sdc':\n"
"    KERNEL==\"sdc\"\n"
"    SUBSYSTEM==\"block\"\n"
"    DRIVER==\"\"\n"
"    ATTR{range}==\"16\"\n"
"    ATTR{ext_range}==\"256\"\n"
"    ATTR{removable}==\"1\"\n"
"    ATTR{ro}==\"0\"\n"
"    ATTR{size}==\"126976\"\n"
"    ATTR{alignment_offset}==\"0\"\n"
"    ATTR{capability}==\"53\"\n"
"    ATTR{stat}==\"      51      100     1208      256        0        0        0        0        0      192      25        6\"\n"
"    ATTR{inflight}==\"       0        0\"\n"
"[...]\n"
"  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0':\n"
"    KERNELS==\"9:0:0:0\"\n"
"    SUBSYSTEMS==\"scsi\"\n"
"    DRIVERS==\"sd\"\n"
"    ATTRS{device_blocked}==\"0\"\n"
"    ATTRS{type}==\"0\"\n"
"    ATTRS{scsi_level}==\"3\"\n"
"    ATTRS{vendor}==\"I0MEGA  \"\n"
"    ATTRS{model}==\"UMni64MB*IOM2C4 \"\n"
"    ATTRS{rev}==\"    \"\n"
"    ATTRS{state}==\"running\"\n"
"[...]\n"
"    ATTRS{max_sectors}==\"240\"\n"
"[...]\n"
"  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2':\n"
"    KERNELS==\"9:0:0:0\"\n"
"    SUBSYSTEMS==\"usb\"\n"
"    DRIVERS==\"usb\"\n"
"    ATTRS{configuration}==\"iCfg\"\n"
"    ATTRS{bNumInterfaces}==\" 1\"\n"
"    ATTRS{bConfigurationValue}==\"1\"\n"
"    ATTRS{bmAttributes}==\"80\"\n"
"    ATTRS{bMaxPower}==\"100mA\"\n"
"    ATTRS{urbnum}==\"398\"\n"
"    ATTRS{idVendor}==\"4146\"\n"
"    ATTRS{idProduct}==\"4146\"\n"
"    ATTRS{bcdDevice}==\"0100\"\n"
"[...]\n"
"    ATTRS{manufacturer}==\"USB Disk\"\n"
"    ATTRS{product}==\"USB Mass Storage Device\"\n"
"    ATTRS{serial}==\"M004021000001\"\n"
"[...]\n"
"</computeroutput>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "To create a new rule, you can use tests on the device's variables, as well as those of one of the parent devices. The above case allows us to create two rules like these:"
msgstr "新しいルールを作るために、デバイスの変数および親デバイスの変数に対するテストを行います。上の例から、以下のような 2 つのルールを作成します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"KERNEL==\"sd?\", SUBSYSTEM==\"block\", ATTRS{serial}==\"M004021000001\", SYMLINK+=\"usb_key/disk\"\n"
"KERNEL==\"sd?[0-9]\", SUBSYSTEM==\"block\", ATTRS{serial}==\"M004021000001\", SYMLINK+=\"usb_key/part%n\""
msgstr ""
"KERNEL==\"sd?\", SUBSYSTEM==\"block\", ATTRS{serial}==\"M004021000001\", SYMLINK+=\"usb_key/disk\"\n"
"KERNEL==\"sd?[0-9]\", SUBSYSTEM==\"block\", ATTRS{serial}==\"M004021000001\", SYMLINK+=\"usb_key/part%n\""

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Once these rules are set in a file, named for example <filename>/etc/udev/rules.d/010_local.rules</filename>, you can simply remove and reconnect the USB key. You can then see that <filename>/dev/usb_key/disk</filename> represents the disk associated with the USB key, and <filename>/dev/usb_key/part1</filename> is its first partition."
msgstr "これらのルールをたとえば <filename>/etc/udev/rules.d/010_local.rules</filename> という 1 つのファイルに書き込んだら、USB メモリを取り外し、再度取り付けてください。この USB キーに関連付けられたディスクを表す <filename>/dev/usb_key/disk</filename> と第 1 パーティションを表す <filename>/dev/usb_key/part1</filename> が生成されたことと思います。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>GOING FURTHER</emphasis> Debugging <emphasis>udev</emphasis>'s configuration"
msgstr "<emphasis>GOING FURTHER</emphasis> <emphasis>udev</emphasis> 設定のデバッグ"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Like many daemons, <command>udevd</command> stores logs in <filename>/var/log/daemon.log</filename>. But it is not very verbose by default, and it is usually not enough to understand what is happening. The <command>udevadm control --log-priority=info</command> command increases the verbosity level and solves this problem. <command>udevadm control --log-priority=err</command> returns to the default verbosity level."
msgstr "多くのデーモンと同様に、<command>udevd</command> は <filename>/var/log/daemon.log</filename> にログを保存します。しかしデフォルトの状態だとログはそれほど詳細でなく、何が起きているかを理解するには不十分な場合が多いです。<command>udevadm control --log-priority=info</command> コマンドを使ってログの詳細度を上げることで、この問題は解決されます。デフォルトの詳細度に戻すには、<command>udevadm control --log-priority=err</command> を使ってください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Power Management: Advanced Configuration and Power Interface (ACPI)"
msgstr "電源管理、Advanced Configuration and Power Interface (ACPI)"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>power management</primary>"
msgstr "<primary>電源管理</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>management, power management</primary>"
msgstr "<primary>管理、電源管理</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The topic of power management is often problematic. Indeed, properly suspending the computer requires that all the computer's device drivers know how to put them to standby, and that they properly reconfigure the devices upon waking. Unfortunately, there are still a few devices unable to sleep well under Linux, because their manufacturers have not provided the required specifications."
msgstr "電源管理は問題のある場合が多いです。実際、適切にコンピュータを一時停止するには、コンピュータのすべてのデバイスドライバがデバイスをスタンバイ状態にする方法を知り、デバイスドライバがデバイスを再始動する際に適切に再設定できなければいけません。不幸なことに、Linux の下ではうまくスタンバイ状態にできないデバイスが多いです。なぜなら、デバイスの製造業者が必要な仕様を公開しないからです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Linux supports ACPI (Advanced Configuration and Power Interface) — the most recent standard in power management. The <emphasis role=\"pkg\">acpid</emphasis> package provides a daemon that looks for power management related events (switching between AC and battery power on a laptop, etc.) and that can execute various commands in response."
msgstr "Linux は ACPI (Advanced Configuration and Power Interface) つまり最新の標準的な電源管理規格をサポートします。<emphasis role=\"pkg\">acpid</emphasis> パッケージは電源管理に関するイベント (ラップトップで交流電源とバッテリ電源の切り替えに対するイベントなど) を待ち受けたり、イベントに応答してさまざまなコマンドを実行するデーモンを提供します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>ACPI</primary>"
msgstr "<primary>ACPI</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Advanced Configuration and Power Interface</primary>"
msgstr "<primary>Advanced Configuration and Power Interface</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>acpid</command></primary>"
msgstr "<primary><command>acpid</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BEWARE</emphasis> Graphics card and standby"
msgstr "<emphasis>BEWARE</emphasis> グラフィックカードとスタンバイ"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The graphics card driver is often the culprit when standby doesn't work properly. In that case, it is a good idea to test the latest version of the X.org graphics server."
msgstr "グラフィックカードドライバはスタンバイがうまくできない問題の原因になることが多いです。この場合、X.org グラフィックサーバの最新版を試してみるのが良いアイディアです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "After this overview of basic services common to many Unix systems, we will focus on the environment of the administered machines: the network. Many services are required for the network to work properly. They will be discussed in the next chapter."
msgstr "この章では多くの Unix システムで共通の基本的サービスの概要を述べました。次の章では管理されているマシンの環境に焦点を合わせます。すなわちネットワークに焦点を合わせます。多くのサービスはネットワークを正しく動作させることを必要とします。次の章ではこれについて議論します。"

#~ msgid "<emphasis>CULTURE</emphasis> Advanced Power Management (APM)"
#~ msgstr "<emphasis>CULTURE</emphasis> Advanced Power Management (APM)"

#~ msgid "<primary>APM</primary>"
#~ msgstr "<primary>APM</primary>"

#~ msgid "<primary>Advanced Power Management</primary>"
#~ msgstr "<primary>Advanced Power Management</primary>"

#~ msgid "APM (Advanced Power Management) is the ancestor of ACPI in the power management world. While Debian still provides <command>apmd</command> (the counterpart to <command>acpid</command> for the APM standard), the official Debian kernel no longer supports APM so you'll have to run a custom kernel if you really need it for some old computer."
#~ msgstr "APM (Advanced Power Management) は電源管理分野における ACPI の先祖です。Debian ではまだ <command>apmd</command> (APM 規格用の <command>acpid</command> に対応するもの) を配布していますが、公式の Debian カーネルはもはや APM をサポートしません。このため、一部の古いコンピュータで本当に APM が必要ならば、カスタムカーネルを実行しなければいけません。"

#~ msgid "Another new option that is gaining a lot of traction is <command>systemd</command>. Its approach is opposite to the previous systems; instead of preemptively launching all services, and having to deal with the question of scheduling, <command>systemd</command> chooses to start services on demand, somewhat along the principle of <command>inetd</command>. But this means that the boot system must be able to know how services are made available (it could be through a socket, a filesystem, or others), and thus requires small modifications of those services. It also provides backwards compatibility to System V init scripts."
#~ msgstr "別の新しい選択肢は <command>systemd</command> で、多くの注目を集めています。<command>systemd</command> は前に挙げたシステムと対極のやり方を取ります。それどころか、事前にすべてのサービスを起動して、起動順の問題を解決する代わりに、<command>systemd</command> は要求に応じてサービスを起動します。これは若干 <command>inetd</command> の原則と似ています。しかしこれは、起動システムは必ずサービスを利用できるようにする方法を知らなければいけない (ソケット、ファイルシステム、その他を介すことで可能です) こと、を意味しており、サービスはこれに合わせて挙動を少し変更しなければいけません。さらに <command>systemd</command> は System V init スクリプトに対する後方互換性を提供します。"
