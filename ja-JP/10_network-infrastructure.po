#
# AUTHOR <EMAIL@ADDRESS>, YEAR.
# Ryuunosuke Ayanokouzi <i38w7i3@yahoo.co.jp>, 2015-2017.
# Kenshi Muto <kmuto@kmuto.jp>, 2015.
# Yoichi Chonan <cyoichi@maple.ocn.ne.jp>, 2015.
# YABUKI Youichi <yabuki@sraoss.co.jp>, 2015.
#
msgid ""
msgstr ""
"Project-Id-Version: 0\n"
"POT-Creation-Date: 2017-02-05 09:00+0900\n"
"PO-Revision-Date: 2017-02-05 09:00+0900\n"
"Last-Translator: AYANOKOUZI, Ryuunosuke <i38w7i3@yahoo.co.jp>\n"
"Language-Team: Japanese <https://github.com/l/debian-handbook/tree/master/translation/ja_JP/push>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: application/x-publican; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Network"
msgstr "ネットワーク"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Gateway"
msgstr "ゲートウェイ"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "TCP/IP"
msgstr "TCP/IP"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "IPv6"
msgstr "IPv6"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "DNS"
msgstr "DNS"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Bind"
msgstr "Bind"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "DHCP"
msgstr "DHCP"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "QoS"
msgstr "QoS"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Network Infrastructure"
msgstr "ネットワークインフラ"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Linux sports the whole Unix heritage for networking, and Debian provides a full set of tools to create and manage them. This chapter reviews these tools."
msgstr "Linux はネットワークに関する Unix の財産すべてを受け継ぎ、Debian はネットワークを作成および管理する完全なツールセットを提供します。この章では、これらのツールを説明します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "A gateway is a system linking several networks. This term often refers to a local network's “exit point” on the mandatory path to all external IP addresses. The gateway is connected to each of the networks it links together, and acts as a router to convey IP packets between its various interfaces."
msgstr "ゲートウェイは複数のネットワークを連結するシステムです。ゲートウェイという用語は外部 IP アドレスに向かう経路に出るために必須のローカルネットワークの「出口」を意味する場合が多いです。ゲートウェイは相互に連結する各ネットワークに接続されており、複数のインターフェース間で IP パケットを相互に伝送するためのルータとして振る舞います。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>gateway</primary>"
msgstr "<primary>ゲートウェイ</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>network</primary><secondary>gateway</secondary>"
msgstr "<primary>ネットワーク</primary><secondary>ゲートウェイ</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>router</primary>"
msgstr "<primary>ルータ</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> IP packet"
msgstr "<emphasis>BACK TO BASICS</emphasis> IP パケット"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>packet</primary><secondary>IP</secondary>"
msgstr "<primary>パケット</primary><secondary>IP パケット</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Most networks nowadays use the IP protocol (<emphasis>Internet Protocol</emphasis>). This protocol segments the transmitted data into limited-size packets. Each packet contains, in addition to its payload data, a number of details required for its proper routing."
msgstr "今日、多くのネットワークは IP プロトコル (<emphasis>インターネットプロトコル</emphasis>) を使います。IP プロトコルは転送するデータを適当なサイズのパケットに分割します。それぞれのパケットには、実データ本体に加えて、適切な経路選択に必要な数々のデータが含まれます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> TCP/UDP"
msgstr "<emphasis>BACK TO BASICS</emphasis> TCP/UDP"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>port</primary><secondary>TCP</secondary>"
msgstr "<primary>ポート</primary><secondary>TCP</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>port</primary><secondary>UDP</secondary>"
msgstr "<primary>ポート</primary><secondary>UDP</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>TCP, port</primary>"
msgstr "<primary>TCP、ポート</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>UDP, port</primary>"
msgstr "<primary>UDP、ポート</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Many programs do not handle the individual packets themselves, even though the data they transmit does travel over IP; they often use TCP (<emphasis>Transmission Control Protocol</emphasis>). TCP is a layer over IP allowing the establishment of connections dedicated to data streams between two points. The programs then only see an entry point into which data can be fed with the guarantee that the same data exits without loss (and in the same sequence) at the exit point at the other end of the connection. Although many kinds of errors can happen in the lower layers, they are compensated by TCP: lost packets are retransmitted, and packets arriving out of order (for example, if they used different paths) are re-ordered appropriately."
msgstr "IP を使ってデータを送信する場合であっても、プログラムが個々のパケットそれ自体を処理することはほとんどありません。多くのプログラムは TCP (<emphasis>Transmission Control Protocol</emphasis>) を使います。TCP は IP 上のレイヤで、2 点間にデータストリーム専用の接続を確立することが可能です。TCP を使うプログラムはデータを送り込むための入口を考慮するだけです。この入口から送信されたデータは接続の別の側にある出口から損失なく同じデータが (同じ順番で) 出てくると保証されます。TCP よりも下層のレイヤで起きるさまざまなエラーは TCP によって補正されます。具体的に言えば、損失したパケットはもう一度転送され、順番が狂って到着したパケット (たとえば、異なる経路で到着したために) は適切な順番にそろえられます。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: PTAL;
msgid "Another protocol relying on IP is UDP (<emphasis>User Datagram Protocol</emphasis>). In contrast to TCP, it is packet-oriented. Its goals are different: the purpose of UDP is only to transmit one packet from an application to another. The protocol does not try to compensate for possible packet loss on the way, nor does it ensure that packets are received in the same order as were sent. The main advantage to this protocol is that the latency is greatly improved, since the loss of a single packet does not delay the receiving of all following packets until the lost one is retransmitted."
msgstr "IP に依存するもう 1 つのプロトコルが UDP (<emphasis>User Datagram Protocol</emphasis>) です。TCP と対照的に、UDP はパケット重視です。UDP の目標は TCP と異なります。すなわち、UDP の目標は 1 個のパケットをあるアプリケーションから別のアプリケーションに転送するだけです。UDP を使った場合、転送中のパケット損失は補償されませんし、パケットが送信順と同じ順番で受信されることも保証されません。UDP の主な利点は遅延が大きく改善される点です。なぜなら、1 パケットを損失しても、損失したパケットの再転送要求を出さないかぎり、損失したパケット以降に続くパケットの受信は遅延しないからです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "TCP and UDP both involve ports, which are “extension numbers” for establishing communication with a given application on a machine. This concept allows keeping several different communications in parallel with the same correspondent, since these communications can be distinguished by the port number."
msgstr "TCP と UDP はどちらもポート番号を使います。ポート番号とは、マシン上で動くあるアプリケーションと通信を確立するための「内線番号」と言えます。この概念を使うことで、同一のマシンに対して複数の異なる通信を並列して保つことが可能になります。なぜなら、通信はポート番号で区別されるからです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Some of these port numbers — standardized by the IANA (<emphasis>Internet Assigned Numbers Authority</emphasis>) — are “well-known” for being associated with network services. For instance, TCP port 25 is generally used by the email server. <ulink type=\"block\" url=\"http://www.iana.org/assignments/port-numbers\" />"
msgstr "IANA (<emphasis>Internet Assigned Numbers Authority</emphasis>) が標準化したいくつかのポート番号は「well-known」とされ、ネットワークサービスに関連付けられています。たとえば、TCP ポート 25 番は一般に電子メールサーバが使うポート番号として標準化されています。<ulink type=\"block\" url=\"http://www.iana.org/assignments/port-numbers\" />"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "When a local network uses a private address range (not routable on the Internet), the gateway needs to implement <emphasis>address masquerading</emphasis> so that the machines on the network can communicate with the outside world. The masquerading operation is a kind of proxy operating on the network level: each outgoing connection from an internal machine is replaced with a connection from the gateway itself (since the gateway does have an external, routable address), the data going through the masqueraded connection is sent to the new one, and the data coming back in reply is sent through to the masqueraded connection to the internal machine. The gateway uses a range of dedicated TCP ports for this purpose, usually with very high numbers (over 60000). Each connection coming from an internal machine then appears to the outside world as a connection coming from one of these reserved ports."
msgstr "ローカルネットワークがプライベートアドレス (インターネットにルーティングされないアドレス) 範囲を使う場合、ゲートウェイは<emphasis>アドレスマスカレード</emphasis>を実行する必要があります。<emphasis>アドレスマスカレード</emphasis>を使うことで、ローカルネットワーク上のマシンが外部と通信することが可能になります。マスカレード動作とはネットワークレベルのプロキシ動作のようなものです。すなわち、内部のマシンからの外部宛接続はゲートウェイ自身からの接続に置き替えられます (なぜなら、ゲートウェイは外部にルーティングできるアドレスを持っているからです)。マスカレード接続を通過するデータは外部に送信され、応答として戻ってくるデータはマスカレード接続を通過して内部のマシンに送信されます。ゲートウェイはこの目的に専用の TCP ポート範囲を使います。この範囲は通常とても大きな番号 (60000 番より大きい番号) です。内部マシンからの接続はこれらの予約されたポート番号の 1 つから送信された接続として外部に送信されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>masquerading</primary>"
msgstr "<primary>マスカレード</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>CULTURE</emphasis> Private address range"
msgstr "<emphasis>CULTURE</emphasis> プライベートアドレス範囲"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>IP address</primary><secondary>private</secondary>"
msgstr "<primary>IP アドレス</primary><secondary>プライベート</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>private IP address</primary>"
msgstr "<primary>プライベート IP アドレス</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: https://tools.ietf.org/html/rfc1918;
# Ref: https://tools.ietf.org/html/rfc1466;
msgid "RFC 1918 defines three ranges of IPv4 addresses not meant to be routed on the Internet but only used in local networks. The first one, <literal>10.0.0.0/8</literal> (see sidebar <xref linkend=\"sidebar.networking-basics\" />), is a class-A range (with 2<superscript>24</superscript> IP addresses). The second one, <literal>172.16.0.0/12</literal>, gathers 16 class-B ranges (<literal>172.16.0.0/16</literal> to <literal>172.31.0.0/16</literal>), each containing 2<superscript>16</superscript> IP addresses. Finally, <literal>192.168.0.0/16</literal> is a class-B range (grouping 256 class-C ranges, <literal>192.168.0.0/24</literal> to <literal>192.168.255.0/24</literal>, with 256 IP addresses each). <ulink type=\"block\" url=\"http://www.faqs.org/rfcs/rfc1918.html\" />"
msgstr "RFC 1918 では、インターネットにルーティングされずローカルネットワークにのみ使うことができる、IPv4 アドレスの範囲が定義されています。1 番目の <literal>10.0.0.0/8</literal> (補注<xref linkend=\"sidebar.networking-basics\" />を参照してください) は 1 個のクラス A 範囲です (クラス A には 2<superscript>24</superscript> 個の IP アドレスが含まれます)。2 番目の <literal>172.16.0.0/12</literal> は 16 個のクラス B 範囲です (<literal>172.16.0.0/16</literal> から <literal>172.31.0.0/16</literal> まで)。クラス B には 2<superscript>16</superscript> 個の IP アドレスが含まれます。3 番目の <literal>192.168.0.0/16</literal> は 1 個のクラス B 範囲です (<literal>192.168.0.0/24</literal> から <literal>192.168.255.0/24</literal> までの 256 個のクラス C 範囲とも考えられます)。クラス C には 256 個の IP アドレスが含まれます。<ulink type=\"block\" url=\"http://www.faqs.org/rfcs/rfc1918.html\" />"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The gateway can also perform two kinds of <emphasis>network address translation</emphasis> (or NAT for short). The first kind, <emphasis>Destination NAT</emphasis> (DNAT) is a technique to alter the destination IP address (and/or the TCP or UDP port) for a (generally) incoming connection. The connection tracking mechanism also alters the following packets in the same connection to ensure continuity in the communication. The second kind of NAT is <emphasis>Source NAT</emphasis> (SNAT), of which <emphasis>masquerading</emphasis> is a particular case; SNAT alters the source IP address (and/or the TCP or UDP port) of a (generally) outgoing connection. As for DNAT, all the packets in the connection are appropriately handled by the connection tracking mechanism. Note that NAT is only relevant for IPv4 and its limited address space; in IPv6, the wide availability of addresses greatly reduces the usefulness of NAT by allowing all “internal” addresses to be directly routable on the Internet (this does not imply that internal machines are accessible, since intermediary firewalls can filter traffic)."
msgstr "ゲートウェイでは 2 種類の<emphasis>ネットワークアドレス変換</emphasis> (略して NAT) が実行されます。1 種類目は <emphasis>Destination NAT</emphasis> (DNAT) で、(通常は) 到着した接続の宛先 IP アドレス (および TCP や UDP ポート) を書き換える手法です。接続追跡メカニズムによって、通信の継続性を保証するために同じ接続でそれ以降に使われるパケットの宛先が書き換えられます。NAT の 2 種類目は <emphasis>Source NAT</emphasis> (SNAT) で、<emphasis>マスカレード</emphasis>は SNAT の特別な場合です。SNAT は (通常は) 出て行く接続のソース IP アドレス (および TCP や UDP ポート) を書き換えます。DNAT に関して言えば、出て行く接続の全パケットが接続追跡メカニズムによって適切に取り扱われます。NAT は IPv4 と IPv4 の制限されたアドレス空間だけに関連します。一方で IPv6 では、アドレス空間が広くなったことにより、すべての「内部」アドレスは直接インターネットにルーティングできるようになるため、NAT の有用性が減ります (これは内部マシンにアクセスできるようになることを意味しているのではありません。なぜなら、中間ファイアウォールがトラフィックをフィルタするからです)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>NAT</primary>"
msgstr "<primary>NAT</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Network</primary><secondary>Address Translation</secondary>"
msgstr "<primary>ネットワーク</primary><secondary>アドレス変換</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>SNAT</primary>"
msgstr "<primary>SNAT</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>DNAT</primary>"
msgstr "<primary>DNAT</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Destination NAT</primary>"
msgstr "<primary>Destination NAT</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Source NAT</primary>"
msgstr "<primary>Source NAT</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> Port forwarding"
msgstr "<emphasis>BACK TO BASICS</emphasis> ポート転送"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>port forwarding</primary>"
msgstr "<primary>ポート転送</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "A concrete application of DNAT is <emphasis>port forwarding</emphasis>. Incoming connections to a given port of a machine are forwarded to a port on another machine. Other solutions may exist for achieving a similar effect, though, especially at the application level with <command>ssh</command> (see <xref linkend=\"sect.ssh-port-forwarding\" />) or <command>redir</command>."
msgstr "DNAT の具体的な応用例が<emphasis>ポート転送</emphasis>です。マシンのあるポートに到着する接続が他のマシンのあるポートに転送されます。特にアプリケーションレベルでは <command>ssh</command> (<xref linkend=\"sect.ssh-port-forwarding\" />を参照してください) や <command>redir</command> などを使うことで、同じ効果を果たす別の解決策が存在するかもしれません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Enough theory, let's get practical. Turning a Debian system into a gateway is a simple matter of enabling the appropriate option in the Linux kernel, by way of the <filename>/proc/</filename> virtual filesystem:"
msgstr "理論はここまでにして、具体的な例を説明します。Debian システムをゲートウェイとして機能させるには、以下に示す通り <filename>/proc/</filename> 仮想ファイルシステムを使って、Linux カーネルの適切なオプションを有効化するだけです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"<computeroutput># </computeroutput><userinput>echo 1 &gt; /proc/sys/net/ipv4/conf/default/forwarding</userinput>"
msgstr ""
"\n"
"<computeroutput># </computeroutput><userinput>echo 1 &gt; /proc/sys/net/ipv4/conf/default/forwarding</userinput>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "This option can also be automatically enabled on boot if <filename>/etc/sysctl.conf</filename> sets the <literal>net.ipv4.conf.default.forwarding</literal> option to <literal>1</literal>."
msgstr "このオプションを起動時に自動的に有効化するには、<filename>/etc/sysctl.conf</filename> の <literal>net.ipv4.conf.default.forwarding</literal> オプションを <literal>1</literal> に設定してください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <filename>/etc/sysctl.conf</filename> file"
msgstr "<filename>/etc/sysctl.conf</filename> ファイル"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"net.ipv4.conf.default.forwarding = 1\n"
"net.ipv4.conf.default.rp_filter = 1\n"
"net.ipv4.tcp_syncookies = 1"
msgstr ""
"\n"
"net.ipv4.conf.default.forwarding = 1\n"
"net.ipv4.conf.default.rp_filter = 1\n"
"net.ipv4.tcp_syncookies = 1"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The same effect can be obtained for IPv6 by simply replacing <literal>ipv4</literal> with <literal>ipv6</literal> in the manual command and using the <literal>net.ipv6.conf.all.forwarding</literal> line in <filename>/etc/sysctl.conf</filename>."
msgstr "IPv6 に対して同様の効果を与えるには、IPv4 に対して手作業で行ったコマンドの <literal>ipv4</literal> を単純に <literal>ipv6</literal> へ置換して実行するか、<filename>/etc/sysctl.conf</filename> 中の <literal>net.ipv6.conf.all.forwarding</literal> オプションを <literal>1</literal> に設定してください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Enabling IPv4 masquerading is a slightly more complex operation that involves configuring the <emphasis>netfilter</emphasis> firewall."
msgstr "IPv4 マスカレードを設定するには少し複雑な作業が必要です。すなわち <emphasis>netfilter</emphasis> ファイアウォールを設定する必要があります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Similarly, using NAT (for IPv4) requires configuring <emphasis>netfilter</emphasis>. Since the primary purpose of this component is packet filtering, the details are listed in <xref linkend=\"security\" xrefstyle=\"select: label quotedtitle nopage\" /> (see <xref linkend=\"sect.firewall-packet-filtering\" />)."
msgstr "同様に、(IPv4 で) NAT を使うには <emphasis>netfilter</emphasis> の設定が必要です。<emphasis>netfilter</emphasis> の基本目的はパケットフィルタリングですから、詳細は<xref linkend=\"security\" xrefstyle=\"select: label quotedtitle nopage\" />に書かれています (<xref linkend=\"sect.firewall-packet-filtering\" />を参照してください)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Virtual Private Network"
msgstr "仮想プライベートネットワーク"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "A <emphasis>Virtual Private Network</emphasis> (VPN for short) is a way to link two different local networks through the Internet by way of a tunnel; the tunnel is usually encrypted for confidentiality. VPNs are often used to integrate a remote machine within a company's local network."
msgstr "<emphasis>仮想プライベートネットワーク</emphasis> (略して VPN) は 2 つの異なるローカルネットワークをインターネットに作ったトンネルを経由してつなげる方法です。さらに、トンネルは通常機密を守るために暗号化されます。VPN はリモートマシンを会社のローカルネットワークの中に参加させるために使われることが多いです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>network</primary><secondary>virtual private</secondary>"
msgstr "<primary>ネットワーク</primary><secondary>仮想プライベート</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>VPN</primary>"
msgstr "<primary>VPN</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>virtual private network</primary>"
msgstr "<primary>仮想プライベートネットワーク</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Several tools provide this. OpenVPN is an efficient solution, easy to deploy and maintain, based on SSL/TLS. Another possibility is using IPsec to encrypt IP traffic between two machines; this encryption is transparent, which means that applications running on these hosts need not be modified to take the VPN into account. SSH can also be used to provide a VPN, in addition to its more conventional features. Finally, a VPN can be established using Microsoft's PPTP protocol. Other solutions exist, but are beyond the focus of this book."
msgstr "VPN 機能を提供するツールにはさまざまなものがあります。OpenVPN は効果的な解決策で、設置とメンテナンスが簡単で、SSL/TLS に基づいています。別の可能性は IPsec を使って 2 台のマシン間の IP トラフィックを暗号化することです。IPsec の暗号化は透過的で、ホスト上で実行されているアプリケーションは VPN の存在を気にする必要がありません。SSH は伝統的な機能に加えて、VPN を提供するために使われる場合もあります。最後に、Microsoft の PPTP プロトコルを使って VPN を作ることも可能です。他にも解決策は存在しますが、本書では解説しません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "OpenVPN"
msgstr "OpenVPN"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>OpenVPN</primary>"
msgstr "<primary>OpenVPN</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "OpenVPN is a piece of software dedicated to creating virtual private networks. Its setup involves creating virtual network interfaces on the VPN server and on the client(s); both <literal>tun</literal> (for IP-level tunnels) and <literal>tap</literal> (for Ethernet-level tunnels) interfaces are supported. In practice, <literal>tun</literal> interfaces will most often be used except when the VPN clients are meant to be integrated into the server's local network by way of an Ethernet bridge."
msgstr "OpenVPN は仮想プライベートネットワーク作成専用ソフトウェアの一種です。OpenVPN をセットアップするには VPN サーバ上とクライアント上に仮想ネットワークインターフェースの作成が必要です。さらに、OpenVPN は <literal>tun</literal> (IP レベルトンネル用) と <literal>tap</literal> (イーサネットレベルトンネル用) インターフェースをサポートします。実際には、VPN クライアントをイーサネットブリッジ経由でサーバのローカルネットワークに参加させる場合を除いて、<literal>tun</literal> インターフェースが最もよく使われます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "OpenVPN relies on OpenSSL for all the SSL/TLS cryptography and associated features (confidentiality, authentication, integrity, non-repudiation). It can be configured either with a shared private key or using X.509 certificates based on a public key infrastructure. The latter configuration is strongly preferred since it allows greater flexibility when faced with a growing number of roaming users accessing the VPN."
msgstr "OpenVPN は SSL/TLS 暗号化と関連する機能 (機密性、認証、整合性、否認防止) を使うために OpenSSL に依存しています。OpenVPN は共有秘密鍵または公開鍵基盤に基づく X.509 証明書を使うように設定できます。公開鍵基盤に基づく X.509 証明書を使うよう設定することをお勧めします。なぜなら、公開鍵基盤に従えば VPN にアクセスするローミングユーザの数が増えた場合も大きな自由度を保つことが可能だからです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>CULTURE</emphasis> SSL and TLS"
msgstr "<emphasis>CULTURE</emphasis> SSL と TLS"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>SSL</primary>"
msgstr "<primary>SSL</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>TLS</primary>"
msgstr "<primary>TLS</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The SSL protocol (<emphasis>Secure Socket Layer</emphasis>) was invented by Netscape to secure connections to web servers. It was later standardized by IETF under the acronym TLS (<emphasis>Transport Layer Security</emphasis>). Since then TLS continued to evolve and nowadays SSL is deprecated due to multiple design flaws that have been discovered."
msgstr "SSL (<emphasis>Secure Socket Layer</emphasis>) プロトコルはウェブサーバとの安全な接続を確立する目的で Netscape によって考案されました。SSL は後に TLS (<emphasis>Transport Layer Security</emphasis>) の下で IETF によって標準化されました。その後 TLS は進化を続けました。対して SSL は構造的欠陥を見つけられたため SSL を使うことは推奨されません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Public Key Infrastructure: <emphasis>easy-rsa</emphasis>"
msgstr "公開鍵基盤、<emphasis>easy-rsa</emphasis>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>PKI (Public Key Infrastructure)</primary>"
msgstr "<primary>PKI (公開鍵基盤)</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Public Key Infrastructure</primary>"
msgstr "<primary>公開鍵基盤</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>X.509, certificate</primary>"
msgstr "<primary>X.509、証明書</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>certificate</primary><secondary>X.509</secondary>"
msgstr "<primary>証明書</primary><secondary>X.509</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis>easy-rsa</emphasis></primary>"
msgstr "<primary><emphasis>easy-rsa</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>RSA (algorithm)</primary>"
msgstr "<primary>RSA (アルゴリズム)</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>key pair</primary>"
msgstr "<primary>鍵ペア</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: PTAL;
msgid "The RSA algorithm is widely used in public-key cryptography. It involves a “key pair”, comprised of a private and a public key. The two keys are closely linked to each other, and their mathematical properties are such that a message encrypted with the public key can only be decrypted by someone knowing the private key, which ensures confidentiality. In the opposite direction, a message encrypted with the private key can be decrypted by anyone knowing the public key, which allows authenticating the origin of a message since only someone with access to the private key could generate it. When associated with a digital hash function (MD5, SHA1, or a more recent variant), this leads to a signature mechanism that can be applied to any message."
msgstr "公開鍵暗号では RSA アルゴリズムが広く使われています。公開鍵暗号は秘密鍵と公開鍵からなる「鍵ペア」を使います。2 種類の鍵は互いに密接な関係を持っており、公開鍵で暗号化されたメッセージは秘密鍵を知っている人だけが復号化できるという数学的特徴によって機密性が保証されます。逆に、秘密鍵を使って暗号化されたメッセージは公開鍵を持っている人なら誰でも復号化できます。この特徴を使うことで、メッセージの出自が本物であることを確認することが可能です。なぜなら、秘密鍵を持つものだけがその暗号化メッセージを生成できるからです。デジタルハッシュ関数 (MD5、SHA1、最近の亜種など) を組み合わせることで、これはいかなるメッセージにも適用できる署名メカニズムになります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "However, anyone can create a key pair, store any identity on it, and pretend to be the identity of their choice. One solution involves the concept of a <emphasis>Certification Authority</emphasis> (CA), formalized by the X.509 standard. This term covers an entity that holds a trusted key pair known as a <emphasis>root certificate</emphasis>. This certificate is only used to sign other certificates (key pairs), after proper steps have been undertaken to check the identity stored on the key pair. Applications using X.509 can then check the certificates presented to them, if they know about the trusted root certificates."
msgstr "しかしながら、鍵ペアを作り、鍵ペアに任意の識別情報を保存し、自由に識別情報を偽ることは誰でも可能です。これに対する 1 つの解決策が X.509 標準によって体系化された<emphasis>認証局</emphasis> (CA) の概念です。<emphasis>認証局</emphasis>という用語には、<emphasis>ルート証明書</emphasis>として知られる信頼された鍵ペアに保存された識別情報の実体の意味も含まれています。<emphasis>ルート証明書</emphasis>は他の証明書 (鍵ペア) を署名するためにのみ使われ、署名したい鍵ペアに保存される識別情報を確認するために適切な手順を経た後に署名が行われます。こうすることで X.509 を使うアプリケーションは自分に提示された証明書の識別情報を確認し、提示された証明書が信頼されたルート証明書によって署名されたかを判断できます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "OpenVPN follows this rule. Since public CAs only emit certificates in exchange for a (hefty) fee, it is also possible to create a private certification authority within the company. The <emphasis role=\"pkg\">easy-rsa</emphasis> package provides tools to serve as an X.509 certification infrastructure, implemented as a set of scripts using the <command>openssl</command> command."
msgstr "OpenVPN はこの識別情報確認ルールに従います。パブリック認証局は (高額な) 料金と引き換えに証明書を発行しているに過ぎません。OpenVPN を使えば会社内のプライベート認証局を作成することが可能です。<emphasis role=\"pkg\">easy-rsa</emphasis> パッケージは X.509 証明書基盤としての機能を果たすツールを提供し、このツールは <command>openssl</command> コマンドを使うスクリプト群として実装されています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>NOTE</emphasis> <emphasis>easy-rsa</emphasis> before <emphasis role=\"distribution\">Jessie</emphasis>"
msgstr "<emphasis>NOTE</emphasis> <emphasis role=\"distribution\">Jessie</emphasis> 以前の <emphasis>easy-rsa</emphasis>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "In versions of Debian up to <emphasis role=\"distribution\">Wheezy</emphasis>, <emphasis>easy-rsa</emphasis> was distributed as part of the <emphasis role=\"pkg\">openvpn</emphasis> package, and its scripts were to be found under <filename>/usr/share/doc/openvpn/examples/easy-rsa/2.0/</filename>. Setting up a CA involved copying that directory, instead of using the <command>make-cadir</command> command as documented here."
msgstr "<emphasis role=\"distribution\">Wheezy</emphasis> までの Debian のバージョンでは、<emphasis>easy-rsa</emphasis> は <emphasis role=\"pkg\">openvpn</emphasis> パッケージの一部として配布されており、<emphasis>easy-rsa</emphasis> のスクリプトは <filename>/usr/share/doc/openvpn/examples/easy-rsa/2.0/</filename> 以下に含まれていました。認証局を設定するには、ここで説明されているように <command>make-cadir</command> コマンドを使うのではなく、このディレクトリをコピーする必要がありました。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The Falcot Corp administrators use this tool to create the required certificates, both for the server and the clients. This allows the configuration of all clients to be similar since they will only have to be set up so as to trust certificates coming from Falcot's local CA. This CA is the first certificate to create; to this end, the administrators set up a directory with the files required for the CA in an appropriate location, preferably on a machine not connected to the network in order to mitigate the risk of the CA's private key being stolen."
msgstr "Falcot Corp の管理者は <emphasis>easy-rsa</emphasis> ツールを使い、サーバおよびクライアントに必要な証明書を作ります。<emphasis>easy-rsa</emphasis> ツールを使うことで、すべてのクライアントの設定を同様にすることが可能です。クライアントは Falcot のプライベート認証局から発行された証明書を信頼するようにセットアップしなければいけません。最初に Falcot のプライベート認証局用の証明書を発行します。この目的を達成するために、管理者は認証局に必要なファイルを含むディレクトリを適切な場所にセットアップします。セットアップする場所は、認証局の秘密鍵が盗まれる危険性を和らげるために、ネットワークに接続されていないマシンが好ましいです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>make-cadir pki-falcot\n"
"</userinput><computeroutput>$ </computeroutput><userinput>cd pki-falcot</userinput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>make-cadir pki-falcot\n"
"</userinput><computeroutput>$ </computeroutput><userinput>cd pki-falcot</userinput>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "They then store the required parameters into the <filename>vars</filename> file, especially those named with a <literal>KEY_</literal> prefix; these variables are then integrated into the environment:"
msgstr "<emphasis>easy-rsa</emphasis> ツールは必要なパラメータを <filename>vars</filename> ファイルに保存します。パラメータには特に <literal>KEY_</literal> 接頭辞が付けられています。これらの変数は環境変数に組み込まれます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>vim vars\n"
"</userinput><computeroutput>$ </computeroutput><userinput>grep KEY_ vars\n"
"</userinput><computeroutput>export KEY_CONFIG=`$EASY_RSA/whichopensslcnf $EASY_RSA`\n"
"export KEY_DIR=\"$EASY_RSA/keys\"\n"
"echo NOTE: If you run ./clean-all, I will be doing a rm -rf on $KEY_DIR\n"
"export KEY_SIZE=2048\n"
"export KEY_EXPIRE=3650\n"
"export KEY_COUNTRY=\"FR\"\n"
"export KEY_PROVINCE=\"Loire\"\n"
"export KEY_CITY=\"Saint-Étienne\"\n"
"export KEY_ORG=\"Falcot Corp\"\n"
"export KEY_EMAIL=\"admin@falcot.com\"\n"
"export KEY_OU=\"Certificate authority\"\n"
"export KEY_NAME=\"Certificate authority for Falcot Corp\"\n"
"# If you'd like to sign all keys with the same Common Name, uncomment the KEY_CN export below\n"
"# export KEY_CN=\"CommonName\"\n"
"$ </computeroutput><userinput>. ./vars\n"
"</userinput><computeroutput>NOTE: If you run ./clean-all, I will be doing a rm -rf on /home/roland/pki-falcot/keys\n"
"$ </computeroutput><userinput>./clean-all\n"
"</userinput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>vim vars\n"
"</userinput><computeroutput>$ </computeroutput><userinput>grep KEY_ vars\n"
"</userinput><computeroutput>export KEY_CONFIG=`$EASY_RSA/whichopensslcnf $EASY_RSA`\n"
"export KEY_DIR=\"$EASY_RSA/keys\"\n"
"echo NOTE: If you run ./clean-all, I will be doing a rm -rf on $KEY_DIR\n"
"export KEY_SIZE=2048\n"
"export KEY_EXPIRE=3650\n"
"export KEY_COUNTRY=\"FR\"\n"
"export KEY_PROVINCE=\"Loire\"\n"
"export KEY_CITY=\"Saint-Étienne\"\n"
"export KEY_ORG=\"Falcot Corp\"\n"
"export KEY_EMAIL=\"admin@falcot.com\"\n"
"export KEY_OU=\"Certificate authority\"\n"
"export KEY_NAME=\"Certificate authority for Falcot Corp\"\n"
"# If you'd like to sign all keys with the same Common Name, uncomment the KEY_CN export below\n"
"# export KEY_CN=\"CommonName\"\n"
"$ </computeroutput><userinput>. ./vars\n"
"</userinput><computeroutput>NOTE: If you run ./clean-all, I will be doing a rm -rf on /home/roland/pki-falcot/keys\n"
"$ </computeroutput><userinput>./clean-all\n"
"</userinput>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The next step is the creation of the CA's key pair itself (the two parts of the key pair will be stored under <filename>keys/ca.crt</filename> and <filename>keys/ca.key</filename> during this step):"
msgstr "次にプライベート認証局の鍵ペアを作成します (この最中に、鍵ペアの 2 つの部分が <filename>keys/ca.crt</filename> と <filename>keys/ca.key</filename> に保存されます)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>./build-ca</userinput>\n"
"<computeroutput>Generating a 2048 bit RSA private key\n"
"...................................................................+++\n"
"...+++\n"
"writing new private key to 'ca.key'\n"
"-----\n"
"You are about to be asked to enter information that will be incorporated\n"
"into your certificate request.\n"
"What you are about to enter is what is called a Distinguished Name or a DN.\n"
"There are quite a few fields but you can leave some blank\n"
"For some fields there will be a default value,\n"
"If you enter '.', the field will be left blank.\n"
"-----\n"
"Country Name (2 letter code) [FR]:\n"
"State or Province Name (full name) [Loire]:\n"
"Locality Name (eg, city) [Saint-Étienne]:\n"
"Organization Name (eg, company) [Falcot Corp]:\n"
"Organizational Unit Name (eg, section) [Certificate authority]:\n"
"Common Name (eg, your name or your server's hostname) [Falcot Corp CA]:\n"
"Name [Certificate authority for Falcot Corp]:\n"
"Email Address [admin@falcot.com]:\n"
"</computeroutput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>./build-ca</userinput>\n"
"<computeroutput>Generating a 2048 bit RSA private key\n"
"...................................................................+++\n"
"...+++\n"
"writing new private key to 'ca.key'\n"
"-----\n"
"You are about to be asked to enter information that will be incorporated\n"
"into your certificate request.\n"
"What you are about to enter is what is called a Distinguished Name or a DN.\n"
"There are quite a few fields but you can leave some blank\n"
"For some fields there will be a default value,\n"
"If you enter '.', the field will be left blank.\n"
"-----\n"
"Country Name (2 letter code) [FR]:\n"
"State or Province Name (full name) [Loire]:\n"
"Locality Name (eg, city) [Saint-Étienne]:\n"
"Organization Name (eg, company) [Falcot Corp]:\n"
"Organizational Unit Name (eg, section) [Certificate authority]:\n"
"Common Name (eg, your name or your server's hostname) [Falcot Corp CA]:\n"
"Name [Certificate authority for Falcot Corp]:\n"
"Email Address [admin@falcot.com]:\n"
"</computeroutput>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The certificate for the VPN server can now be created, as well as the Diffie-Hellman parameters required for the server side of an SSL/TLS connection. The VPN server is identified by its DNS name <literal>vpn.falcot.com</literal>; this name is re-used for the generated key files (<filename>keys/vpn.falcot.com.crt</filename> for the public certificate, <filename>keys/vpn.falcot.com.key</filename> for the private key):"
msgstr "これで VPN サーバの証明書および SSL/TLS 接続のサーバ側に必要な Diffie-Hellman パラメータを作ることが可能になりました。VPN サーバは DNS 名 <literal>vpn.falcot.com</literal> で識別されます。ここで指定した DNS 名は作成される鍵ファイルの名前としても使われます (<filename>keys/vpn.falcot.com.crt</filename> は公開鍵証明書、<filename>keys/vpn.falcot.com.key</filename> は秘密鍵です)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>./build-key-server vpn.falcot.com\n"
"</userinput><computeroutput>Generating a 2048 bit RSA private key\n"
".....................................................................................................................+++\n"
"...........+++\n"
"writing new private key to 'vpn.falcot.com.key'\n"
"-----\n"
"You are about to be asked to enter information that will be incorporated\n"
"into your certificate request.\n"
"What you are about to enter is what is called a Distinguished Name or a DN.\n"
"There are quite a few fields but you can leave some blank\n"
"For some fields there will be a default value,\n"
"If you enter '.', the field will be left blank.\n"
"-----\n"
"Country Name (2 letter code) [FR]:\n"
"State or Province Name (full name) [Loire]:\n"
"Locality Name (eg, city) [Saint-Étienne]:\n"
"Organization Name (eg, company) [Falcot Corp]:\n"
"Organizational Unit Name (eg, section) [Certificate authority]:\n"
"Common Name (eg, your name or your server's hostname) [vpn.falcot.com]:\n"
"Name [Certificate authority for Falcot Corp]:\n"
"Email Address [admin@falcot.com]:\n"
"\n"
"Please enter the following 'extra' attributes\n"
"to be sent with your certificate request\n"
"A challenge password []:\n"
"An optional company name []:\n"
"Using configuration from /home/roland/pki-falcot/openssl-1.0.0.cnf\n"
"Check that the request matches the signature\n"
"Signature ok\n"
"The Subject's Distinguished Name is as follows\n"
"countryName           :PRINTABLE:'FR'\n"
"stateOrProvinceName   :PRINTABLE:'Loire'\n"
"localityName          :T61STRING:'Saint-\\0xFFFFFFC3\\0xFFFFFF89tienne'\n"
"organizationName      :PRINTABLE:'Falcot Corp'\n"
"organizationalUnitName:PRINTABLE:'Certificate authority'\n"
"commonName            :PRINTABLE:'vpn.falcot.com'\n"
"name                  :PRINTABLE:'Certificate authority for Falcot Corp'\n"
"emailAddress          :IA5STRING:'admin@falcot.com'\n"
"Certificate is to be certified until Mar  6 14:54:56 2025 GMT (3650 days)\n"
"Sign the certificate? [y/n]:</computeroutput><userinput>y\n"
"</userinput><computeroutput>\n"
"\n"
"1 out of 1 certificate requests certified, commit? [y/n]</computeroutput><userinput>y\n"
"</userinput><computeroutput>Write out database with 1 new entries\n"
"Data Base Updated\n"
"$ </computeroutput><userinput>./build-dh\n"
"</userinput><computeroutput>Generating DH parameters, 2048 bit long safe prime, generator 2\n"
"This is going to take a long time\n"
"[…]\n"
"</computeroutput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>./build-key-server vpn.falcot.com\n"
"</userinput><computeroutput>Generating a 2048 bit RSA private key\n"
".....................................................................................................................+++\n"
"...........+++\n"
"writing new private key to 'vpn.falcot.com.key'\n"
"-----\n"
"You are about to be asked to enter information that will be incorporated\n"
"into your certificate request.\n"
"What you are about to enter is what is called a Distinguished Name or a DN.\n"
"There are quite a few fields but you can leave some blank\n"
"For some fields there will be a default value,\n"
"If you enter '.', the field will be left blank.\n"
"-----\n"
"Country Name (2 letter code) [FR]:\n"
"State or Province Name (full name) [Loire]:\n"
"Locality Name (eg, city) [Saint-Étienne]:\n"
"Organization Name (eg, company) [Falcot Corp]:\n"
"Organizational Unit Name (eg, section) [Certificate authority]:\n"
"Common Name (eg, your name or your server's hostname) [vpn.falcot.com]:\n"
"Name [Certificate authority for Falcot Corp]:\n"
"Email Address [admin@falcot.com]:\n"
"\n"
"Please enter the following 'extra' attributes\n"
"to be sent with your certificate request\n"
"A challenge password []:\n"
"An optional company name []:\n"
"Using configuration from /home/roland/pki-falcot/openssl-1.0.0.cnf\n"
"Check that the request matches the signature\n"
"Signature ok\n"
"The Subject's Distinguished Name is as follows\n"
"countryName           :PRINTABLE:'FR'\n"
"stateOrProvinceName   :PRINTABLE:'Loire'\n"
"localityName          :T61STRING:'Saint-\\0xFFFFFFC3\\0xFFFFFF89tienne'\n"
"organizationName      :PRINTABLE:'Falcot Corp'\n"
"organizationalUnitName:PRINTABLE:'Certificate authority'\n"
"commonName            :PRINTABLE:'vpn.falcot.com'\n"
"name                  :PRINTABLE:'Certificate authority for Falcot Corp'\n"
"emailAddress          :IA5STRING:'admin@falcot.com'\n"
"Certificate is to be certified until Mar  6 14:54:56 2025 GMT (3650 days)\n"
"Sign the certificate? [y/n]:</computeroutput><userinput>y\n"
"</userinput><computeroutput>\n"
"\n"
"1 out of 1 certificate requests certified, commit? [y/n]</computeroutput><userinput>y\n"
"</userinput><computeroutput>Write out database with 1 new entries\n"
"Data Base Updated\n"
"$ </computeroutput><userinput>./build-dh\n"
"</userinput><computeroutput>Generating DH parameters, 2048 bit long safe prime, generator 2\n"
"This is going to take a long time\n"
"[…]\n"
"</computeroutput>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The following step creates certificates for the VPN clients; one certificate is required for each computer or person allowed to use the VPN:"
msgstr "以下では、VPN クライアント用の証明書を作成します。VPN を利用するコンピュータ 1 台ごとおよび人間 1 人ずつに 1 つの証明書が必要です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>./build-key JoeSmith\n"
"</userinput><computeroutput>Generating a 2048 bit RSA private key\n"
"................................+++\n"
"..............................................+++\n"
"writing new private key to 'JoeSmith.key'\n"
"-----\n"
"You are about to be asked to enter information that will be incorporated\n"
"into your certificate request.\n"
"What you are about to enter is what is called a Distinguished Name or a DN.\n"
"There are quite a few fields but you can leave some blank\n"
"For some fields there will be a default value,\n"
"If you enter '.', the field will be left blank.\n"
"-----\n"
"Country Name (2 letter code) [FR]:\n"
"State or Province Name (full name) [Loire]:\n"
"Locality Name (eg, city) [Saint-Étienne]:\n"
"Organization Name (eg, company) [Falcot Corp]:\n"
"Organizational Unit Name (eg, section) [Certificate authority]:</computeroutput><userinput>Development unit\n"
"</userinput><computeroutput>Common Name (eg, your name or your server's hostname) [JoeSmith]:</computeroutput><userinput>Joe Smith\n"
"</userinput><computeroutput>[…]</computeroutput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>./build-key JoeSmith\n"
"</userinput><computeroutput>Generating a 2048 bit RSA private key\n"
"................................+++\n"
"..............................................+++\n"
"writing new private key to 'JoeSmith.key'\n"
"-----\n"
"You are about to be asked to enter information that will be incorporated\n"
"into your certificate request.\n"
"What you are about to enter is what is called a Distinguished Name or a DN.\n"
"There are quite a few fields but you can leave some blank\n"
"For some fields there will be a default value,\n"
"If you enter '.', the field will be left blank.\n"
"-----\n"
"Country Name (2 letter code) [FR]:\n"
"State or Province Name (full name) [Loire]:\n"
"Locality Name (eg, city) [Saint-Étienne]:\n"
"Organization Name (eg, company) [Falcot Corp]:\n"
"Organizational Unit Name (eg, section) [Certificate authority]:</computeroutput><userinput>Development unit\n"
"</userinput><computeroutput>Common Name (eg, your name or your server's hostname) [JoeSmith]:</computeroutput><userinput>Joe Smith\n"
"</userinput><computeroutput>[…]</computeroutput>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Now all certificates have been created, they need to be copied where appropriate: the root certificate's public key (<filename>keys/ca.crt</filename>) will be stored on all machines (both server and clients) as <filename>/etc/ssl/certs/Falcot_CA.crt</filename>. The server's certificate is installed only on the server (<filename>keys/vpn.falcot.com.crt</filename> goes to <filename>/etc/ssl/vpn.falcot.com.crt</filename>, and <filename>keys/vpn.falcot.com.key</filename> goes to <filename>/etc/ssl/private/vpn.falcot.com.key</filename> with restricted permissions so that only the administrator can read it), with the corresponding Diffie-Hellman parameters (<filename>keys/dh2048.pem</filename>) installed to <filename>/etc/openvpn/dh2048.pem</filename>. Client certificates are installed on the corresponding VPN client in a similar fashion."
msgstr "すべての証明書を作ったら、証明書を適切な場所にコピーする必要があります。すなわち、ルート証明書の公開鍵 (<filename>keys/ca.crt</filename>) はすべてのマシン (サーバもクライアントも) に <filename>/etc/ssl/certs/Falcot_CA.crt</filename> という名前で保存されます。サーバの証明書はサーバにだけインストールされます (<filename>keys/vpn.falcot.com.crt</filename> は <filename>/etc/ssl/vpn.falcot.com.crt</filename> へ、<filename>keys/vpn.falcot.com.key</filename> は管理者だけが読めるようなパーミッション制限を掛けるために <filename>/etc/ssl/private/vpn.falcot.com.key</filename> へインストールされます)。同時に、対応する Diffie-Hellman パラメータ (<filename>keys/dh2048.pem</filename>) は <filename>/etc/openvpn/dh2048.pem</filename> へインストールされます。クライアント証明書は対応する VPN クライアントに同様の方法でインストールされます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Configuring the OpenVPN Server"
msgstr "OpenVPN サーバの設定"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "By default, the OpenVPN initialization script tries starting all virtual private networks defined in <filename>/etc/openvpn/*.conf</filename>. Setting up a VPN server is therefore a matter of storing a corresponding configuration file in this directory. A good starting point is <filename>/usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz</filename>, which leads to a rather standard server. Of course, some parameters need to be adapted: <literal>ca</literal>, <literal>cert</literal>, <literal>key</literal> and <literal>dh</literal> need to describe the selected locations (respectively, <literal>/etc/ssl/certs/Falcot_CA.crt</literal>, <literal>/etc/ssl/vpn.falcot.com.crt</literal>, <literal>/etc/ssl/private/vpn.falcot.com.key</literal> and <literal>/etc/openvpn/dh2048.pem</literal>). The <literal>server 10.8.0.0 255.255.255.0</literal> directive defines the subnet to be used by the VPN; the server uses the first IP address in that range (<literal>10.8.0.1</literal>) and the rest of the addresses are allocated to clients."
msgstr "デフォルトで、OpenVPN 初期化スクリプトは <filename>/etc/openvpn/*.conf</filename> で定義されたすべての仮想プライベートネットワークを開始します。このため、VPN サーバをセットアップする場合、このディレクトリ内に対応する設定ファイルを配置することになります。設定ファイルの良い足掛かりとして <filename>/usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz</filename> が用意されています。これはどちらかと言えば標準的なサーバを作るためのものです。もちろん、一部のパラメータを適切に設定しなければいけません。具体的に言えば、<literal>ca</literal>、<literal>cert</literal>、<literal>key</literal>、<literal>dh</literal> パラメータを対応するファイルが設置されている場所に設定する必要があります (それぞれ、<literal>/etc/ssl/certs/Falcot_CA.crt</literal>、<literal>/etc/ssl/vpn.falcot.com.crt</literal>、<literal>/etc/ssl/private/vpn.falcot.com.key</literal>、<literal>/etc/openvpn/dh2048.pem</literal> に設定します)。<literal>server 10.8.0.0 255.255.255.0</literal> 指示文は VPN によって使われるサブネットを定義します。サーバにはこの範囲に含まれる最初の IP アドレス (<literal>10.8.0.1</literal>) が割り当てられ、クライアントには残りの IP アドレスが割り当てられます。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: $ zcat /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz | grep -v -e '^#' -e '^;' -e '^$';
msgid "With this configuration, starting OpenVPN creates the virtual network interface, usually under the <literal>tun0</literal> name. However, firewalls are often configured at the same time as the real network interfaces, which happens before OpenVPN starts. Good practice therefore recommends creating a persistent virtual network interface, and configuring OpenVPN to use this pre-existing interface. This further allows choosing the name for this interface. To this end, <command>openvpn --mktun --dev vpn --dev-type tun</command> creates a virtual network interface named <literal>vpn</literal> with type <literal>tun</literal>; this command can easily be integrated in the firewall configuration script, or in an <literal>up</literal> directive of the <filename>/etc/network/interfaces</filename> file. The OpenVPN configuration file must also be updated accordingly, with the <literal>dev vpn</literal> and <literal>dev-type tun</literal> directives."
msgstr "この設定で OpenVPN を開始すると、通常 <literal>tun0</literal> という名前の仮想ネットワークインターフェースが作成されます。しかしながら、ファイアウォールは OpenVPN の開始前に実ネットワークインターフェースと同時に設定される場合が多いです。このため、永続的な仮想ネットワークインターフェースを作成し、OpenVPN が事前に作成された仮想インターフェースを使うように設定することを推奨します。この追加的設定により、インターフェースの名前を選ぶことが可能になります。この目的を達成するには、<command>openvpn --mktun --dev vpn --dev-type tun</command> を使って <literal>tun</literal> 型の <literal>vpn</literal> と名付けられた仮想ネットワークインターフェースを作成します。さらに、このコマンドをファイアウォール設定スクリプトの中で使えば、簡単に設定を統合できます。つまり <filename>/etc/network/interfaces</filename> ファイルの <literal>up</literal> 指示文を使います。OpenVPN 設定ファイルをファイアウォール設定に対応させるためには <literal>dev vpn</literal> と <literal>dev-type tun</literal> 指示文を使います。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Barring further action, VPN clients can only access the VPN server itself by way of the <literal>10.8.0.1</literal> address. Granting the clients access to the local network (192.168.0.0/24), requires adding a <literal>push route 192.168.0.0 255.255.255.0</literal> directive to the OpenVPN configuration so that VPN clients automatically get a network route telling them that this network is reachable by way of the VPN. Furthermore, machines on the local network also need to be informed that the route to the VPN goes through the VPN server (this automatically works when the VPN server is installed on the gateway). Alternatively, the VPN server can be configured to perform IP masquerading so that connections coming from VPN clients appear as if they are coming from the VPN server instead (see <xref linkend=\"sect.gateway\" />)."
msgstr "これ以上の設定を追加しなければ、VPN クライアントは <literal>10.8.0.1</literal> アドレスの VPN サーバにアクセスできるだけです。クライアントをローカルネットワーク (192.168.0.0/24) へアクセスできる状態にするには、<literal>push route 192.168.0.0 255.255.255.0</literal> 指示文を OpenVPN 設定に追加します。こうすることで、VPN クライアントは自動的にネットワーク経路を取得し、VPN 経由でローカルネットワークに到達できるようになります。さらに、ローカルネットワークにいるマシンに対して VPN サーバに通じる VPN への経路を知らせる必要もあります (VPN サーバがゲートウェイにインストールされている場合、これは自動的に動きます)。別の方法として、VPN サーバが IP マスカレードを動かすように設定する方法があります。そうすれば、VPN クライアントからの接続はあたかもクライアントが VPN サーバからアクセスしたかのように見えます (<xref linkend=\"sect.gateway\" />を参照してください)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Configuring the OpenVPN Client"
msgstr "OpenVPN クライアントの設定"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Setting up an OpenVPN client also requires creating a configuration file in <filename>/etc/openvpn/</filename>. A standard configuration can be obtained by using <filename>/usr/share/doc/openvpn/examples/sample-config-files/client.conf</filename> as a starting point. The <literal>remote vpn.falcot.com 1194</literal> directive describes the address and port of the OpenVPN server; the <literal>ca</literal>, <literal>cert</literal> and <literal>key</literal> also need to be adapted to describe the locations of the key files."
msgstr "OpenVPN クライアントを設定する場合にも、<filename>/etc/openvpn/</filename> に設定ファイルを置きます。標準的な設定の良い足掛かりとして <filename>/usr/share/doc/openvpn/examples/sample-config-files/client.conf</filename> が用意されています。<literal>remote vpn.falcot.com 1194</literal> 指示文は OpenVPN サーバのアドレスとポート番号を表します。さらに <literal>ca</literal>、<literal>cert</literal>、<literal>key</literal> も鍵ファイルの場所に合わせて設定が必要です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "If the VPN should not be started automatically on boot, set the <literal>AUTOSTART</literal> directive to <literal>none</literal> in the <filename>/etc/default/openvpn</filename> file. Starting or stopping a given VPN connection is always possible with the commands <command>service openvpn@<replaceable>name</replaceable> start</command> and <command>service openvpn@<replaceable>name</replaceable> stop</command> (where the connection <replaceable>name</replaceable> matches the one defined in <filename>/etc/openvpn/<replaceable>name</replaceable>.conf</filename>)."
msgstr "起動時に VPN を自動的に開始したくない場合、<filename>/etc/default/openvpn</filename> ファイルの <literal>AUTOSTART</literal> 指示文に <literal>none</literal> を設定してください。VPN 接続の開始と停止は <command>service openvpn@<replaceable>name</replaceable> start</command> と <command>service openvpn@<replaceable>name</replaceable> stop</command> コマンドを使えばいつでも可能です (ここで、接続名 <replaceable>name</replaceable> は <filename>/etc/openvpn/<replaceable>name</replaceable>.conf</filename> で定義したものにマッチします)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <emphasis role=\"pkg\">network-manager-openvpn-gnome</emphasis> package contains an extension to Network Manager (see <xref linkend=\"sect.roaming-network-config\" />) that allows managing OpenVPN virtual private networks. This allows every user to configure OpenVPN connections graphically and to control them from the network management icon. <indexterm><primary><emphasis role=\"pkg\">network-manager-openvpn-gnome</emphasis></primary></indexterm>"
msgstr "<emphasis role=\"pkg\">network-manager-openvpn-gnome</emphasis> パッケージには、NetworkManager (<xref linkend=\"sect.roaming-network-config\" />を参照してください) の拡張が含まれ、これを使うことで OpenVPN 仮想プライベートネットワークを管理することが可能です。誰もがグラフィカルに OpenVPN 接続を設定し、ネットワーク管理アイコンからこれを制御することが可能です。<indexterm><primary><emphasis role=\"pkg\">network-manager-openvpn-gnome</emphasis></primary></indexterm>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Virtual Private Network with SSH"
msgstr "SSH を使った仮想プライベートネットワーク"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>SSH</primary>"
msgstr "<primary>SSH</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>PPP</primary>"
msgstr "<primary>PPP</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "There are actually two ways of creating a virtual private network with SSH. The historic one involves establishing a PPP layer over the SSH link. This method is described in a HOWTO document: <ulink type=\"block\" url=\"http://www.tldp.org/HOWTO/ppp-ssh/\" />"
msgstr "SSH を使った仮想プライベートネットワークの作成法には、2 種類の方法があります。歴史的に見て重要な方法が SSH リンクの上で PPP レイヤを確立する方法です。この方法は HOWTO 文書で説明されています。<ulink type=\"block\" url=\"http://www.tldp.org/HOWTO/ppp-ssh/\" />"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The second method is more recent, and was introduced with OpenSSH 4.3; it is now possible for OpenSSH to create virtual network interfaces (<literal>tun*</literal>) on both sides of an SSH connection, and these virtual interfaces can be configured exactly as if they were physical interfaces. The tunneling system must first be enabled by setting <literal>PermitTunnel</literal> to “yes” in the SSH server configuration file (<filename>/etc/ssh/sshd_config</filename>). When establishing the SSH connection, the creation of a tunnel must be explicitly requested with the <literal>-w any:any</literal> option (<literal>any</literal> can be replaced with the desired <literal>tun</literal> device number). This requires the user to have administrator privilege on both sides, so as to be able to create the network device (in other words, the connection must be established as root)."
msgstr "2 番目の方法はより最近の方法で、OpenSSH 4.3 で導入されました。その結果今や、OpenSSH は SSH 接続のサーバおよびクライアント側に仮想ネットワークインターフェース (<literal>tun*</literal>) を作り、仮想インターフェースをあたかも物理インターフェースのように設定することが可能です。このトンネルシステムを有効化するにはまず、SSH サーバの設定ファイル (<filename>/etc/ssh/sshd_config</filename>) の中で <literal>PermitTunnel</literal> を「yes」に設定しなければいけません。SSH 接続を確立する際には、<literal>-w any:any</literal> オプションを使って明示的にトンネルの作成を要求しなければいけません (ここで <literal>any</literal> は必要な <literal>tun</literal> デバイス番号で置き替えます)。トンネルを作成するには、サーバおよびクライアント側でそのユーザが管理者権限を持っていることが必要です。そうすればネットワークデバイスを作成することが可能です (言い換えれば、接続は root で確立されなければいけません)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Both methods for creating a virtual private network over SSH are quite straightforward. However, the VPN they provide is not the most efficient available; in particular, it does not handle high levels of traffic very well."
msgstr "SSH を使って仮想プライベートネットワークを作成する方法は、どちらもかなり直接的なものです。しかしながら、SSH の提供する VPN は最も効率のよい方法ではありません。特に、高レベルのトラフィックをうまく取り扱うことができません。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: PTAL;
msgid "The explanation is that when a TCP/IP stack is encapsulated within a TCP/IP connection (for SSH), the TCP protocol is used twice, once for the SSH connection and once within the tunnel. This leads to problems, especially due to the way TCP adapts to network conditions by altering timeout delays. The following site describes the problem in more detail: <ulink type=\"block\" url=\"http://sites.inka.de/sites/bigred/devel/tcp-tcp.html\" /> VPNs over SSH should therefore be restricted to one-off tunnels with no performance constraints."
msgstr "つまり、TCP/IP スタックが TCP/IP 接続 (SSH) の中にカプセル化される場合、TCP プロトコルは 2 回使われるという点です。1 回は SSH 接続で、もう 1 回がトンネル内です。TCP はタイムアウト遅延を変更することでネットワークの状態に接続状態を適合させる機能があるため、これは特に問題になります。以下のサイトがこの問題についてより詳しく説明しています。<ulink type=\"block\" url=\"http://sites.inka.de/sites/bigred/devel/tcp-tcp.html\" />このため、VPN over SSH はパフォーマンスに制約のない単発のトンネルに留めるべきです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "IPsec"
msgstr "IPsec"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>IPsec</primary>"
msgstr "<primary>IPsec</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>strongswan</command></primary>"
msgstr "<primary><command>strongswan</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>racoon</command></primary>"
msgstr "<primary><command>racoon</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: PTAL;
msgid "IPsec, despite being the standard in IP VPNs, is rather more involved in its implementation. The IPsec engine itself is integrated in the Linux kernel; the required user-space parts, the control and configuration tools, are provided by the <emphasis role=\"pkg\">ipsec-tools</emphasis> package. In concrete terms, each host's <filename>/etc/ipsec-tools.conf</filename> contains the parameters for <emphasis>IPsec tunnels</emphasis> (or <emphasis>Security Associations</emphasis>, in the IPsec terminology) that the host is concerned with; the <command>/etc/init.d/setkey</command> script provides a way to start and stop a tunnel (each tunnel is a secure link to another host connected to the virtual private network). This file can be built by hand from the documentation provided by the <citerefentry><refentrytitle>setkey</refentrytitle> <manvolnum>8</manvolnum></citerefentry> manual page. However, explicitly writing the parameters for all hosts in a non-trivial set of machines quickly becomes an arduous task, since the number of tunnels grows fast. Installing an IKE daemon (for <emphasis>IPsec Key Exchange</emphasis>) such as <emphasis role=\"pkg\">racoon</emphasis> or <emphasis role=\"pkg\">strongswan</emphasis> makes the process much simpler by bringing administration together at a central point, and more secure by rotating the keys periodically."
msgstr "IPsec は IP VPN の標準的ツールになりつつあるにも関わらず、IPsec の実装は複雑です。IPsec エンジンそれ自身は Linux カーネルに統合されています。ユーザ空間部分で必要となる制御と設定ツールは <emphasis role=\"pkg\">ipsec-tools</emphasis> パッケージに含まれています。具体的には、それぞれのホストの <filename>/etc/ipsec-tools.conf</filename> にはホストが接続する <emphasis>IPsec トンネル</emphasis> (IPsec 用語で <emphasis>Security Association</emphasis>) のパラメータが含まれます。<command>/etc/init.d/setkey</command> スクリプトを使うことで、トンネルを開始したり停止することが可能です (それぞれのトンネルは仮想ネットワークに接続された他のホストと安全なリンクを確立しています)。このファイルは <citerefentry><refentrytitle>setkey</refentrytitle> <manvolnum>8</manvolnum></citerefentry> マニュアルページに含まれる文書を使って手作業で作ることも可能です。しかしながら、多数のマシン群にすべてのホスト用のパラメータを明示的に書くことはすぐに難しい作業になります。なぜなら、トンネルの数はすぐに増えるからです。たとえば <emphasis role=\"pkg\">racoon</emphasis> や <emphasis role=\"pkg\">strongswan</emphasis> などの IKE (<emphasis>IPsec Key Exchange</emphasis> の略語) デーモンをインストールすることで、一元管理による作業の簡素化と鍵の定期的な切り替えによる作業の安全化が可能になります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>IKE</primary>"
msgstr "<primary>IKE</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>IPsec</primary><secondary>IPsec Key Exchange</secondary>"
msgstr "<primary>IPsec</primary><secondary>IPsec Key Exchange</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>setkey</command></primary>"
msgstr "<primary><command>setkey</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "In spite of its status as the reference, the complexity of setting up IPsec restricts its usage in practice. OpenVPN-based solutions will generally be preferred when the required tunnels are neither too many nor too dynamic."
msgstr "IPsec は標準規格という地位があるにも関わらず、その設定が複雑なことが原因で実際にはあまり使われていません。必要なトンネルが少なくて静的な場合は、OpenVPN に基づく解決策が通常好まれます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>CAUTION</emphasis> IPsec and NAT"
msgstr "<emphasis>CAUTION</emphasis> IPsec と NAT"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "NATing firewalls and IPsec do not work well together: since IPsec signs the packets, any change on these packets that the firewall might perform will void the signature, and the packets will be rejected at their destination. Various IPsec implementations now include the <emphasis>NAT-T</emphasis> technique (for <emphasis>NAT Traversal</emphasis>), which basically encapsulates the IPsec packet within a standard UDP packet."
msgstr "ファイアウォールの NAT は IPsec とうまく共存しません。なぜなら、IPsec はパケットを署名しますが、ファイアウォールがパケットを書き換えることで IPsec による署名は無効化され、無効な署名のパケットは受け取り側で拒否されるからです。今やさまざまな IPsec 実装が <emphasis>NAT-T</emphasis> (<emphasis>NAT Traversal</emphasis> の略語) 技術をサポートしています。これは基本的に IPsec パケットを標準的な UDP パケットにカプセル化するものです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>NAT-T</primary>"
msgstr "<primary>NAT-T</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>NAT Traversal</primary>"
msgstr "<primary>NAT Traversal</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>SECURITY</emphasis> IPsec and firewalls"
msgstr "<emphasis>SECURITY</emphasis> IPsec とファイアウォール"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The standard mode of operation of IPsec involves data exchanges on UDP port 500 for key exchanges (also on UDP port 4500 in the case that NAT-T is in use). Moreover, IPsec packets use two dedicated IP protocols that the firewall must let through; reception of these packets is based on their protocol numbers, 50 (ESP) and 51 (AH)."
msgstr "IPsec の動作の標準的モードは鍵交換に UDP ポート 500 番 (NAT-T を使用する場合 UDP ポート 4500 番) を使います。さらに、IPsec パケットは 2 種類の専用 IP プロトコルを使います。ファイアウォールはこのプロトコルを通過させなければいけません。さらに、これらのパケットの受け入れ可否はプロトコル番号 (ESP は 50 番、AH は 51 番) に基づきます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>ESP, protocol</primary>"
msgstr "<primary>ESP、プロトコル</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>AH, protocol</primary>"
msgstr "<primary>AH、プロトコル</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>protocol</primary><secondary>AH</secondary>"
msgstr "<primary>プロトコル</primary><secondary>AH</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>protocol</primary><secondary>ESP</secondary>"
msgstr "<primary>プロトコル</primary><secondary>ESP</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "PPTP"
msgstr "PPTP"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "PPTP (for <emphasis>Point-to-Point Tunneling Protocol</emphasis>) uses two communication channels, one for control data and one for payload data; the latter uses the GRE protocol (<emphasis>Generic Routing Encapsulation</emphasis>). A standard PPP link is then set up over the data exchange channel."
msgstr "PPTP (<emphasis>Point-to-Point Tunneling Protocol</emphasis> の略語) は 2 種類の通信チャンネルを使います。1 つは制御データ用で、もう 1 つがペイロードデータ用です。ペイロードデータ用チャンネルは GRE プロトコル (<emphasis>Generic Routing Encapsulation</emphasis>) を使います。標準的な PPP リンクはペイロードデータ交換用チャンネル上に確立されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>PPTP</primary>"
msgstr "<primary>PPTP</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Point-to-Point Tunneling Protocol</primary>"
msgstr "<primary>Point-to-Point Tunneling Protocol</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>GRE, protocol</primary>"
msgstr "<primary>GRE、プロトコル</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>protocol</primary><secondary>GRE</secondary>"
msgstr "<primary>プロトコル</primary><secondary>GRE</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Configuring the Client"
msgstr "クライアントの設定"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <emphasis role=\"pkg\">pptp-linux</emphasis> package contains an easily-configured PPTP client for Linux. The following instructions take their inspiration from the official documentation: <ulink type=\"block\" url=\"http://pptpclient.sourceforge.net/howto-debian.phtml\" />"
msgstr "<emphasis role=\"pkg\">pptp-linux</emphasis> パッケージには Linux 用に簡単に設定できる PPTP クライアントが含まれています。以下の説明は公式文書からヒントを得て作ったものです。<ulink type=\"block\" url=\"http://pptpclient.sourceforge.net/howto-debian.phtml\" />"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis role=\"pkg\">pptp-linux</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">pptp-linux</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The Falcot administrators created several files: <filename>/etc/ppp/options.pptp</filename>, <filename>/etc/ppp/peers/falcot</filename>, <filename>/etc/ppp/ip-up.d/falcot</filename>, and <filename>/etc/ppp/ip-down.d/falcot</filename>."
msgstr "Falcot の管理者はいくつかのファイルを作成しました。すなわち <filename>/etc/ppp/options.pptp</filename>、<filename>/etc/ppp/peers/falcot</filename>、<filename>/etc/ppp/ip-up.d/falcot</filename>、<filename>/etc/ppp/ip-down.d/falcot</filename> を作成しました。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <filename>/etc/ppp/options.pptp</filename> file"
msgstr "<filename>/etc/ppp/options.pptp</filename> ファイル"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"# PPP options used for a PPTP connection\n"
"lock\n"
"noauth\n"
"nobsdcomp\n"
"nodeflate"
msgstr ""
"\n"
"# PPTP 接続時に利用する PPP オプション\n"
"lock\n"
"noauth\n"
"nobsdcomp\n"
"nodeflate"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <filename>/etc/ppp/peers/falcot</filename> file"
msgstr "<filename>/etc/ppp/peers/falcot</filename> ファイル"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: man 8 pptp;
msgid ""
"\n"
"# vpn.falcot.com is the PPTP server\n"
"pty \"pptp vpn.falcot.com --nolaunchpppd\"\n"
"# the connection will identify as the \"vpn\" user\n"
"user vpn\n"
"remotename pptp\n"
"# encryption is needed\n"
"require-mppe-128\n"
"file /etc/ppp/options.pptp\n"
"ipparam falcot"
msgstr ""
"\n"
"# vpn.falcot.com は PPTP サーバです\n"
"pty \"pptp vpn.falcot.com --nolaunchpppd\"\n"
"# \"vpn\" ユーザで本人確認して接続します\n"
"user vpn\n"
"remotename pptp\n"
"# 暗号化を有効にします\n"
"require-mppe-128\n"
"file /etc/ppp/options.pptp\n"
"ipparam falcot"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <filename>/etc/ppp/ip-up.d/falcot</filename> file"
msgstr "<filename>/etc/ppp/ip-up.d/falcot</filename> ファイル"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"# Create the route to the Falcot network\n"
"if [ \"$6\" = \"falcot\" ]; then\n"
"  # 192.168.0.0/24 is the (remote) Falcot network\n"
"  route add -net 192.168.0.0 netmask 255.255.255.0 dev $1\n"
"fi"
msgstr ""
"\n"
"# Falcot ネットワークへの経路を作成します\n"
"if [ \"$6\" = \"falcot\" ]; then\n"
"  # 192.168.0.0/24 is the (remote) Falcot network\n"
"  route add -net 192.168.0.0 netmask 255.255.255.0 dev $1\n"
"fi"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <filename>/etc/ppp/ip-down.d/falcot</filename> file"
msgstr "<filename>/etc/ppp/ip-down.d/falcot</filename> ファイル"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"# Delete the route to the Falcot network\n"
"if [ \"$6\" = \"falcot\" ]; then\n"
"  # 192.168.0.0/24 is the (remote) Falcot network\n"
"  route del -net 192.168.0.0 netmask 255.255.255.0 dev $1\n"
"fi"
msgstr ""
"\n"
"# Falcot ネットワークへの経路を削除します\n"
"if [ \"$6\" = \"falcot\" ]; then\n"
"  # 192.168.0.0/24 is the (remote) Falcot network\n"
"  route del -net 192.168.0.0 netmask 255.255.255.0 dev $1\n"
"fi"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>SECURITY</emphasis> MPPE"
msgstr "<emphasis>SECURITY</emphasis> MPPE"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Securing PPTP involves using the MPPE feature (<emphasis>Microsoft Point-to-Point Encryption</emphasis>), which is available in official Debian kernels as a module."
msgstr "PPTP を安全なものにするには MPPE 機能 (<emphasis>Microsoft Point-to-Point Encryption</emphasis>) を使います。MPPE はモジュールとして公式の Debian カーネルで利用できます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>MPPE</primary>"
msgstr "<primary>MPPE</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Microsoft</primary><secondary>Point-to-Point Encryption</secondary>"
msgstr "<primary>Microsoft</primary><secondary>Point-to-Point Encryption</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Configuring the Server"
msgstr "サーバの設定"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>CAUTION</emphasis> PPTP and firewalls"
msgstr "<emphasis>CAUTION</emphasis> PPTP とファイアウォール"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Intermediate firewalls need to be configured to let through IP packets using protocol 47 (GRE). Moreover, the PPTP server's port 1723 needs to be open so that the communication channel can happen."
msgstr "中間ファイアウォールはプロトコル 47 番 (GRE) を使っている IP パケットを通過させるように設定されなければいけません。さらに、通信チャンネルを開くために PPTP サーバのポート 1723 番を開けることが必要です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<command>pptpd</command> is the PPTP server for Linux. Its main configuration file, <filename>/etc/pptpd.conf</filename>, requires very few changes: <emphasis>localip</emphasis> (local IP address) and <emphasis>remoteip</emphasis> (remote IP address). In the example below, the PPTP server always uses the <literal>192.168.0.199</literal> address, and PPTP clients receive IP addresses from <literal>192.168.0.200</literal> to <literal>192.168.0.250</literal>."
msgstr "<command>pptpd</command> は Linux 用の PPTP サーバです。主設定ファイル <filename>/etc/pptpd.conf</filename> にはいくつかの変更が必要です。すなわち <emphasis>localip</emphasis> (ローカル IP アドレス) と <emphasis>remoteip</emphasis> (リモート IP アドレス) を変更する必要があります。以下の例では、PPTP サーバは常に <literal>192.168.0.199</literal> アドレスを使い、PPTP クライアントは <literal>192.168.0.200</literal> から <literal>192.168.0.250</literal> までの IP アドレスを受け取ります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <filename>/etc/pptpd.conf</filename> file"
msgstr "<filename>/etc/pptpd.conf</filename> ファイル"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: man 5 pptpd.conf;
msgid ""
"\n"
"# TAG: speed\n"
"#\n"
"#       Specifies the speed for the PPP daemon to talk at.\n"
"#\n"
"speed 115200\n"
"\n"
"# TAG: option\n"
"#\n"
"#       Specifies the location of the PPP options file.\n"
"#       By default PPP looks in '/etc/ppp/options'\n"
"#\n"
"option /etc/ppp/pptpd-options\n"
"\n"
"# TAG: debug\n"
"#\n"
"#       Turns on (more) debugging to syslog\n"
"#\n"
"# debug\n"
"\n"
"# TAG: localip\n"
"# TAG: remoteip\n"
"#\n"
"#       Specifies the local and remote IP address ranges.\n"
"#\n"
"#       You can specify single IP addresses separated by commas or you can\n"
"#       specify ranges, or both. For example:\n"
"#\n"
"#               192.168.0.234,192.168.0.245-249,192.168.0.254\n"
"#\n"
"#       IMPORTANT RESTRICTIONS:\n"
"#\n"
"#       1. No spaces are permitted between commas or within addresses.\n"
"#\n"
"#       2. If you give more IP addresses than MAX_CONNECTIONS, it will\n"
"#          start at the beginning of the list and go until it gets\n"
"#          MAX_CONNECTIONS IPs. Others will be ignored.\n"
"#\n"
"#       3. No shortcuts in ranges! ie. 234-8 does not mean 234 to 238,\n"
"#          you must type 234-238 if you mean this.\n"
"#\n"
"#       4. If you give a single localIP, that's ok - all local IPs will\n"
"#          be set to the given one. You MUST still give at least one remote\n"
"#          IP for each simultaneous client.\n"
"#\n"
"#localip 192.168.0.234-238,192.168.0.245\n"
"#remoteip 192.168.1.234-238,192.168.1.245\n"
"#localip 10.0.1.1\n"
"#remoteip 10.0.1.2-100\n"
"localip 192.168.0.199\n"
"remoteip 192.168.0.200-250"
msgstr ""
"\n"
"# TAG: speed\n"
"#\n"
"#       PPTP デーモンの通信速度を指定します。\n"
"#\n"
"speed 115200\n"
"\n"
"# TAG: option\n"
"#\n"
"#       PPP オプションファイルの場所を指定します。\n"
"#       PPP はデフォルトで '/etc/ppp/options' を使います\n"
"#\n"
"option /etc/ppp/pptpd-options\n"
"\n"
"# TAG: debug\n"
"#\n"
"#       syslog に詳細なデバッグ情報を出力します\n"
"#\n"
"# debug\n"
"\n"
"# TAG: localip\n"
"# TAG: remoteip\n"
"#\n"
"#       ローカルとリモートの IP アドレス範囲を指定します。\n"
"#\n"
"#       コンマで区切ることで、単独の IP アドレスおよび\n"
"#       IP アドレス範囲を指定できます。以下は利用例です。\n"
"#\n"
"#               192.168.0.234,192.168.0.245-249,192.168.0.254\n"
"#\n"
"#       以下の重要な制約事項に注意してください。\n"
"#\n"
"#       1. コンマ間およびアドレス内部で空白文字を使わないでください。\n"
"#\n"
"#       2. MAX_CONNECTIONS よりも多くの IP アドレス を指定した場合、\n"
"#          使われる IP アドレスはリストの先頭から MAX_CONNECTIONS\n"
"#          個までの IP アドレスです。それ以外は使われません。\n"
"#\n"
"#       3. アドレス範囲を略記しないでください! たとえば 234 から 238 の範囲を指定するために\n"
"#          234-8 と記述するのは間違いです。その代わり 234-238 と記述してください。\n"
"#\n"
"#       4. ローカル IP は 1 つだけでも構いません。この場合、すべてのローカル IP は\n"
"#          指定したものになります。しかしながら、同時接続中のクライアントには\n"
"#          必ず異なるリモート IP を割り振らなければいけません。\n"
"#\n"
"#localip 192.168.0.234-238,192.168.0.245\n"
"#remoteip 192.168.1.234-238,192.168.1.245\n"
"#localip 10.0.1.1\n"
"#remoteip 10.0.1.2-100\n"
"localip 192.168.0.199\n"
"remoteip 192.168.0.200-250"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The PPP configuration used by the PPTP server also requires a few changes in <filename>/etc/ppp/pptpd-options</filename>. The important parameters are the server name (<literal>pptp</literal>), the domain name (<literal>falcot.com</literal>), and the IP addresses for DNS and WINS servers."
msgstr "さらに <filename>/etc/ppp/pptpd-options</filename> を編集して、PPTP サーバの使う PPP 設定を変更します。重要なパラメータはサーバ名 (<literal>pptp</literal>)、ドメイン名 (<literal>falcot.com</literal>)、DNS と WINS サーバの IP アドレスです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <filename>/etc/ppp/pptpd-options</filename> file"
msgstr "<filename>/etc/ppp/pptpd-options</filename> ファイル"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: http://www.tldp.org/LDP/nag2/x-087-2-ppp.authentication.html;
msgid ""
"\n"
"## turn pppd syslog debugging on\n"
"#debug\n"
"\n"
"## change 'servername' to whatever you specify as your server name in chap-secrets\n"
"name pptp\n"
"## change the domainname to your local domain\n"
"domain falcot.com\n"
"\n"
"## these are reasonable defaults for WinXXXX clients\n"
"## for the security related settings\n"
"# The Debian pppd package now supports both MSCHAP and MPPE, so enable them\n"
"# here. Please note that the kernel support for MPPE must also be present!\n"
"auth\n"
"require-chap\n"
"require-mschap\n"
"require-mschap-v2\n"
"require-mppe-128\n"
"\n"
"## Fill in your addresses\n"
"ms-dns 192.168.0.1\n"
"ms-wins 192.168.0.1\n"
"\n"
"## Fill in your netmask\n"
"netmask 255.255.255.0\n"
"\n"
"## some defaults\n"
"nodefaultroute\n"
"proxyarp\n"
"lock"
msgstr ""
"\n"
"## pppd の syslog デバッグを有効化します\n"
"#debug\n"
"\n"
"## 「サーバ名」を chap-secrets 内の自分のサーバ名として指定したものに変更します\n"
"name pptp\n"
"## ドメイン名をローカルドメインに変更します\n"
"domain falcot.com\n"
"\n"
"## 以下は WinXXXX クライアントに対して\n"
"## 適当とされるデフォルトセキュリティ関連設定です\n"
"# Debian の pppd パッケージは MSCHAP と MPPE の両方をサポートしています。そのため\n"
"# ここでは両方を有効化しています。カーネルの MPPE サポートが必須という点にも注意してください!\n"
"auth\n"
"require-chap\n"
"require-mschap\n"
"require-mschap-v2\n"
"require-mppe-128\n"
"\n"
"## サービスに対応するアドレスを指定してください\n"
"ms-dns 192.168.0.1\n"
"ms-wins 192.168.0.1\n"
"\n"
"## ネットマスクを指定してください\n"
"netmask 255.255.255.0\n"
"\n"
"## 一部のデフォルト設定\n"
"nodefaultroute\n"
"proxyarp\n"
"lock"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The last step involves registering the <literal>vpn</literal> user (and the associated password) in the <filename>/etc/ppp/chap-secrets</filename> file. Contrary to other instances where an asterisk (<literal>*</literal>) would work, the server name must be filled explicitly here. Furthermore, Windows PPTP clients identify themselves under the <literal><replaceable>DOMAIN</replaceable>\\\\<replaceable>USER</replaceable></literal> form, instead of only providing a user name. This explains why the file also mentions the <literal>FALCOT\\\\vpn</literal> user. It is also possible to specify individual IP addresses for users; an asterisk in this field specifies that dynamic addressing should be used."
msgstr "最後に、<literal>vpn</literal> ユーザ (と対応するパスワード) を <filename>/etc/ppp/chap-secrets</filename> ファイルに登録します。サーバ名だけは、アスタリスク (<literal>*</literal>) を使える他のインスタンスと異なり、明示的に指定しなければいけません。さらに、Windows PPTP クライアントはユーザ名ではなく <literal><replaceable>DOMAIN</replaceable>\\\\<replaceable>USER</replaceable></literal> という形を認証を行います。このため、<filename>/etc/ppp/chap-secrets</filename> ファイルに <literal>FALCOT\\\\vpn</literal> ユーザが追加されています。ユーザに割り当てる IP アドレスを明記することも可能です。IP アドレスフィールドのアスタリスクは動的にアドレスを割り当てることを意味します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <filename>/etc/ppp/chap-secrets</filename> file"
msgstr "<filename>/etc/ppp/chap-secrets</filename> ファイル"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: http://www.tldp.org/LDP/nag/node121.html;
# Ref: http://www.tldp.org/LDP/nag2/x-087-2-ppp.authentication.html;
msgid ""
"\n"
"# Secrets for authentication using CHAP\n"
"# client        server  secret      IP addresses\n"
"vpn             pptp    f@Lc3au     *\n"
"FALCOT\\\\vpn     pptp    f@Lc3au     *"
msgstr ""
"\n"
"# CHAP 認証用のログイン情報\n"
"# クライアント  サーバ  秘密情報    IP アドレス\n"
"vpn             pptp    f@Lc3au     *\n"
"FALCOT\\\\vpn     pptp    f@Lc3au     *"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>SECURITY</emphasis> PPTP vulnerabilities"
msgstr "<emphasis>SECURITY</emphasis> PPTP 脆弱性"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Microsoft's first PPTP implementation drew severe criticism because it had many security vulnerabilities; most have since then been fixed in more recent versions. The configuration documented in this section uses the latest version of the protocol. Be aware though that removing some options (such as <literal>require-mppe-128</literal> and <literal>require-mschap-v2</literal>) would make the service vulnerable again."
msgstr "Microsoft の最初の PPTP 実装は多くのセキュリティ脆弱性を残していたためにさまざまな非難を浴びました。しかし、最近のバージョンではその多くが修正されています。この節で説明されている設定は PPTP プロトコルの最新のバージョンを使っています。いくつかのオプション (<literal>require-mppe-128</literal> や <literal>require-mschap-v2</literal> など) を無効化すると、サービスに脆弱性が生まれるという点に注意してください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Quality of Service"
msgstr "Quality of Service"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Principle and Mechanism"
msgstr "原理とメカニズム"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>Quality of Service</emphasis> (or <emphasis>QoS</emphasis> for short) refers to a set of techniques that guarantee or improve the quality of the service provided to applications. The most popular such technique involves classifying the network traffic into categories, and differentiating the handling of traffic according to which category it belongs to. The main application of this differentiated services concept is <emphasis>traffic shaping</emphasis>, which limits the data transmission rates for connections related to some services and/or hosts so as not to saturate the available bandwidth and starve important other services. Traffic shaping is a particularly good fit for TCP traffic, since this protocol automatically adapts to available bandwidth."
msgstr "<emphasis>Quality of Service (サービスの品質)</emphasis> (略して <emphasis>QoS</emphasis>) はアプリケーションに提供されるサービスの品質を向上させる技術群を指します。最もよく使われる技術はネットワークトラフィックをカテゴリ分けして、トラフィックの所属するカテゴリごとにその取り扱いに違いを付ける技術です。サービスを差別化するという概念の主な用途が<emphasis>トラフィックシェーピング</emphasis>です。これは一部のサービスおよびホストに関連する接続のデータの転送率を制限します。これを使うことで、利用できる帯域幅が飽和することを避け、重要な他のサービスに支障が出ないようにします。トラフィックシェーピングは TCP トラフィックに対して特に有効です。なぜなら、TCP は利用できる帯域幅に自動的に適応するからです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>QoS</primary>"
msgstr "<primary>QoS</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>quality of service</primary>"
msgstr "<primary>サービスの品質</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>quality</primary><secondary>of service</secondary>"
msgstr "<primary>品質</primary><secondary>サービスの品質</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>service</primary><secondary>quality</secondary>"
msgstr "<primary>サービス</primary><secondary>品質</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "It is also possible to alter the priorities on traffic, which allows prioritizing packets related to interactive services (such as <command>ssh</command> and <command>telnet</command>) or to services that only deal with small blocks of data."
msgstr "トラフィックの優先度を変更し、対話型サービス (<command>ssh</command> や <command>telnet</command> など) や小さなブロックのデータだけを取り扱うサービスに関連するパケットに高い優先度を付けることも可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The Debian kernels include the features required for QoS along with their associated modules. These modules are many, and each of them provides a different service, most notably by way of special schedulers for the queues of IP packets; the wide range of available scheduler behaviors spans the whole range of possible requirements."
msgstr "Debian カーネルには、QoS 関連モジュールと一緒に QoS に必要な機能が含まれています。多くのモジュールが存在し、各モジュールが異なるサービスを提供します。中でも注目すべきは IP パケットの待ち行列用の特別なスケジューラです。このスケジューラはさまざまな用途に利用できるため、考え得るさまざまな要求に対応できます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>CULTURE</emphasis> LARTC — <emphasis>Linux Advanced Routing &amp; Traffic Control</emphasis>"
msgstr "<emphasis>CULTURE</emphasis> LARTC (<emphasis>Linux Advanced Routing &amp; Traffic Control</emphasis>)"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <emphasis>Linux Advanced Routing &amp; Traffic Control</emphasis> HOWTO is the reference document covering everything there is to know about network quality of service. <ulink type=\"block\" url=\"http://www.lartc.org/howto/\" />"
msgstr "<emphasis>Linux Advanced Routing &amp; Traffic Control</emphasis> HOWTO はネットワークのサービス品質に関して知っておくべきすべての内容をカバーする基礎的な文書です。<ulink type=\"block\" url=\"http://www.lartc.org/howto/\" />"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>routing</primary><secondary>advanced</secondary>"
msgstr "<primary>ルーティング</primary><secondary>上級ルーティング</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>traffic</primary><secondary>control</secondary>"
msgstr "<primary>トラフィック</primary><secondary>制御</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>control of traffic</primary>"
msgstr "<primary>トラフィックの制御</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Configuring and Implementing"
msgstr "設定と実践"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "QoS parameters are set through the <command>tc</command> command (provided by the <emphasis role=\"pkg\">iproute</emphasis> package). Since its interface is quite complex, using higher-level tools is recommended."
msgstr "QoS パラメータは <command>tc</command> コマンド (<emphasis role=\"pkg\">iproute</emphasis> パッケージに含まれます) を使って設定します。<command>tc</command> コマンドはインターフェースがかなり複雑なので、高レベルツールを使うことを推奨します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis>iproute</emphasis></primary>"
msgstr "<primary><emphasis>iproute</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>tc</command></primary>"
msgstr "<primary><command>tc</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Reducing Latencies: <command>wondershaper</command>"
msgstr "待ち時間の低減、<command>wondershaper</command>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The main purpose of <command>wondershaper</command> (in the similarly-named package) is to minimize latencies independent of network load. This is achieved by limiting total traffic to a value that falls just short of the link saturation value."
msgstr "<command>wondershaper</command> (同名のパッケージに含まれます) の主目的はネットワーク負荷とは無関係に待ち時間を最小化することです。全トラフィックをある値に制限することにより、これは実現されます。この値には帯域を飽和させるよりほんの少しだけ小さな値を設定します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>wondershaper</command></primary>"
msgstr "<primary><command>wondershaper</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>limitation of traffic</primary>"
msgstr "<primary>トラフィックの制限</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>traffic</primary><secondary>limitation</secondary>"
msgstr "<primary>トラフィック</primary><secondary>制限</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Once a network interface is configured, setting up this traffic limitation is achieved by running <command>wondershaper <replaceable>interface</replaceable> <replaceable>download_rate</replaceable> <replaceable>upload_rate</replaceable></command>. The interface can be <literal>eth0</literal> or <literal>ppp0</literal> for example, and both rates are expressed in kilobits per second. The <command>wondershaper remove <replaceable>interface</replaceable></command> command disables traffic control on the specified interface."
msgstr "ネットワークインターフェースを設定した後、<command>wondershaper <replaceable>interface</replaceable> <replaceable>download_rate</replaceable> <replaceable>upload_rate</replaceable></command> を実行することでトラフィックが制限されます。ここで <replaceable>interface</replaceable> はたとえば <literal>eth0</literal> または <literal>ppp0</literal> などのインターフェース名で、<replaceable>download_rate</replaceable> および <replaceable>upload_rate</replaceable> はキロビット毎秒単位の値です。特定のインターフェースで実施されているトラフィック制限を無効化するには <command>wondershaper remove <replaceable>interface</replaceable></command> コマンドを使います。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "For an Ethernet connection, this script is best called right after the interface is configured. This is done by adding <literal>up</literal> and <literal>down</literal> directives to the <filename>/etc/network/interfaces</filename> file allowing declared commands to be run, respectively, after the interface is configured and before it is deconfigured. For example:"
msgstr "イーサネット接続の場合、<command>wondershaper</command> をインターフェースが設定された直後に呼び出すのが最良です。これを行うには、<filename>/etc/network/interfaces</filename> ファイルに <literal>up</literal> と <literal>down</literal> 指示文を追加して、それぞれインターフェースが開始された後と停止される前に実行するコマンドを宣言します。以下にその例を示します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Changes in the <filename>/etc/network/interfaces</filename> file"
msgstr "<filename>/etc/network/interfaces</filename> ファイルの修正"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"iface eth0 inet dhcp\n"
"    up /sbin/wondershaper eth0 500 100\n"
"    down /sbin/wondershaper remove eth0"
msgstr ""
"\n"
"iface eth0 inet dhcp\n"
"    up /sbin/wondershaper eth0 500 100\n"
"    down /sbin/wondershaper remove eth0"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "In the PPP case, creating a script that calls <command>wondershaper</command> in <filename>/etc/ppp/ip-up.d/</filename> will enable traffic control as soon as the connection is up."
msgstr "PPP の場合、<filename>/etc/ppp/ip-up.d/</filename> 内に <command>wondershaper</command> を呼び出すスクリプトを作成することで、接続が開始された後の可能な限り早い時期にトラフィック制御を行うように設定できます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>GOING FURTHER</emphasis> Optimal configuration"
msgstr "<emphasis>GOING FURTHER</emphasis> 最適な設定"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <filename>/usr/share/doc/wondershaper/README.Debian.gz</filename> file describes, in some detail, the configuration method recommended by the package maintainer. In particular, it advises measuring the download and upload speeds so as to best evaluate real limits."
msgstr "<filename>/usr/share/doc/wondershaper/README.Debian.gz</filename> ファイルでは、パッケージメンテナの推奨する設定方法が少し詳しく説明されています。特に、ダウンロードとアップロード速度を計測することを勧めています。実際の速度を計測することで、制限を適切に見積もることが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Standard Configuration"
msgstr "標準的な設定"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Barring a specific QoS configuration, the Linux kernel uses the <literal>pfifo_fast</literal> queue scheduler, which provides a few interesting features by itself. The priority of each processed IP packet is based on the ToS field (<emphasis>Type of Service</emphasis>) of this packet; modifying this field is enough to take advantage of the scheduling features. There are five possible values:"
msgstr "明示的に QoS 設定を行わない場合、Linux カーネルは <literal>pfifo_fast</literal> キュースケジューラを使います。これは興味深い機能を提供します。各 IP パケットの優先度はパケットの ToS フィールド (<emphasis>Type of Service</emphasis>) によって決まります。スケジューリング機能を活用するには、このフィールドを修正するだけで十分です。ToS フィールドの取り得る値は以下の 5 種類です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Normal-Service (0);"
msgstr "通常のサービス (0)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Minimize-Cost (2);"
msgstr "コストの最小化 (2)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Maximize-Reliability (4);"
msgstr "信頼度の最大化 (4)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Maximize-Throughput (8);"
msgstr "速度の最大化 (8)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Minimize-Delay (16)."
msgstr "遅延の最小化 (16)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>ToS</primary>"
msgstr "<primary>ToS</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Type of Service</primary>"
msgstr "<primary>Type of Service</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The ToS field can be set by applications that generate IP packets, or modified on the fly by <emphasis>netfilter</emphasis>. The following rules are sufficient to increase responsiveness for a server's SSH service:"
msgstr "ToS フィールドは IP パケットを生成するアプリケーションによって設定されるか、<emphasis>netfilter</emphasis> によってその場で修正されます。以下のルールを使うだけで、サーバの SSH サービスに対する応答性を増加させることが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"iptables -t mangle -A PREROUTING -p tcp --sport ssh -j TOS --set-tos Minimize-Delay\n"
"iptables -t mangle -A PREROUTING -p tcp --dport ssh -j TOS --set-tos Minimize-Delay"
msgstr ""
"\n"
"iptables -t mangle -A PREROUTING -p tcp --sport ssh -j TOS --set-tos Minimize-Delay\n"
"iptables -t mangle -A PREROUTING -p tcp --dport ssh -j TOS --set-tos Minimize-Delay"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Dynamic Routing"
msgstr "動的ルーティング"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>routing</primary><secondary>dynamic</secondary>"
msgstr "<primary>ルーティング</primary><secondary>動的</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>quagga</command></primary>"
msgstr "<primary><command>quagga</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>zebra</command></primary>"
msgstr "<primary><command>zebra</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The reference tool for dynamic routing is currently <command>quagga</command>, from the similarly-named package; it used to be <command>zebra</command> until development of the latter stopped. However, <command>quagga</command> kept the names of the programs for compatibility reasons which explains the <command>zebra</command> commands below."
msgstr "現在の動的ルーティングの標準ツールは <command>quagga</command> で、<command>quagga</command> は同名のパッケージに含まれます。以前の標準ツールは <command>zebra</command> でしたが、<command>zebra</command> は開発中止となったため <command>quagga</command> に取って代わられました。しかしながら、<command>quagga</command> は互換性の理由からプログラムの名前に <command>zebra</command> を使っています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> Dynamic routing"
msgstr "<emphasis>BACK TO BASICS</emphasis> 動的ルーティング"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Dynamic routing allows routers to adjust, in real time, the paths used for transmitting IP packets. Each protocol involves its own method of defining routes (shortest path, use routes advertised by peers, and so on)."
msgstr "動的ルーティングを使うことで、ルータは IP パケットの送信経路をリアルタイムで調整することが可能になります。プロトコルごとに経路を定義する方法 (最短経路、各装置が希望する経路など) は違います。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "In the Linux kernel, a route links a network device to a set of machines that can be reached through this device. The <command>route</command> command defines new routes and displays existing ones."
msgstr "Linux カーネルでは、ネットワークデバイスとそのデバイスを通過して到達できるマシン群を関連付けることで経路を定義します。<command>route</command> コマンドは新しい経路を定義したり、既存の経路を表示するために使われます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>route</command></primary>"
msgstr "<primary><command>route</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Quagga is a set of daemons cooperating to define the routing tables to be used by the Linux kernel; each routing protocol (most notably BGP, OSPF and RIP) provides its own daemon. The <command>zebra</command> daemon collects information from other daemons and handles static routing tables accordingly. The other daemons are known as <command>bgpd</command>, <command>ospfd</command>, <command>ospf6d</command>, <command>ripd</command>, <command>ripngd</command>, <command>isisd</command>, and <command>babeld</command>."
msgstr "Quagga は複数のデーモン群で、これらが協力して Linux カーネルの使うルーティングテーブルを定義します。各ルーティングプロトコル (中でも注目すべきは BGP、OSPF、RIP) に対して専用のデーモンがあります。<command>zebra</command> デーモンは他のデーモンから情報を収集し、その情報に基づき静的ルーティングテーブルを操作します。ここで他のデーモンとは、<command>bgpd</command>、<command>ospfd</command>、<command>ospf6d</command>、<command>ripd</command>、<command>ripngd</command>、<command>isisd</command>、<command>babeld</command> として知られています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>OSPF</primary>"
msgstr "<primary>OSPF</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>BGP</primary>"
msgstr "<primary>BGP</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>RIP</primary>"
msgstr "<primary>RIP</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>IS-IS</primary>"
msgstr "<primary>IS-IS</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>BABEL wireless mesh routing</primary>"
msgstr "<primary>BABEL wireless mesh routing</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>bgpd</command></primary>"
msgstr "<primary><command>bgpd</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>ospfd</command></primary>"
msgstr "<primary><command>ospfd</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>ospf6d</command></primary>"
msgstr "<primary><command>ospf6d</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>ripd</command></primary>"
msgstr "<primary><command>ripd</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>ripngd</command></primary>"
msgstr "<primary><command>ripngd</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>isisd</command></primary>"
msgstr "<primary><command>isisd</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>babeld</command></primary>"
msgstr "<primary><command>babeld</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Daemons are enabled by editing the <filename>/etc/quagga/daemons</filename> file and creating the appropriate configuration file in <filename>/etc/quagga/</filename>; this configuration file must be named after the daemon, with a <filename>.conf</filename> extension, and belong to the <literal>quagga</literal> user and the <literal>quaggavty</literal> group, in order for the <filename>/etc/init.d/quagga</filename> script to invoke the daemon."
msgstr "これらのデーモンを有効化するには、<filename>/etc/quagga/daemons</filename> ファイルを編集し、適切な設定ファイルを <filename>/etc/quagga/</filename> の中に作成してください。さらに、この設定ファイルはデーモンにちなんで命名され、<filename>.conf</filename> 拡張子を付けられ、<literal>quagga</literal> ユーザと <literal>quaggavty</literal> グループに所有されなければいけません。これは <filename>/etc/init.d/quagga</filename> スクリプトが対象のデーモンを呼び出せるようにするためです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The configuration of each of these daemons requires knowledge of the routing protocol in question. These protocols cannot be described in detail here, but the <emphasis role=\"pkg\">quagga-doc</emphasis> provides ample explanation in the form of an <command>info</command> file. The same contents may be more easily browsed as HTML on the Quagga website: <ulink type=\"block\" url=\"http://www.nongnu.org/quagga/docs/docs-info.html\" />"
msgstr "デーモンを設定するには、対象のルーティングプロトコルに関する知識が必要です。ここではそれぞれのプロトコルの詳細を説明できませんが、<emphasis role=\"pkg\">quagga-doc</emphasis> パッケージに含まれる <command>info</command> ファイルで十分な説明が行われています。また、同じ内容を Quagga のウェブサイト上で HTML として閲覧するほうが簡単かもしれません。<ulink type=\"block\" url=\"http://www.nongnu.org/quagga/docs/docs-info.html\" />"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "In addition, the syntax is very close to a standard router's configuration interface, and network administrators will adapt quickly to <command>quagga</command>."
msgstr "加えて、設定構文は標準的なルータの設定インターフェースととても似ているため、ネットワーク管理者は <command>quagga</command> に素早く順応するでしょう。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>IN PRACTICE</emphasis> OSPF, BGP or RIP?"
msgstr "<emphasis>IN PRACTICE</emphasis> OSPF、BGP、RIP?"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "OSPF is generally the best protocol to use for dynamic routing on private networks, but BGP is more common for Internet-wide routing. RIP is rather ancient, and hardly used anymore."
msgstr "一般に、OSPF はプライベートネットワークの動的ルーティングに使われる最良のプロトコルです。BGP はインターネット全体のルーティングに使われることが多いプロトコルです。RIP は比較的古典的で、ほとんど使われません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "IPv6, successor to IPv4, is a new version of the IP protocol designed to fix its flaws, most notably the scarcity of available IP addresses. This protocol handles the network layer; its purpose is to provide a way to address machines, to convey data to their intended destination, and to handle data fragmentation if needed (in other words, to split packets into chunks with a size that depends on the network links to be used on the path and to reassemble the chunks in their proper order on arrival)."
msgstr "IPv6 は IPv4 の後継で、IP プロトコルの新しいバージョンで、IPv4 の欠点 (中でも注目すべきは利用できる IP アドレスの枯渇) を解決するために設計されました。IPv6 はネットワーク層で動きます。そして IPv6 の目的はマシンをアドレス指定する方法を提供すること、目標の宛先にデータを伝達すること、必要ならばデータの断片化を取り扱うことです (言い換えれば、経路で使われるネットワークリンクに従ってパケットをあるサイズのチャンクに分割し、到着した時に適切な順番にチャンクを再構築することです)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Debian kernels include IPv6 handling in the core kernel (with the exception of some architectures that have it compiled as a module named <literal>ipv6</literal>). Basic tools such as <command>ping</command> and <command>traceroute</command> have their IPv6 equivalents in <command>ping6</command> and <command>traceroute6</command>, available respectively in the <emphasis role=\"pkg\">iputils-ping</emphasis> and <emphasis role=\"pkg\">iputils-tracepath</emphasis> packages."
msgstr "Debian カーネルは IPv6 をコアカーネルでサポートします (<literal>ipv6</literal> という名前でコンパイルされたモジュールを使って IPv6 をサポートする一部のアーキテクチャを除きます)。<command>ping</command>、<command>traceroute</command> などの基本ツールには IPv6 用の <command>ping6</command>、<command>traceroute6</command> などの代替品があり、これらはそれぞれ <emphasis role=\"pkg\">iputils-ping</emphasis>、<emphasis role=\"pkg\">iputils-tracepath</emphasis> パッケージに含まれます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>IPv6</primary>"
msgstr "<primary>IPv6</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis role=\"pkg\">iputils-ping</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">iputils-ping</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis role=\"pkg\">iputils-tracepath</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">iputils-tracepath</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The IPv6 network is configured similarly to IPv4, in <filename>/etc/network/interfaces</filename>. But if you want that network to be globally available, you must ensure that you have an IPv6-capable router relaying traffic to the global IPv6 network."
msgstr "IPv6 ネットワークは IPv4 と同様に <filename>/etc/network/interfaces</filename> で設定します。しかし、ネットワークをグローバルに利用できるようにしたい場合、グローバル IPv6 ネットワークへのトラフィックを中継するための IPv6 を取り扱うことができるルータを持っていなければいけません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Example of IPv6 configuration"
msgstr "IPv6 設定の例"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: $ man 5 interfaces;
# Ref: https://tools.ietf.org/html/rfc3849;
# Ref: http://tldp.org/HOWTO/html_single/Linux+IPv6-HOWTO/;
# Ref: http://www.tldp.org/HOWTO/Linux+IPv6-HOWTO/proc-sys-net-ipv6..html;
# Ref: http://www.gogo6.com/forum/topics/how-do-i-assign-several-ipv6;
# Ref: http://www.ruwenzori.net/ipv6/Jims_LAN_IPv6_global_connectivity_howto.html;
# Ref: https://wiki.debian.org/NetworkConfiguration;
# Tag: PTAL;
msgid ""
"\n"
"iface eth0 inet6 static\n"
"    address 2001:db8:1234:5::1:1\n"
"    netmask 64\n"
"    # Disabling auto-configuration\n"
"    # autoconf 0\n"
"    # The router is auto-configured and has no fixed address\n"
"    # (accept_ra 1). If it had:\n"
"    # gateway 2001:db8:1234:5::1"
msgstr ""
"\n"
"iface eth0 inet6 static\n"
"    address 2001:db8:1234:5::1:1\n"
"    netmask 64\n"
"    # 自動設定の無効化\n"
"    # autoconf 0\n"
"    # ルータが自動設定されており、ルータが固定アドレスを持っていない場合は\n"
"    # accept_ra 1 を有効化してください。それ以外の場合は以下を有効化してください。\n"
"    # gateway 2001:db8:1234:5::1"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "IPv6 subnets usually have a netmask of 64 bits. This means that 2<superscript>64</superscript> distinct addresses exist within the subnet. This allows Stateless Address Autoconfiguration (<acronym>SLAAC</acronym>) to pick an address based on the network interface's MAC address. By default, if <acronym>SLAAC</acronym> is activated in your network and IPv6 on your computer, the kernel will automatically find IPv6 routers and configure the network interfaces."
msgstr "IPv6 サブネットのネットマスクは通常 64 ビットです。これは、サブネットの中に 2<superscript>64</superscript> 個の異なるアドレスが存在することを意味します。この特徴のおかげで、インターフェースの MAC アドレスに基づいたアドレスを選ぶステートレスアドレス自動設定 (<acronym>SLAAC</acronym>) を使うことが可能です。ネットワークで <acronym>SLAAC</acronym> が有効化されコンピュータで IPv6 が有効化された場合、デフォルトでカーネルは自動的に IPv6 ルータを探してネットワークインターフェースを設定します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "This behavior may have privacy implications. If you switch networks frequently, e.g. with a laptop, you might not want your <acronym>MAC</acronym> address being a part of your public IPv6 address. This makes it easy to identify the same device across networks. A solution to this are IPv6 privacy extensions (which Debian enables by default if IPv6 connectivity is detected during initial installation), which will assign an additional randomly generated address to the interface, periodically change them and prefer them for outgoing connections. Incoming connections can still use the address generated by SLAAC. The following example, for use in <filename>/etc/network/interfaces</filename>, activates these privacy extensions."
msgstr "SLAAC の挙動はプライバシーを推測される危険性をはらんでいます。たとえばラップトップでネットワークを頻繁に切り替える場合、公開 IPv6 アドレスの一部に <acronym>MAC</acronym> アドレスを含めたくないかもしれません。SLAAC のせいで、異なるネットワーク上の同じデバイスを容易に識別できるようになります。この問題に対する解決策が IPv6 プライバシー拡張です (初回インストール時に IPv6 接続が検出された場合、Debian は IPv6 プライバシー拡張をデフォルトで有効化します)。IPv6 プライバシー拡張を使うとインターフェースにランダムに生成されたアドレスを割り当て、定期的にこれを変更し、外部に出る接続にはこのアドレスを使うようになります。外部から入ってくる接続は SLAAC で生成されたアドレスを使うことも可能です。以下の例では <filename>/etc/network/interfaces</filename> の中で IPv6 プライバシー拡張を有効化しています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "IPv6 privacy extensions"
msgstr "IPv6 プライバシー拡張"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"iface eth0 inet6 auto\n"
"    # Prefer the randomly assigned addresses for outgoing connections.\n"
"    privext 2"
msgstr ""
"\n"
"iface eth0 inet6 auto\n"
"    # 外部へ接続する際にランダムに割り当てられたアドレスを使います。\n"
"    privext 2"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>TIP</emphasis> Programs built with IPv6"
msgstr "<emphasis>TIP</emphasis> プログラムの IPv6 対応"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Many pieces of software need to be adapted to handle IPv6. Most of the packages in Debian have been adapted already, but not all. If your favorite package does not work with IPv6 yet, you can ask for help on the <emphasis>debian-ipv6</emphasis> mailing-list. They might know about an IPv6-aware replacement and could file a bug to get the issue properly tracked. <ulink type=\"block\" url=\"http://lists.debian.org/debian-ipv6/\" />"
msgstr "多くのソフトウェアを IPv6 に対応させる必要があります。Debian に含まれるほとんどのパッケージは既に IPv6 に対応済みですが、すべてではありません。もしお気に入りのパッケージがまだ IPv6 に対応していない場合、<emphasis>debian-ipv6</emphasis> メーリングリストで助けを求めることも可能です。彼らは IPv6 に対応している代替ソフトウェアを知っているかもしれませんし、この問題について適切な追跡が行えるようなバグ報告を投稿できるかもしれません。<ulink type=\"block\" url=\"http://lists.debian.org/debian-ipv6/\" />"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>IPv6 firewall</primary>"
msgstr "<primary>IPv6 ファイアウォール</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>firewall</primary><secondary>IPv6</secondary>"
msgstr "<primary>ファイアウォール</primary><secondary>IPv6</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>ip6tables</command></primary>"
msgstr "<primary><command>ip6tables</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "IPv6 connections can be restricted, in the same fashion as for IPv4: the standard Debian kernels include an adaptation of <emphasis>netfilter</emphasis> for IPv6. This IPv6-enabled <emphasis>netfilter</emphasis> is configured in a similar fashion to its IPv4 counterpart, except the program to use is <command>ip6tables</command> instead of <command>iptables</command>."
msgstr "IPv6 接続は IPv4 と同様の方法で制限することが可能です。すなわち 標準的な Debian カーネルは IPv6 用の <emphasis>netfilter</emphasis> に対応しています。IPv6 対応の <emphasis>netfilter</emphasis> を設定するには IPv4 でやったのと同様の方法を使います。ただし、<command>iptables</command> の代わりに <command>ip6tables</command> を使います。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Tunneling"
msgstr "トンネル"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>CAUTION</emphasis> IPv6 tunneling and firewalls"
msgstr "<emphasis>CAUTION</emphasis> IPv6 トンネルとファイアウォール"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "IPv6 tunneling over IPv4 (as opposed to native IPv6) requires the firewall to accept the traffic, which uses IPv4 protocol number 41."
msgstr "IPv4 上に IPv6 トンネルを作るには (ネイティブ IPv6 とは対照的に) IPv4 プロトコル 41 番を使うトラフィックを受け入れるファイアウォールが必要です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "If a native IPv6 connection is not available, the fallback method is to use a tunnel over IPv4. Gogo6 is one (free) provider of such tunnels: <ulink type=\"block\" url=\"http://www.gogo6.com/freenet6/tunnelbroker\" />"
msgstr "ネイティブ IPv6 接続が利用できない場合、IPv4 上のトンネルを経由する代替法が使われます。gogo6 はこのようなトンネルの (無料) プロバイダです。<ulink type=\"block\" url=\"http://www.gogo6.com/freenet6/tunnelbroker\" />"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Freenet6</primary>"
msgstr "<primary>Freenet6</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Gogo6</primary>"
msgstr "<primary>gogo6</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "To use a Freenet6 tunnel, you need to register for a Freenet6 Pro account on the website, then install the <emphasis role=\"pkg\">gogoc</emphasis> package and configure the tunnel. This requires editing the <filename>/etc/gogoc/gogoc.conf</filename> file: <literal>userid</literal> and <literal>password</literal> lines received by e-mail should be added, and <literal>server</literal> should be replaced with <literal>authenticated.freenet6.net</literal>."
msgstr "Freenet6 トンネルを使うには、ウェブサイトから Freenet6 Pro アカウントを登録し、<emphasis role=\"pkg\">gogoc</emphasis> パッケージをインストールし、トンネルを設定します。<filename>/etc/gogoc/gogoc.conf</filename> ファイルを編集する必要があります。具体的に言えば、電子メールで受け取った <literal>userid</literal> と <literal>password</literal> 行を追加し、<literal>server</literal> を <literal>authenticated.freenet6.net</literal> に置き替えます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "IPv6 connectivity is proposed to all machines on a local network by adding the three following directives to the <filename>/etc/gogoc/gogoc.conf</filename> file (assuming the local network is connected to the eth0 interface):"
msgstr "IPv6 接続をローカルネットワークのすべてのマシンに提供するには、以下の 3 つの指示文を <filename>/etc/gogoc/gogoc.conf</filename> ファイルに追加します (ここで、ローカルネットワークは eth0 インターフェースに接続されていると仮定します)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"host_type=router\n"
"prefixlen=56\n"
"if_prefix=eth0"
msgstr ""
"\n"
"host_type=router\n"
"prefixlen=56\n"
"if_prefix=eth0"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The machine then becomes the access router for a subnet with a 56-bit prefix. Once the tunnel is aware of this change, the local network must be told about it; this implies installing the <command>radvd</command> daemon (from the similarly-named package). This IPv6 configuration daemon has a role similar to <command>dhcpd</command> in the IPv4 world."
msgstr "これでマシンは 56 ビットのプレフィックスを持つサブネット用のアクセスルータになります。Freenet6 トンネルが設定変更を検出したら、ローカルネットワークに設定変更を通知しなければいけません。これを行うには <command>radvd</command> デーモン (同名のパッケージに含まれます) をインストールします。<command>radvd</command> IPv6 設定デーモンは IPv4 で言うところの <command>dhcpd</command> と同様の役割を果たします。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: http://www.gogo6.com/forum/topics/how-to-install-the-client-on-1;
msgid "The <filename>/etc/radvd.conf</filename> configuration file must then be created (see <filename>/usr/share/doc/radvd/examples/simple-radvd.conf</filename> as a starting point). In our case, the only required change is the prefix, which needs to be replaced with the one provided by Freenet6; it can be found in the output of the <command>ifconfig</command> command, in the block concerning the <literal>tun</literal> interface."
msgstr "<filename>/etc/radvd.conf</filename> 設定ファイルを作成しなければいけません (ひな形の <filename>/usr/share/doc/radvd/examples/simple-radvd.conf</filename> を参照してください)。Freenet6 を使う場合、プレフィックス設定を Freenet6 から提供されたものに変更するだけで十分です。プレフィックスを探すには <command>ifconfig</command> コマンドの出力から <literal>tun</literal> インターフェースを含むブロックを参照します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>radvd</command></primary>"
msgstr "<primary><command>radvd</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Then run <command>service gogoc restart</command> and <command>service radvd start</command>, and the IPv6 network should work."
msgstr "この後 <command>service gogoc restart</command> と <command>service radvd start</command> を実行すれば、IPv6 ネットワークが使えるはずです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Domain Name Servers (DNS)"
msgstr "ドメインネームサーバ (DNS)"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>DNS</primary>"
msgstr "<primary>DNS</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>server</primary><secondary>name</secondary>"
msgstr "<primary>サーバ</primary><secondary>ネームサーバ</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <emphasis>Domain Name Service</emphasis> (DNS) is a fundamental component of the Internet: it maps host names to IP addresses (and vice-versa), which allows the use of <literal>www.debian.org</literal> instead of <literal>5.153.231.4</literal> or <literal>2001:41c8:1000:21::21:4</literal>."
msgstr "<emphasis>ドメインネームサービス</emphasis> (DNS) はインターネットの基礎要素です。つまり DNS はホスト名を IP アドレスに対応付け (逆に IP アドレスをホスト名に対応付けることも行います)、<literal>5.153.231.4</literal> や <literal>2001:41c8:1000:21::21:4</literal> の代わりに <literal>www.debian.org</literal> を使えるようにします。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "DNS records are organized in zones; each zone matches either a domain (or a subdomain) or an IP address range (since IP addresses are generally allocated in consecutive ranges). A primary server is authoritative on the contents of a zone; secondary servers, usually hosted on separate machines, provide regularly refreshed copies of the primary zone."
msgstr "DNS レコードはゾーン分けされています。それぞれのゾーンはドメイン (またはサブドメイン) か IP アドレス範囲に対応付けられます (なぜなら、ゾーンは通常連続した IP アドレス範囲を割り当てられるからです)。プライマリサーバはあるゾーンに含まれる内容の情報を提供する権威的なサーバです。さらに、セカンダリサーバは通常プライマリサーバとは別のマシン上でホストされ、定期的にプライマリゾーンのコピーをとるサーバです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>zone</primary><secondary>DNS</secondary>"
msgstr "<primary>ゾーン</primary><secondary>DNS</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>DNS</primary><secondary>zone</secondary>"
msgstr "<primary>DNS</primary><secondary>ゾーン</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Each zone can contain records of various kinds (<emphasis>Resource Records</emphasis>):"
msgstr "各ゾーンには、さまざまな種類のレコード (<emphasis>リソースレコード</emphasis>) が含まれます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>A</literal>: IPv4 address. <indexterm><primary>A, DNS record</primary></indexterm>"
msgstr "<literal>A</literal>。IPv4 アドレスを意味します。<indexterm><primary>A、DNS レコード</primary></indexterm>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>CNAME</literal>: alias (<emphasis>canonical name</emphasis>). <indexterm><primary>CNAME, DNS record</primary></indexterm>"
msgstr "<literal>CNAME</literal>。別名 (<emphasis>canonical name</emphasis>) を意味します。<indexterm><primary>CNAME、DNS レコード</primary></indexterm>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>MX</literal>: <emphasis>mail exchange</emphasis>, an email server. This information is used by other email servers to find where to send email addressed to a given address. Each MX record has a priority. The highest-priority server (with the lowest number) is tried first (see sidebar <xref linkend=\"sidebar.smtp\" />); other servers are contacted in order of decreasing priority if the first one does not reply. <indexterm><primary>MX</primary><secondary>DNS record</secondary></indexterm>"
msgstr "<literal>MX</literal>。<emphasis>mail exchange</emphasis> つまり電子メールサーバを意味します。MX レコードは電子メールサーバが自分の管理下にないアドレス宛の電子メールの送信先を見つけるために使われます。それぞれの MX レコードには優先度があります。最も優先度の高いサーバ (最も低い番号のサーバ) に対する送信を最初に試行します (補注<xref linkend=\"sidebar.smtp\" />を参照してください)。さらに、最初のサーバからの応答がなかった場合、他のサーバを優先度の高い順に試行します。<indexterm><primary>MX</primary><secondary>DNS レコード</secondary></indexterm>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>PTR</literal>: mapping of an IP address to a name. Such a record is stored in a “reverse DNS” zone named after the IP address range. For example, <literal>1.168.192.in-addr.arpa</literal> is the zone containing the reverse mapping for all addresses in the <literal>192.168.1.0/24</literal> range. <indexterm><primary>PTR, DNS record</primary></indexterm>"
msgstr "<literal>PTR</literal>。ある IP アドレスに対する名前の対応付けを意味します。<literal>PTR</literal> レコードはある IP アドレス範囲に対応付けられた「逆引き DNS」ゾーンに保存されます。たとえば、<literal>1.168.192.in-addr.arpa</literal> は <literal>192.168.1.0/24</literal> 範囲に含まれる全アドレスの逆引き対応が保存されているゾーンです。<indexterm><primary>PTR、DNS レコード</primary></indexterm>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>AAAA</literal>: IPv6 address. <indexterm><primary>AAAA, DNS record</primary></indexterm>"
msgstr "<literal>AAAA</literal>。IPv6 アドレスを意味します。<indexterm><primary>AAAA、DNS レコード</primary></indexterm>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>NS</literal>: maps a name to a name server. Each domain must have at least one NS record. These records point at a DNS server that can answer queries concerning this domain; they usually point at the primary and secondary servers for the domain. These records also allow DNS delegation; for instance, the <literal>falcot.com</literal> zone can include an NS record for <literal>internal.falcot.com</literal>, which means that the <literal>internal.falcot.com</literal> zone is handled by another server. Of course, this server must declare an <literal>internal.falcot.com</literal> zone. <indexterm><primary>NS, DNS record</primary></indexterm>"
msgstr "<literal>NS</literal>。名前とネームサーバの対応付けを意味します。それぞれのドメインは最低 1 つの NS レコードを持っています。NS レコードでは、このドメインに対する問い合わせに答えることができる DNS サーバを指定します。これは通常そのドメインに対するプライマリおよびセカンダリサーバです。NS レコードを使って DNS の権限委譲を指定することも可能です。たとえば、<literal>falcot.com</literal> ゾーンの NS レコードには <literal>internal.falcot.com</literal> が含まれます。これは <literal>internal.falcot.com</literal> ゾーンは別のサーバが担当していることを意味します。もちろん、このサーバは <literal>internal.falcot.com</literal> ゾーンを宣言しなければいけません。<indexterm><primary>NS、DNS レコード</primary></indexterm>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>record</primary><secondary>DNS</secondary>"
msgstr "<primary>レコード</primary><secondary>DNS</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>DNS record</primary>"
msgstr "<primary>DNS レコード</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The reference name server, Bind, was developed and is maintained by ISC (<emphasis>Internet Software Consortium</emphasis>). It is provided in Debian by the <emphasis role=\"pkg\">bind9</emphasis> package. Version 9 brings two major changes compared to previous versions. First, the DNS server can now run under an unprivileged user, so that a security vulnerability in the server does not grant root privileges to the attacker (as was seen repeatedly with versions 8.x)."
msgstr "標準的なネームサーバである Bind は ISC (<emphasis>Internet Software Consortium</emphasis>) によって開発およびメンテナンスされています。Debian において Bind を提供するパッケージは <emphasis role=\"pkg\">bind9</emphasis> です。Bind バージョン 9 では、前のバージョンに比べて 2 種類の大きな変更が導入されました。1 番目は DNS サーバを非特権ユーザとして実行するという変更です。これにより、サーバのセキュリティ脆弱性によって攻撃者に root 権限を渡してしまうことがなくなりました (バージョン 8.x ではこのようなことがよくありました)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Furthermore, Bind supports the DNSSEC standard for signing (and therefore authenticating) DNS records, which allows blocking any spoofing of this data during man-in-the-middle attacks."
msgstr "2 番目は Bind が DNS レコードの署名 (すなわち DNS レコードの認証) に DNSSEC 標準をサポートするようになった変更です。これにより、中間者攻撃で DNS レコードが偽装された場合に、偽装された DNS レコードを遮断することが可能になりました。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis role=\"pkg\">bind9</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">bind9</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>ISC</primary>"
msgstr "<primary>ISC</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Internet Software Consortium</primary>"
msgstr "<primary>Internet Software Consortium</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>CULTURE</emphasis> DNSSEC"
msgstr "<emphasis>CULTURE</emphasis> DNSSEC"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>DNSSEC</primary>"
msgstr "<primary>DNSSEC</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The DNSSEC norm is quite complex; this partly explains why it is not in widespread usage yet (even if it perfectly coexists with DNS servers unaware of DNSSEC). To understand all the ins and outs, you should check the following article. <ulink type=\"block\" url=\"http://en.wikipedia.org/wiki/Domain_Name_System_Security_Extensions\" />"
msgstr "DNSSEC の規格はかなり複雑です。さらに DNSSEC はその複雑さにより、まだ広く使われている規格ではありません (DNSSEC に未対応の DNS サーバと完全に共存するにも関わらず使われていません)。一部始終を理解するには、以下の記事を参照してください。<ulink type=\"block\" url=\"http://en.wikipedia.org/wiki/Domain_Name_System_Security_Extensions\" />"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Configuring"
msgstr "設定"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Configuration files for <command>bind</command>, irrespective of version, have the same structure."
msgstr "バージョンによらず <command>bind</command> の設定ファイルは同じ構造をしています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The Falcot administrators created a primary <literal>falcot.com</literal> zone to store information related to this domain, and a <literal>168.192.in-addr.arpa</literal> zone for reverse mapping of IP addresses in the local networks."
msgstr "Falcot の管理者は <literal>falcot.com</literal> ドメインに関連する情報を保存するためにプライマリ <literal>falcot.com</literal> ゾーンを作成し、ローカルネットワーク内の IP アドレスとの逆引き対応を付けるために <literal>168.192.in-addr.arpa</literal> ゾーンを作成しました。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>CAUTION</emphasis> Names of reverse zones"
msgstr "<emphasis>CAUTION</emphasis> 逆引きゾーンの名前"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>zone</primary><secondary>reverse</secondary>"
msgstr "<primary>ゾーン</primary><secondary>逆引き</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>reverse zone</primary>"
msgstr "<primary>逆引きゾーン</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><literal>in-addr.arpa</literal></primary>"
msgstr "<primary><literal>in-addr.arpa</literal></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><literal>ip6.arpa</literal></primary>"
msgstr "<primary><literal>ip6.arpa</literal></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>nibble format</primary>"
msgstr "<primary>ニブルフォーマット</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Reverse zones have a particular name. The zone covering the <literal>192.168.0.0/16</literal> network needs to be named <literal>168.192.in-addr.arpa</literal>: the IP address components are reversed, and followed by the <literal>in-addr.arpa</literal> suffix."
msgstr "逆引きゾーンには特定の名前が付けられています。<literal>192.168.0.0/16</literal> ネットワークに対する逆引きゾーンは <literal>168.192.in-addr.arpa</literal> のように名付けなければいけません。具体的に言えば、IP アドレス部分の順序を逆にして、その後ろに <literal>in-addr.arpa</literal> サフィックスを付けます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "For IPv6 networks, the suffix is <literal>ip6.arpa</literal> and the IP address components which are reversed are each character in the full hexadecimal representation of the IP address. As such, the <literal>2001:0bc8:31a0::/48</literal> network would use a zone named <literal>0.a.1.3.8.c.b.0.1.0.0.2.ip6.arpa</literal>."
msgstr "IPv6 ネットワークの場合、IP アドレスを完全に 16 進数表記した時の文字を逆順にして、その後ろに <literal>ip6.arpa</literal> サフィックスを付けます。つまり、<literal>2001:0bc8:31a0::/48</literal> ネットワークはゾーン名として <literal>0.a.1.3.8.c.b.0.1.0.0.2.ip6.arpa</literal> を使います。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>TIP</emphasis> Testing the DNS server"
msgstr "<emphasis>TIP</emphasis> DNS サーバのテスト"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <command>host</command> command (in the <emphasis role=\"pkg\">bind9-host</emphasis> package) queries a DNS server, and can be used to test the server configuration. For example, <command>host machine.falcot.com localhost</command> checks the local server's reply for the <literal>machine.falcot.com</literal> query. <command>host <replaceable>ipaddress</replaceable> localhost</command> tests the reverse resolution."
msgstr "<command>host</command> コマンド (<emphasis role=\"pkg\">bind9-host</emphasis> パッケージに含まれます) は引数に DNS サーバを与えることができ、DNS サーバの設定をテストするために使うことも可能です。たとえば <command>host machine.falcot.com localhost</command> を使うと、<literal>localhost</literal> 上の DNS サーバに <literal>machine.falcot.com</literal> を問い合わせた際の応答を確認することが可能です。<command>host <replaceable>ipaddress</replaceable> localhost</command> を使うと逆引き設定をテストすることが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>host</command></primary>"
msgstr "<primary><command>host</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The following configuration excerpts, taken from the Falcot files, can serve as starting points to configure a DNS server:"
msgstr "以下に Falcot のファイルから抜粋した設定を載せます。これは DNS サーバの設定の足掛かりになります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><filename>named.conf</filename></primary>"
msgstr "<primary><filename>named.conf</filename></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><filename>/etc/bind/named.conf</filename></primary>"
msgstr "<primary><filename>/etc/bind/named.conf</filename></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Excerpt of <filename>/etc/bind/named.conf.local</filename>"
msgstr "<filename>/etc/bind/named.conf.local</filename> の抜粋"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"zone \"falcot.com\" {\n"
"        type master;\n"
"        file \"/etc/bind/db.falcot.com\";\n"
"        allow-query { any; };\n"
"        allow-transfer {\n"
"                195.20.105.149/32 ; // ns0.xname.org\n"
"                193.23.158.13/32 ; // ns1.xname.org\n"
"        };\n"
"};\n"
"\n"
"zone \"internal.falcot.com\" {\n"
"        type master;\n"
"        file \"/etc/bind/db.internal.falcot.com\";\n"
"        allow-query { 192.168.0.0/16; };\n"
"};\n"
"\n"
"zone \"168.192.in-addr.arpa\" {\n"
"        type master;\n"
"        file \"/etc/bind/db.192.168\";\n"
"        allow-query { 192.168.0.0/16; };\n"
"};"
msgstr ""
"\n"
"zone \"falcot.com\" {\n"
"        type master;\n"
"        file \"/etc/bind/db.falcot.com\";\n"
"        allow-query { any; };\n"
"        allow-transfer {\n"
"                195.20.105.149/32 ; // ns0.xname.org\n"
"                193.23.158.13/32 ; // ns1.xname.org\n"
"        };\n"
"};\n"
"\n"
"zone \"internal.falcot.com\" {\n"
"        type master;\n"
"        file \"/etc/bind/db.internal.falcot.com\";\n"
"        allow-query { 192.168.0.0/16; };\n"
"};\n"
"\n"
"zone \"168.192.in-addr.arpa\" {\n"
"        type master;\n"
"        file \"/etc/bind/db.192.168\";\n"
"        allow-query { 192.168.0.0/16; };\n"
"};"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Excerpt of <filename>/etc/bind/db.falcot.com</filename>"
msgstr "<filename>/etc/bind/db.falcot.com</filename> の抜粋"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: https://www.centos.org/docs/5/html/Deployment_Guide-en-US/s1-bind-zone.html;
# Ref: http://www.zytrax.com/books/dns/ch8/soa.html;
# Ref: https://www.ietf.org/rfc/rfc1912.txt;
msgid ""
"; falcot.com Zone \n"
"; admin.falcot.com. =&gt; zone contact: admin@falcot.com\n"
"$TTL    604800\n"
"@       IN      SOA     falcot.com. admin.falcot.com. (\n"
"                        20040121        ; Serial\n"
"                         604800         ; Refresh\n"
"                          86400         ; Retry\n"
"                        2419200         ; Expire\n"
"                         604800 )       ; Negative Cache TTL\n"
";\n"
"; The @ refers to the zone name (\"falcot.com\" here)\n"
"; or to $ORIGIN if that directive has been used\n"
";\n"
"@       IN      NS      ns\n"
"@       IN      NS      ns0.xname.org.\n"
"\n"
"internal IN      NS      192.168.0.2\n"
"\n"
"@       IN      A       212.94.201.10\n"
"@       IN      MX      5 mail\n"
"@       IN      MX      10 mail2\n"
"\n"
"ns      IN      A       212.94.201.10\n"
"mail    IN      A       212.94.201.10\n"
"mail2   IN      A       212.94.201.11\n"
"www     IN      A       212.94.201.11\n"
"\n"
"dns     IN      CNAME   ns"
msgstr ""
"; falcot.com ゾーン\n"
"; admin.falcot.com. でゾーン連絡先アドレスに admin@falcot.com を指定したことになります\n"
"$TTL    604800\n"
"@       IN      SOA     falcot.com. admin.falcot.com. (\n"
"                        20040121        ; Serial\n"
"                         604800         ; Refresh\n"
"                          86400         ; Retry\n"
"                        2419200         ; Expire\n"
"                         604800 )       ; Negative Cache TTL\n"
";\n"
"; @ はゾーン名 (ここでは \"falcot.com\") または\n"
"; $ORIGIN 指示文が使われていた場合 $ORIGIN を意味します\n"
";\n"
"@       IN      NS      ns\n"
"@       IN      NS      ns0.xname.org.\n"
"\n"
"internal IN      NS      192.168.0.2\n"
"\n"
"@       IN      A       212.94.201.10\n"
"@       IN      MX      5 mail\n"
"@       IN      MX      10 mail2\n"
"\n"
"ns      IN      A       212.94.201.10\n"
"mail    IN      A       212.94.201.10\n"
"mail2   IN      A       212.94.201.11\n"
"www     IN      A       212.94.201.11\n"
"\n"
"dns     IN      CNAME   ns"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>CAUTION</emphasis> Syntax of a name"
msgstr "<emphasis>CAUTION</emphasis> 名前の構文"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The syntax of machine names follows strict rules. For instance, <literal>machine</literal> implies <literal>machine.<replaceable>domain</replaceable></literal>. If the domain name should not be appended to a name, said name must be written as <literal>machine.</literal> (with a dot as suffix). Indicating a DNS name outside the current domain therefore requires a syntax such as <literal>machine.otherdomain.com.</literal> (with the final dot)."
msgstr "マシン名の構文には厳密なルールがあります。たとえば、<literal>machine</literal> は <literal>machine.<replaceable>domain</replaceable></literal> を意味します。名前にこのドメイン名を加えるべきでない場合、名前を <literal>machine.</literal> のように表記 (ドットを後置) しなければいけません。このため、現在のドメインの外部にある DNS 名を表すには <literal>machine.otherdomain.com.</literal> のような構文 (最後にドットを後置) が必要です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Excerpt of <filename>/etc/bind/db.192.168</filename>"
msgstr "<filename>/etc/bind/db.192.168</filename> の抜粋"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"; Reverse zone for 192.168.0.0/16\n"
"; admin.falcot.com. =&gt; zone contact: admin@falcot.com\n"
"$TTL    604800\n"
"@       IN      SOA     ns.internal.falcot.com. admin.falcot.com. (\n"
"                        20040121        ; Serial\n"
"                         604800         ; Refresh\n"
"                          86400         ; Retry\n"
"                        2419200         ; Expire\n"
"                         604800 )       ; Negative Cache TTL\n"
"\n"
"        IN      NS      ns.internal.falcot.com.\n"
"\n"
"; 192.168.0.1 -&gt; arrakis\n"
"1.0     IN      PTR     arrakis.internal.falcot.com.\n"
"; 192.168.0.2 -&gt; neptune\n"
"2.0     IN      PTR     neptune.internal.falcot.com.\n"
"\n"
"; 192.168.3.1 -&gt; pau\n"
"1.3     IN      PTR     pau.internal.falcot.com."
msgstr ""
"; 192.168.0.0/16 用の逆引きゾーン\n"
"; admin.falcot.com. でゾーン連絡先アドレスに admin@falcot.com を指定したことになります\n"
"$TTL    604800\n"
"@       IN      SOA     ns.internal.falcot.com. admin.falcot.com. (\n"
"                        20040121        ; Serial\n"
"                         604800         ; Refresh\n"
"                          86400         ; Retry\n"
"                        2419200         ; Expire\n"
"                         604800 )       ; Negative Cache TTL\n"
"\n"
"        IN      NS      ns.internal.falcot.com.\n"
"\n"
"; 192.168.0.1 を arrakis に対応付けます\n"
"1.0     IN      PTR     arrakis.internal.falcot.com.\n"
"; 192.168.0.2 を neptune に対応付けます\n"
"2.0     IN      PTR     neptune.internal.falcot.com.\n"
"\n"
"; 192.168.3.1 を pau に対応付けます\n"
"1.3     IN      PTR     pau.internal.falcot.com."

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "DHCP (for <emphasis>Dynamic Host Configuration Protocol</emphasis>) is a protocol by which a machine can automatically get its network configuration when it boots. This allows centralizing the management of network configurations, and ensuring that all desktop machines get similar settings."
msgstr "DHCP (<emphasis>Dynamic Host Configuration Protocol</emphasis> の略語) はマシンが起動時にネットワーク設定を自動的に取得することを可能にするプロトコルです。DHCP のおかげでネットワーク設定の管理を中央集権化し、すべてのデスクトップマシンに類似した設定を行うことが可能になります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>DHCP</primary>"
msgstr "<primary>DHCP</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Dynamic Host Configuration Protocol</primary>"
msgstr "<primary>Dynamic Host Configuration Protocol</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>network</primary><secondary>DHCP configuration</secondary>"
msgstr "<primary>ネットワーク</primary><secondary>DHCP 設定</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "A DHCP server provides many network-related parameters. The most common of these is an IP address and the network where the machine belongs, but it can also provide other information, such as DNS servers, WINS servers, NTP servers, and so on."
msgstr "DHCP サーバは多くのネットワーク関連パラメータを提供します。DHCP サーバが提供する最も一般的なパラメータは IP アドレスとマシンの所属するネットワークです。しかしながら、DHCP サーバは DNS サーバ、WINS サーバ、NTP サーバなどの情報を提供することも可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The Internet Software Consortium (also involved in developing <command>bind</command>) is the main author of the DHCP server. The matching Debian package is <emphasis role=\"pkg\">isc-dhcp-server</emphasis>."
msgstr "(<command>bind</command> の開発にも参加している) Internet Software Consortium は DHCP サーバの主開発者です。彼らの開発した DHCP サーバを含む Debian パッケージは <emphasis role=\"pkg\">isc-dhcp-server</emphasis> です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The first elements that need to be edited in the DHCP server configuration file (<filename>/etc/dhcp/dhcpd.conf</filename>) are the domain name and the DNS servers. If this server is alone on the local network (as defined by the broadcast propagation), the <literal>authoritative</literal> directive must also be enabled (or uncommented). One also needs to create a <literal>subnet</literal> section describing the local network and the configuration information to be provided. The following example fits a <literal>192.168.0.0/24</literal> local network with a router at <literal>192.168.0.1</literal> serving as the gateway. Available IP addresses are in the range <literal>192.168.0.128</literal> to <literal>192.168.0.254</literal>."
msgstr "DHCP サーバの設定ファイル (<filename>/etc/dhcp/dhcpd.conf</filename>) で最初に編集する必要がある場所はドメイン名と DNS サーバです。DHCP サーバがローカルネットワーク (ブロードキャストが届く範囲として定義されます) に 1 台しかない場合、<literal>authoritative</literal> 指示文を有効化しなければいけません (コメントを外さなければいけません)。また、<literal>subnet</literal> セクションを作成し、そこに通知先のローカルネットワークと設定情報を記述する必要があります。以下は <literal>192.168.0.1</literal> にゲートウェイを担当しているルータが存在する <literal>192.168.0.0/24</literal> ローカルネットワーク用の設定例です。配布される IP アドレスは <literal>192.168.0.128</literal> から <literal>192.168.0.254</literal> までの範囲です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Excerpt of <filename>/etc/dhcp/dhcpd.conf</filename>"
msgstr "<filename>/etc/dhcp/dhcpd.conf</filename> の抜粋"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: man 5 dhcpd.conf;
# Ref: less /usr/share/doc/isc-dhcp-server/examples/dhcpd.conf.example;
msgid ""
"\n"
"#\n"
"# Sample configuration file for ISC dhcpd for Debian\n"
"#\n"
"\n"
"# The ddns-updates-style parameter controls whether or not the server will\n"
"# attempt to do a DNS update when a lease is confirmed. We default to the\n"
"# behavior of the version 2 packages ('none', since DHCP v2 didn't\n"
"# have support for DDNS.)\n"
"ddns-update-style interim;\n"
"\n"
"# option definitions common to all supported networks...\n"
"option domain-name \"internal.falcot.com\";\n"
"option domain-name-servers ns.internal.falcot.com;\n"
"\n"
"default-lease-time 600;\n"
"max-lease-time 7200;\n"
"\n"
"# If this DHCP server is the official DHCP server for the local\n"
"# network, the authoritative directive should be uncommented.\n"
"authoritative;\n"
"\n"
"# Use this to send dhcp log messages to a different log file (you also\n"
"# have to hack syslog.conf to complete the redirection).\n"
"log-facility local7;\n"
"\n"
"# My subnet\n"
"subnet 192.168.0.0 netmask 255.255.255.0 {\n"
"    option routers 192.168.0.1;\n"
"    option broadcast-address 192.168.0.255;\n"
"    range 192.168.0.128 192.168.0.254;\n"
"    ddns-domainname \"internal.falcot.com\";\n"
"}"
msgstr ""
"\n"
"#\n"
"# Debian の ISC dhcpd 用設定ファイルの見本\n"
"#\n"
"\n"
"# ddns-update-style パラメータは IP アドレスのリースが確認されたら\n"
"# このサーバが DNS 更新を試行するか否かを制御します。\n"
"# デフォルト設定値はバージョン 2 パッケージの挙動です\n"
"# ('none'。なぜなら DHCP v2 は DDNS をサポートしていなかったからです)。\n"
"ddns-update-style interim;\n"
"\n"
"# すべてのネットワークに共通のオプションを定義します。\n"
"option domain-name \"internal.falcot.com\";\n"
"option domain-name-servers ns.internal.falcot.com;\n"
"\n"
"default-lease-time 600;\n"
"max-lease-time 7200;\n"
"\n"
"# この DHCP サーバがローカルネットワークの公式 DHCP サーバならば、\n"
"# authoritative 指示文を有効化するべきです。\n"
"authoritative;\n"
"\n"
"# dhcp ログメッセージを別のログファイルへ送信するには以下の設定を使います\n"
"# (これを正しく動作させるには syslog.conf の設定も必要です)。\n"
"log-facility local7;\n"
"\n"
"# 自分のサブネット\n"
"subnet 192.168.0.0 netmask 255.255.255.0 {\n"
"    option routers 192.168.0.1;\n"
"    option broadcast-address 192.168.0.255;\n"
"    range 192.168.0.128 192.168.0.254;\n"
"    ddns-domainname \"internal.falcot.com\";\n"
"}"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "DHCP and DNS"
msgstr "DHCP と DNS"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>DNS</primary><secondary>automated updates</secondary>"
msgstr "<primary>DNS</primary><secondary>自動更新</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "A nice feature is the automated registering of DHCP clients in the DNS zone, so that each machine gets a significant name (rather than something impersonal such as <literal>machine-192-168-0-131.internal.falcot.com</literal>). Using this feature requires configuring the DNS server to accept updates to the <literal>internal.falcot.com</literal> DNS zone from the DHCP server, and configuring the latter to submit updates for each registration."
msgstr "DNS ゾーン内に DHCP クライアントを自動登録するという便利な機能を使うことが可能です。自動登録機能を使えば、各マシンの意味のある名前を使ってアクセスできるようになります (自動登録機能を使わない場合、<literal>machine-192-168-0-131.internal.falcot.com</literal> などの匿名性のある名前を使ってアクセスすることになります)。自動登録機能を使うには、DHCP サーバから <literal>internal.falcot.com</literal> DNS ゾーンの更新を受け入れるように DNS サーバを設定して、各クライアントの登録情報の更新を DNS サーバに送信するように DHCP サーバを設定します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "In the <command>bind</command> case, the <literal>allow-update</literal> directive needs to be added to each of the zones that the DHCP server is to edit (the one for the <literal>internal.falcot.com</literal> domain, and the reverse zone). This directive lists the IP addresses allowed to perform these updates; it should therefore contain the possible addresses of the DHCP server (both the local address and the public address, if appropriate)."
msgstr "<command>bind</command> の場合、DHCP サーバから更新を受け入れる各ゾーンに <literal>allow-update</literal> 指示文を追加する必要があります (<literal>internal.falcot.com</literal> ドメインと逆引きゾーンの両方に追加する必要があります)。<literal>allow-update</literal> 指示文は更新を受け入れる IP アドレスをリストします。つまり、考え得る DHCP サーバの全アドレスを列挙します (必要に応じて、ローカルアドレスと公開アドレスの両方を指定します)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"allow-update { 127.0.0.1 192.168.0.1 212.94.201.10 !any };"
msgstr ""
"\n"
"allow-update { 127.0.0.1 192.168.0.1 212.94.201.10 !any };"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: PTAL;
msgid "Beware! A zone that can be modified <emphasis>will</emphasis> be changed by <command>bind</command>, and the latter will overwrite its configuration files at regular intervals. Since this automated procedure produces files that are less human-readable than manually-written ones, the Falcot administrators handle the <literal>internal.falcot.com</literal> domain with a delegated DNS server; this means the <literal>falcot.com</literal> zone file stays firmly under their manual control."
msgstr "注意してください! 更新を受け入れることを許可したゾーンは <command>bind</command> により<emphasis>変更され</emphasis>、設定ファイルは定期的に上書きされます。この自動手続きにより作成されるファイルは手作業で書かれたものよりも人間にとって読みづらいため、Falcot の管理者は権限委譲された DNS サーバを使って <literal>internal.falcot.com</literal> ドメインを管理しています。これは <literal>falcot.com</literal> ゾーンファイルは手作業で管理されることを意味します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The DHCP server configuration excerpt above already includes the directives required for DNS zone updates: they are the <literal>ddns-update-style interim;</literal> and <literal>ddns-domain-name \"internal.falcot.com\";</literal> lines in the block describing the subnet."
msgstr "上で引用した DHCP サーバの設定には、既に DNS ゾーンの更新に必要な指示文が含まれています。すなわちその指示文とは <literal>ddns-update-style interim;</literal> とサブネットを表すブロック中の <literal>ddns-domain-name \"internal.falcot.com\";</literal> です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Network Diagnosis Tools"
msgstr "ネットワーク診断ツール"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "When a network application does not run as expected, it is important to be able to look under the hood. Even when everything seems to run smoothly, running a network diagnosis can help ensure everything is working as it should. Several diagnosis tools exists for this purpose; each one operates on a different level."
msgstr "ネットワークアプリケーションが期待通りに動かない場合、中身を確かめることが重要です。すべてが問題なく動いているように見える場合でも、ネットワーク診断を実行すればすべてがあるべき姿で動いていることを確かめる手助けになります。この目的で複数の診断ツールが存在します。そして、各ツールは異なるレベルを診断します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Local Diagnosis: <command>netstat</command>"
msgstr "ローカルの診断、<command>netstat</command>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>netstat</command></primary>"
msgstr "<primary><command>netstat</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Let's first mention the <command>netstat</command> command (in the <emphasis role=\"pkg\">net-tools</emphasis> package); it displays an instant summary of a machine's network activity. When invoked with no argument, this command lists all open connections; this list can be very verbose since it includes many Unix-domain sockets (widely used by daemons) which do not involve the network at all (for example, <literal>dbus</literal> communication, <literal>X11</literal> traffic, and communications between virtual filesystems and the desktop)."
msgstr "最初に <command>netstat</command> コマンド (<emphasis role=\"pkg\">net-tools</emphasis> パッケージに含まれます) を紹介しましょう。<command>netstat</command> コマンドはマシンのその瞬間のネットワーク活動に関する要約を表示します。何も引数を渡さずに実行した場合、<command>netstat</command> コマンドは開かれた接続をリストします。このリストはとても長くなる場合があります。なぜなら、このリストには多くの Unix ドメインソケットが含まれるからです (Unix ドメインソケットはデーモンによって広く使われています)。Unix ドメインソケットはネットワークに関与するものではありません (<literal>dbus</literal> 通信、<literal>X11</literal> トラフィック、仮想ファイルシステムとデスクトップ間の通信などに関与するものです)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Common invocations therefore use options that alter <command>netstat</command>'s behavior. The most frequently used options include:"
msgstr "一般的に <command>netstat</command> を実行する際には標準の挙動を変更するオプションを使います。最も頻繁に使われるオプションを以下に挙げます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>-t</literal>, which filters the results to only include TCP connections;"
msgstr "<literal>-t</literal>。TCP 接続だけが表示されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>-u</literal>, which works similarly for UDP connections; these options are not mutually exclusive, and one of them is enough to stop displaying Unix-domain connections;"
msgstr "<literal>-u</literal>。UDP 接続だけが表示されます。<literal>-t</literal> と <literal>-u</literal> オプションは同時に使えます。Unix ドメインソケットの表示を抑制するにはどちらか一方を使うだけで十分です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>-a</literal>, to also list listening sockets (waiting for incoming connections);"
msgstr "<literal>-a</literal>。リッスンしている (接続を待ち受けている) ソケットも表示されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: $ man 1 netstat;
# Ref: $ vimdiff <(netstat -epan) <(netstat -epa);
msgid "<literal>-n</literal>, to display the results numerically: IP addresses (no DNS resolution), port numbers (no aliases as defined in <filename>/etc/services</filename>) and user ids (no login names);"
msgstr "<literal>-n</literal>。結果が数値的に表示されます。すなわち、IP アドレス (DNS で名前解決しません)、ポート番号 (<filename>/etc/services</filename> の定義する別名を使いません)、ユーザ id (ログイン名を使いません) を使って表示されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>-p</literal>, to list the processes involved; this option is only useful when <command>netstat</command> is run as root, since normal users will only see their own processes;"
msgstr "<literal>-p</literal>。関連付けられたプロセスが表示されます。<command>netstat</command> を root 権限で実行した場合にのみ、このオプションは役に立ちます。なぜなら、普通のユーザは自分のプロセス以外を見ることができないからです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>-c</literal>, to continuously refresh the list of connections."
msgstr "<literal>-c</literal>。継続的に接続リストを更新します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Other options, documented in the <citerefentry><refentrytitle>netstat</refentrytitle> <manvolnum>8</manvolnum></citerefentry> manual page, provide an even finer control over the displayed results. In practice, the first five options are so often used together that systems and network administrators practically acquired <command>netstat -tupan</command> as a reflex. Typical results, on a lightly loaded machine, may look like the following:"
msgstr "<citerefentry><refentrytitle>netstat</refentrytitle> <manvolnum>8</manvolnum></citerefentry> マニュアルページに書かれている他のオプションを使えば、表示される結果をさらに細かく制御することが可能です。実質的には上に挙げたオプションのうち最初の 5 種類を組み合わせて使うことが多いため、結果としてシステムとネットワークの管理者は <command>netstat -tupan</command> を身に付けることが多いです。負荷の高くないマシンでは、以下のような典型的な結果を返します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"<computeroutput># </computeroutput><userinput>netstat -tupan</userinput>\n"
"<computeroutput>Active Internet connections (servers and established)\n"
"Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name\n"
"tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      397/rpcbind     \n"
"tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      431/sshd        \n"
"tcp        0      0 0.0.0.0:36568           0.0.0.0:*               LISTEN      407/rpc.statd   \n"
"tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      762/exim4       \n"
"tcp        0    272 192.168.1.242:22        192.168.1.129:44452     ESTABLISHED 1172/sshd: roland [\n"
"tcp6       0      0 :::111                  :::*                    LISTEN      397/rpcbind     \n"
"tcp6       0      0 :::22                   :::*                    LISTEN      431/sshd        \n"
"tcp6       0      0 ::1:25                  :::*                    LISTEN      762/exim4       \n"
"tcp6       0      0 :::35210                :::*                    LISTEN      407/rpc.statd   \n"
"udp        0      0 0.0.0.0:39376           0.0.0.0:*                           916/dhclient    \n"
"udp        0      0 0.0.0.0:996             0.0.0.0:*                           397/rpcbind     \n"
"udp        0      0 127.0.0.1:1007          0.0.0.0:*                           407/rpc.statd   \n"
"udp        0      0 0.0.0.0:68              0.0.0.0:*                           916/dhclient    \n"
"udp        0      0 0.0.0.0:48720           0.0.0.0:*                           451/avahi-daemon: r\n"
"udp        0      0 0.0.0.0:111             0.0.0.0:*                           397/rpcbind     \n"
"udp        0      0 192.168.1.242:123       0.0.0.0:*                           539/ntpd        \n"
"udp        0      0 127.0.0.1:123           0.0.0.0:*                           539/ntpd        \n"
"udp        0      0 0.0.0.0:123             0.0.0.0:*                           539/ntpd        \n"
"udp        0      0 0.0.0.0:5353            0.0.0.0:*                           451/avahi-daemon: r\n"
"udp        0      0 0.0.0.0:39172           0.0.0.0:*                           407/rpc.statd   \n"
"udp6       0      0 :::996                  :::*                                397/rpcbind     \n"
"udp6       0      0 :::34277                :::*                                407/rpc.statd   \n"
"udp6       0      0 :::54852                :::*                                916/dhclient    \n"
"udp6       0      0 :::111                  :::*                                397/rpcbind     \n"
"udp6       0      0 :::38007                :::*                                451/avahi-daemon: r\n"
"udp6       0      0 fe80::5054:ff:fe99::123 :::*                                539/ntpd        \n"
"udp6       0      0 2001:bc8:3a7e:210:a:123 :::*                                539/ntpd        \n"
"udp6       0      0 2001:bc8:3a7e:210:5:123 :::*                                539/ntpd        \n"
"udp6       0      0 ::1:123                 :::*                                539/ntpd        \n"
"udp6       0      0 :::123                  :::*                                539/ntpd        \n"
"udp6       0      0 :::5353                 :::*                                451/avahi-daemon: r\n"
"</computeroutput>"
msgstr ""
"\n"
"<computeroutput># </computeroutput><userinput>netstat -tupan</userinput>\n"
"<computeroutput>稼働中のインターネット接続 (サーバと確立)\n"
"Proto 受信-Q 送信-Q 内部アドレス            外部アドレス            状態        PID/Program name\n"
"tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      397/rpcbind     \n"
"tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      431/sshd        \n"
"tcp        0      0 0.0.0.0:36568           0.0.0.0:*               LISTEN      407/rpc.statd   \n"
"tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      762/exim4       \n"
"tcp        0    272 192.168.1.242:22        192.168.1.129:44452     ESTABLISHED 1172/sshd: roland [\n"
"tcp6       0      0 :::111                  :::*                    LISTEN      397/rpcbind     \n"
"tcp6       0      0 :::22                   :::*                    LISTEN      431/sshd        \n"
"tcp6       0      0 ::1:25                  :::*                    LISTEN      762/exim4       \n"
"tcp6       0      0 :::35210                :::*                    LISTEN      407/rpc.statd   \n"
"udp        0      0 0.0.0.0:39376           0.0.0.0:*                           916/dhclient    \n"
"udp        0      0 0.0.0.0:996             0.0.0.0:*                           397/rpcbind     \n"
"udp        0      0 127.0.0.1:1007          0.0.0.0:*                           407/rpc.statd   \n"
"udp        0      0 0.0.0.0:68              0.0.0.0:*                           916/dhclient    \n"
"udp        0      0 0.0.0.0:48720           0.0.0.0:*                           451/avahi-daemon: r\n"
"udp        0      0 0.0.0.0:111             0.0.0.0:*                           397/rpcbind     \n"
"udp        0      0 192.168.1.242:123       0.0.0.0:*                           539/ntpd        \n"
"udp        0      0 127.0.0.1:123           0.0.0.0:*                           539/ntpd        \n"
"udp        0      0 0.0.0.0:123             0.0.0.0:*                           539/ntpd        \n"
"udp        0      0 0.0.0.0:5353            0.0.0.0:*                           451/avahi-daemon: r\n"
"udp        0      0 0.0.0.0:39172           0.0.0.0:*                           407/rpc.statd   \n"
"udp6       0      0 :::996                  :::*                                397/rpcbind     \n"
"udp6       0      0 :::34277                :::*                                407/rpc.statd   \n"
"udp6       0      0 :::54852                :::*                                916/dhclient    \n"
"udp6       0      0 :::111                  :::*                                397/rpcbind     \n"
"udp6       0      0 :::38007                :::*                                451/avahi-daemon: r\n"
"udp6       0      0 fe80::5054:ff:fe99::123 :::*                                539/ntpd        \n"
"udp6       0      0 2001:bc8:3a7e:210:a:123 :::*                                539/ntpd        \n"
"udp6       0      0 2001:bc8:3a7e:210:5:123 :::*                                539/ntpd        \n"
"udp6       0      0 ::1:123                 :::*                                539/ntpd        \n"
"udp6       0      0 :::123                  :::*                                539/ntpd        \n"
"udp6       0      0 :::5353                 :::*                                451/avahi-daemon: r\n"
"</computeroutput>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "As expected, this lists established connections, two SSH connections in this case, and applications waiting for incoming connections (listed as <literal>LISTEN</literal>), notably the Exim4 email server listening on port 25."
msgstr "予想通り、確立された接続 (2 つの SSH 接続) と接続を待ち受けているアプリケーション (<literal>LISTEN</literal> と記載されます。特に 25 番をリッスンしている Exim4 電子メールサーバ) が表示されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Remote Diagnosis: <command>nmap</command>"
msgstr "リモートの診断、<command>nmap</command>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>nmap</command></primary>"
msgstr "<primary><command>nmap</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<command>nmap</command> (in the similarly-named package) is, in a way, the remote equivalent for <command>netstat</command>. It can scan a set of “well-known” ports for one or several remote servers, and list the ports where an application is found to answer to incoming connections. Furthermore, <command>nmap</command> is able to identify some of these applications, sometimes even their version number. The counterpart of this tool is that, since it runs remotely, it cannot provide information on processes or users; however, it can operate on several targets at once."
msgstr "<command>nmap</command> (同名のパッケージに含まれます) はある意味でリモートに対する <command>netstat</command> に相当します。<command>nmap</command> は 1 台または数台のリモートサーバに対して「well-known」ポート群をスキャンし、入ってきた接続に応答したアプリケーションの見つかったポートをリストします。さらに、<command>nmap</command> は一部のアプリケーションを識別することが可能です。場合によってはアプリケーションのバージョン番号さえも識別することが可能です。<command>nmap</command> は <command>netstat</command> と対照的にリモートから実行されるため、プロセスやユーザの情報を提供できません。しかしながら、<command>nmap</command> は複数のリモートサーバに対して一気に実行できます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "A typical <command>nmap</command> invocation only uses the <literal>-A</literal> option (so that <command>nmap</command> attempts to identify the versions of the server software it finds) followed by one or more IP addresses or DNS names of machines to scan. Again, many more options exist to finely control the behavior of <command>nmap</command>; please refer to the documentation in the <citerefentry> <refentrytitle>nmap</refentrytitle> <manvolnum>1</manvolnum> </citerefentry> manual page."
msgstr "<command>nmap</command> を実行する際の典型例は <literal>-A</literal> オプション (<command>nmap</command> は見つかったサーバソフトウェアのバージョンを識別しようとします) だけを使い、その後ろにスキャンする 1 つか複数の IP アドレスまたは DNS 名を渡すことです。繰り返しになりますが、他にも多くのオプションが存在し、<command>nmap</command> の挙動をさらに細かく制御することが可能です。<citerefentry> <refentrytitle>nmap</refentrytitle> <manvolnum>1</manvolnum> </citerefentry> マニュアルページを参照してください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"<computeroutput># </computeroutput><userinput>nmap mirtuel</userinput>\n"
"<computeroutput>\n"
"Starting Nmap 6.47 ( http://nmap.org ) at 2015-03-09 16:46 CET\n"
"Nmap scan report for mirtuel (192.168.1.242)\n"
"Host is up (0.000013s latency).\n"
"rDNS record for 192.168.1.242: mirtuel.internal.placard.fr.eu.org\n"
"Not shown: 998 closed ports\n"
"PORT    STATE SERVICE\n"
"22/tcp  open  ssh\n"
"111/tcp open  rpcbind\n"
"\n"
"Nmap done: 1 IP address (1 host up) scanned in 2.41 seconds\n"
"# </computeroutput><userinput>nmap -A localhost</userinput>\n"
"<computeroutput>\n"
"Starting Nmap 6.47 ( http://nmap.org ) at 2015-03-09 16:46 CET\n"
"Nmap scan report for localhost (127.0.0.1)\n"
"Host is up (0.000013s latency).\n"
"Other addresses for localhost (not scanned): 127.0.0.1\n"
"Not shown: 997 closed ports\n"
"PORT    STATE SERVICE VERSION\n"
"22/tcp  open  ssh     OpenSSH 6.7p1 Debian 3 (protocol 2.0)\n"
"|_ssh-hostkey: ERROR: Script execution failed (use -d to debug)\n"
"25/tcp  open  smtp    Exim smtpd 4.84\n"
"| smtp-commands: mirtuel Hello localhost [127.0.0.1], SIZE 52428800, 8BITMIME, PIPELINING, HELP, \n"
"|_ Commands supported: AUTH HELO EHLO MAIL RCPT DATA NOOP QUIT RSET HELP \n"
"111/tcp open  rpcbind 2-4 (RPC #100000)\n"
"| rpcinfo: \n"
"|   program version   port/proto  service\n"
"|   100000  2,3,4        111/tcp  rpcbind\n"
"|   100000  2,3,4        111/udp  rpcbind\n"
"|   100024  1          36568/tcp  status\n"
"|_  100024  1          39172/udp  status\n"
"Device type: general purpose\n"
"Running: Linux 3.X\n"
"OS CPE: cpe:/o:linux:linux_kernel:3\n"
"OS details: Linux 3.7 - 3.15\n"
"Network Distance: 0 hops\n"
"Service Info: Host: mirtuel; OS: Linux; CPE: cpe:/o:linux:linux_kernel\n"
"\n"
"OS and Service detection performed. Please report any incorrect results at http://nmap.org/submit/ .\n"
"Nmap done: 1 IP address (1 host up) scanned in 11.54 seconds\n"
"</computeroutput>"
msgstr ""
"\n"
"<computeroutput># </computeroutput><userinput>nmap mirtuel</userinput>\n"
"<computeroutput>\n"
"Starting Nmap 6.47 ( http://nmap.org ) at 2015-03-10 00:46 JST\n"
"Nmap scan report for mirtuel (192.168.1.242)\n"
"Host is up (0.000013s latency).\n"
"rDNS record for 192.168.1.242: mirtuel.internal.placard.fr.eu.org\n"
"Not shown: 998 closed ports\n"
"PORT    STATE SERVICE\n"
"22/tcp  open  ssh\n"
"111/tcp open  rpcbind\n"
"\n"
"Nmap done: 1 IP address (1 host up) scanned in 2.41 seconds\n"
"# </computeroutput><userinput>nmap -A localhost</userinput>\n"
"<computeroutput>\n"
"Starting Nmap 6.47 ( http://nmap.org ) at 2015-03-10 00:46 JST\n"
"Nmap scan report for localhost (127.0.0.1)\n"
"Host is up (0.000013s latency).\n"
"Other addresses for localhost (not scanned): 127.0.0.1\n"
"Not shown: 997 closed ports\n"
"PORT    STATE SERVICE VERSION\n"
"22/tcp  open  ssh     OpenSSH 6.7p1 Debian 3 (protocol 2.0)\n"
"|_ssh-hostkey: ERROR: Script execution failed (use -d to debug)\n"
"25/tcp  open  smtp    Exim smtpd 4.84\n"
"| smtp-commands: mirtuel Hello localhost [127.0.0.1], SIZE 52428800, 8BITMIME, PIPELINING, HELP, \n"
"|_ Commands supported: AUTH HELO EHLO MAIL RCPT DATA NOOP QUIT RSET HELP \n"
"111/tcp open  rpcbind 2-4 (RPC #100000)\n"
"| rpcinfo: \n"
"|   program version   port/proto  service\n"
"|   100000  2,3,4        111/tcp  rpcbind\n"
"|   100000  2,3,4        111/udp  rpcbind\n"
"|   100024  1          36568/tcp  status\n"
"|_  100024  1          39172/udp  status\n"
"Device type: general purpose\n"
"Running: Linux 3.X\n"
"OS CPE: cpe:/o:linux:linux_kernel:3\n"
"OS details: Linux 3.7 - 3.15\n"
"Network Distance: 0 hops\n"
"Service Info: Host: mirtuel; OS: Linux; CPE: cpe:/o:linux:linux_kernel\n"
"\n"
"OS and Service detection performed. Please report any incorrect results at http://nmap.org/submit/ .\n"
"Nmap done: 1 IP address (1 host up) scanned in 11.54 seconds\n"
"</computeroutput>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "As expected, the SSH and Exim4 applications are listed. Note that not all applications listen on all IP addresses; since Exim4 is only accessible on the <literal>lo</literal> loopback interface, it only appears during an analysis of <literal>localhost</literal> and not when scanning <literal>mirtuel</literal> (which maps to the <literal>eth0</literal> interface on the same machine)."
msgstr "予想通り、SSH と Exim4 アプリケーションが表示されます。すべてのアプリケーションがすべての IP アドレスをリッスンしているわけではない点に注意してください。すなわち、Exim4 は <literal>lo</literal> ループバックインターフェースからのみアクセスできますから、<literal>localhost</literal> の解析にのみ表示され <literal>mirtuel</literal> (これは同じマシンの <literal>eth0</literal> インターフェースに対応付けられています) をスキャンした時には表示されません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Sniffers: <command>tcpdump</command> and <command>wireshark</command>"
msgstr "スニファ、<command>tcpdump</command> と <command>wireshark</command>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Sometimes, one needs to look at what actually goes on the wire, packet by packet. These cases call for a “frame analyzer”, more widely known as a <emphasis>sniffer</emphasis>. Such a tool observes all the packets that reach a given network interface, and displays them in a user-friendly way."
msgstr "しばしば実際にワイヤを行き来する情報をパケットごとに見る必要がある場合があります。この際に使われるツールは「フレームアナライザ」と呼ばれ、<emphasis>スニファ</emphasis>としても広く知られています。この種のツールは指定したネットワークに到達したすべてのパケットを観察し、ユーザにわかりやすい方法でパケットを表示します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>tcpdump</command></primary>"
msgstr "<primary><command>tcpdump</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The venerable tool in this domain is <command>tcpdump</command>, available as a standard tool on a wide range of platforms. It allows many kinds of network traffic capture, but the representation of this traffic stays rather obscure. We will therefore not describe it in further detail."
msgstr "ネットワークトラフィック解析分野における由緒あるツールが <command>tcpdump</command> です。<command>tcpdump</command> は広範囲のプラットフォームで利用できる標準的なツールです。<command>tcpdump</command> を使うと多くの種類のネットワークトラフィックをキャプチャできますが、<command>tcpdump</command> のトラフィックの表現は決してわかりやすいものではありません。このため <command>tcpdump</command> に関しては詳しく説明しません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>wireshark</command></primary>"
msgstr "<primary><command>wireshark</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "A more recent (and more modern) tool, <command>wireshark</command> (in the <emphasis role=\"pkg\">wireshark</emphasis> package), has become the new reference in network traffic analysis due to its many decoding modules that allow for a simplified analysis of the captured packets. The packets are displayed graphically with an organization based on the protocol layers. This allows a user to visualize all protocols involved in a packet. For example, given a packet containing an HTTP request, <command>wireshark</command> displays, separately, the information concerning the physical layer, the Ethernet layer, the IP packet information, the TCP connection parameters, and finally the HTTP request itself."
msgstr "より最近の (そしてより現代的な) ツールである <command>wireshark</command> (<emphasis role=\"pkg\">wireshark</emphasis> パッケージに含まれます) はキャプチャされたパケットの解析を単純化する多くのデコーディングモジュールのおかげでネットワークトラフィック解析分野における新しい標準的なツールになりつつあります。パケットはプロトコル層に基づいてグラフィカルに表示されます。<command>wireshark</command> を使うと、ユーザはあるパケットに関わるすべてのプロトコルを可視化することが可能です。たとえば、HTTP リクエストを含むパケットに対して、<command>wireshark</command> は物理層、イーサネット層、IP パケット情報、TCP 接続パラメータ、最後に HTTP リクエスト自身に関連する情報を別々に表示します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <command>wireshark</command> network traffic analyzer"
msgstr "<command>wireshark</command> ネットワークトラフィックアナライザ"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "In our example, the packets traveling over SSH are filtered out (with the <literal>!tcp.port == 22</literal> filter). The packet currently displayed was developed at the HTTP layer."
msgstr "上の例では、SSH を通じて移動するパケットを (<literal>!tcp.port == 22</literal> フィルタを使って) 除去しています。ここで詳細を表示されているパケットは HTTP 層で作られたものです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>TIP</emphasis> <command>wireshark</command> with no graphical interface: <command>tshark</command>"
msgstr "<emphasis>TIP</emphasis> グラフィカルインターフェースを持たない <command>wireshark</command>、<command>tshark</command>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>tshark</command></primary>"
msgstr "<primary><command>tshark</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "When one cannot run a graphical interface, or does not wish to do so for whatever reason, a text-only version of <command>wireshark</command> also exists under the name <command>tshark</command> (in a separate <emphasis role=\"pkg\">tshark</emphasis> package). Most of the capture and decoding features are still available, but the lack of a graphical interface necessarily limits the interactions with the program (filtering packets after they've been captured, tracking of a given TCP connection, and so on). It can still be used as a first approach. If further manipulations are intended and require the graphical interface, the packets can be saved to a file and this file can be loaded into a graphical <command>wireshark</command> running on another machine."
msgstr "グラフィカルインターフェースを実行できない場合や何らかの理由で実行したくない場合に備えて、<command>wireshark</command> のテキスト版 <command>tshark</command> (<emphasis role=\"pkg\">tshark</emphasis> パッケージに分割されています) が存在します。キャプチャとデコード機能のほとんどを利用できますが、グラフィカルインターフェースがないことでプログラムとのやり取りが制限されます (たとえば、パケットがキャプチャされた後にフィルタをかけたり、特定の TCP 接続を追跡したりすることが不可能です)。しかし <command>tshark</command> を足掛かりとして使うことが可能です。さらなる操作が必要だったりグラフィカルインターフェースが必要な操作を行う場合、パケットをファイルに保存してそのファイルを別のマシンで実行されているグラフィカルな <command>wireshark</command> で読み込むことが可能です。"

#~ msgid "<emphasis>CULTURE</emphasis> <command>ethereal</command> and <command>wireshark</command>"
#~ msgstr "<emphasis>CULTURE</emphasis> <command>ethereal</command> と <command>wireshark</command>"

#~ msgid "<primary><command>ethereal</command></primary>"
#~ msgstr "<primary><command>ethereal</command></primary>"

#~ msgid "<primary><command>tethereal</command></primary>"
#~ msgstr "<primary><command>tethereal</command></primary>"

#~ msgid "<command>wireshark</command> seems to be relatively young; however, it is only the new name for a software application previously known as <command>ethereal</command>. When its main developer left the company where he was employed, he was not able to arrange for the transfer of the registered trademark. As an alternative he went for a name change; only the name and the icons for the software actually changed."
#~ msgstr "<command>wireshark</command> は比較的若いように見えます。しかしながら、<command>wireshark</command> は <command>ethereal</command> として知られていたソフトウェアの新しい名前に過ぎません。<command>ethereal</command> の主開発者は雇用されていた会社を離れた時、登録済みの商標の移動を手配できませんでした。代案として、彼は名前を変えました。従って実際のところ、<command>wireshark</command> は <command>ethereal</command> の名前とアイコンだけを変えたものに過ぎません。"

#~ msgid "<primary><command>openswan</command></primary>"
#~ msgstr "<primary><command>openswan</command></primary>"

#~ msgid "Presentation"
#~ msgstr "プレゼンテーション"
