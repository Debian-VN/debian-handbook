#
# AUTHOR <EMAIL@ADDRESS>, YEAR.
# Ryuunosuke Ayanokouzi <i38w7i3@yahoo.co.jp>, 2015-2017.
# Kenshi Muto <kmuto@kmuto.jp>, 2015.
# Yoichi Chonan <cyoichi@maple.ocn.ne.jp>, 2015.
# YABUKI Youichi <yabuki@sraoss.co.jp>, 2015.
# Osamu Aoki <osamu@debian.org>, 2016.
#
msgid ""
msgstr ""
"Project-Id-Version: 0\n"
"POT-Creation-Date: 2017-02-05 09:00+0900\n"
"PO-Revision-Date: 2017-02-05 09:00+0900\n"
"Last-Translator: AYANOKOUZI, Ryuunosuke <i38w7i3@yahoo.co.jp>\n"
"Language-Team: Japanese <https://github.com/l/debian-handbook/tree/master/translation/ja_JP/push>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: application/x-publican; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Configuration"
msgstr "設定"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Localization"
msgstr "地域化"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Locales"
msgstr "ロケール"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Network"
msgstr "ネットワーク"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Name resolution"
msgstr "名前解決"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Users"
msgstr "ユーザ"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Groups"
msgstr "グループ"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Accounts"
msgstr "アカウント"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Command-line interpreter"
msgstr "コマンドラインインタプリタ"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Shell"
msgstr "シェル"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Printing"
msgstr "印刷"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Bootloader"
msgstr "ブートローダ"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Kernel compiling"
msgstr "カーネルのコンパイル"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Basic Configuration: Network, Accounts, Printing..."
msgstr "基本設定、ネットワーク、アカウント、印刷..."

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "A computer with a new installation created with <command>debian-installer</command> is intended to be as functional as possible, but many services still have to be configured. Furthermore, it is always good to know how to change certain configuration elements defined during the initial installation process."
msgstr "<command>debian-installer</command> を使って新規にインストールしたコンピュータは可能な限り実用的に設定されます。とは言うものの、多くのサービスには設定の余地が残っています。さらに、管理者は最初のインストール中に設定された特定の項目の内容を変更する方法も必ず知っておくべきです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "This chapter reviews everything included in what we could call the “basic configuration”: networking, language and locales, users and groups, printing, mount points, etc."
msgstr "この章では「基本設定」と呼ばれている内容についてすべてを見直します。具体的に言えば、ネットワーク、言語とロケール、ユーザとグループ、印刷、マウントポイントなどの設定を見直します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Configuring the System for Another Language"
msgstr "他の言語用にシステムを設定"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>French localization</primary>"
msgstr "<primary>日本語化</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "If the system was installed using French, the machine will probably already have French set as the default language. But it is good to know what the installer does to set the language, so that later, if the need arises, you can change it."
msgstr "日本語を使ってシステムをインストールした場合、既に日本語がデフォルト言語になっているかもしれません。しかし、インストーラが言語を設定する際にやっていることを知っておくべきです。こうしておくことで、後から必要になった際に言語を切り替えることが可能になります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>TOOL</emphasis> The <command>locale</command> command to display the current configuration"
msgstr "<emphasis>TOOL</emphasis> 現在の設定を表示する <command>locale</command> コマンド"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <command>locale</command> command lists a summary of the current configuration of various locale parameters (date format, numbers format, etc.), presented in the form of a group of standard environment variables dedicated to the dynamic modification of these settings."
msgstr "<command>locale</command> コマンドは、ロケールの設定を動的に変更するために設けられた標準的な環境変数の形で、さまざまなロケール関連パラメータ (日付フォーマット、番号フォーマットなど) の現在の設定の概要を表示します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Setting the Default Language"
msgstr "デフォルト言語の設定"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>locales</primary>"
msgstr "<primary>ロケール</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>language</primary>"
msgstr "<primary>言語</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>locale-gen</command></primary>"
msgstr "<primary><command>locale-gen</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "A locale is a group of regional settings. This includes not only the language for text, but also the format for displaying numbers, dates, times, and monetary sums, as well as the alphabetical comparison rules (to properly account for accented characters). Although each of these parameters can be specified independently from the others, we generally use a locale, which is a coherent set of values for these parameters corresponding to a “region” in the broadest sense. These locales are usually indicated under the form, <literal><replaceable>language-code</replaceable>_<replaceable>COUNTRY-CODE</replaceable></literal>, sometimes with a suffix to specify the character set and encoding to be used. This enables consideration of idiomatic or typographical differences between different regions with a common language."
msgstr "ロケールとは地域に関する設定項目全体を指します。ロケールの内容には表示言語だけでなく、番号、日付、時間、通貨の表示書式、アルファベット比較則 (アクセント付き文字を使う言語では適切な設定が必要) が含まれます。各パラメータは独立に設定できますが、通常は同じロケールを使います。こうすることで、広い意味で「地域」に関連するパラメータに一貫性を持たせることが可能になります。ロケールは通常 <literal><replaceable>language-code</replaceable>_<replaceable>COUNTRY-CODE</replaceable></literal> の書式で表され、文字セットとエンコーディングを表すためにサフィックスを付けられる場合もあります。こうすることで、共通の言語を異なる地域で使う場合の、慣習や書体の違いを考慮することが可能になります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>CULTURE</emphasis> Character sets"
msgstr "<emphasis>CULTURE</emphasis> 文字セット"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>character set</primary>"
msgstr "<primary>文字セット</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>encoding</primary>"
msgstr "<primary>エンコーディング</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>ISO-8859-1</primary>"
msgstr "<primary>ISO-8859-1</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>ISO-8859-15</primary>"
msgstr "<primary>ISO-8859-15</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Latin 1</primary>"
msgstr "<primary>Latin 1</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Latin 9</primary>"
msgstr "<primary>Latin 9</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Historically, each locale has an associated “character set” (group of known characters) and a preferred “encoding” (internal representation for characters within the computer)."
msgstr "歴史的に言って、各ロケールは関連する「文字セット」(既知の文字のグループ) と推奨される「エンコーディング」(コンピュータにおける文字の内部表現) を持っていました。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The most popular encodings for latin-based languages were limited to 256 characters because they opted to use a single byte for each character. Since 256 characters was not enough to cover all European languages, multiple encodings were needed, and that is how we ended up with <emphasis>ISO-8859-1</emphasis> (also known as “Latin 1”) up to <emphasis>ISO-8859-15</emphasis> (also known as “Latin 9”), among others."
msgstr "ラテン語由来の言語で最も人気のあるエンコーディングの文字数は 256 文字に制限されています。なぜなら、それらのエンコーディングでは 1 文字を 1 バイトで表現するよう定めているからです。256 文字ではすべてのヨーロッパ系言語をカバーできなかったため、複数のエンコーディングが必要になり、<emphasis>ISO-8859-1</emphasis> (「Latin 1」としても知られる) から <emphasis>ISO-8859-15</emphasis> (「Latin 9」としても知られる) までが定められました。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Working with foreign languages often implied regular switches between various encodings and character sets. Furthermore, writing multilingual documents led to further, almost intractable problems. Unicode (a super-catalog of nearly all writing systems from all of the world's languages) was created to work around this problem. One of Unicode's encodings, UTF-8, retains all 128 ASCII symbols (7-bit codes), but handles other characters differently. Those are preceded by a specific escape sequence of a few bits, which implicitly defines the length of the character. This allows encoding all Unicode characters on a sequence of one or more bytes. Its use has been popularized by the fact that it is the default encoding in XML documents."
msgstr "外国語を使って仕事することは日常的に複数のエンコーディングと文字セットを切り替えることを意味していました。さらに、多言語文書を書くことはさらに難しく、ほとんど手に負えない問題でした。この問題に対処するために Unicode (全世界の言語のほぼすべての表記体系の巨大なカタログ) が作られました。Unicode エンコーディングの 1 つである UTF-8 は 128 ASCII 文字 (7 ビットコード) と互換性を保ちながら、他の文字を別のやり方で取り扱います。非 ASCII 文字は数ビットの特殊なエスケープシーケンスで始まり、このエスケープシーケンスが文字の長さを暗黙のうちに定義します。このことにより、1 バイトから数バイトのシーケンスで全 Unicode 文字の符号化が可能になります。UTF-8 は XML 文書のデフォルトエンコーディングだったため広く使われています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>ASCII</primary>"
msgstr "<primary>ASCII</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>UTF-8</primary>"
msgstr "<primary>UTF-8</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Unicode</primary>"
msgstr "<primary>Unicode</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "This is the encoding that should generally be used, and is thus the default on Debian systems."
msgstr "通常のエンコーディングは UTF-8 を使うべきで、Debian システムでは UTF-8 をデフォルトエンコーディングとしています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <emphasis role=\"pkg\">locales</emphasis> package includes all the elements required for proper functioning of “localization” of various applications. During installation, this package will ask to select a set of supported languages. This set can be changed at any time by running <command>dpkg-reconfigure locales</command> as root."
msgstr "<emphasis role=\"pkg\">locales</emphasis> パッケージには、さまざまなアプリケーションの「地域化」を適切に動作させるために必要なすべての要素が含まれます。インストールの最中、<emphasis role=\"pkg\">locales</emphasis> パッケージはシステムがサポートする言語を選択するよう求めます。システムがサポートする言語を変更するには、root で <command>dpkg-reconfigure locales</command> を実行してください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The first question invites you to select “locales” to support. Selecting all English locales (meaning those beginning with “<literal>en_</literal>”) is a reasonable choice. Do not hesitate to also enable other locales if the machine will host foreign users. The list of locales enabled on the system is stored in the <filename>/etc/locale.gen</filename> file. It is possible to edit this file by hand, but you should run <command>locale-gen</command> after any modifications. It will generate the necessary files for the added locales to work, and remove any obsolete files."
msgstr "<emphasis role=\"pkg\">locales</emphasis> パッケージのインストール中、最初の質問でサポートしたい「ロケール」を選択します。すべての英語ロケール (つまり「<literal>en_</literal>」で始まるロケール) を有効化するのが合理的です。外国人ユーザがマシンを使う場合、ためらわずに他の言語も有効化してください。システムがサポートするロケールのリストは <filename>/etc/locale.gen</filename> ファイルに保存されています。<filename>/etc/locale.gen</filename> ファイルを手作業で編集することも可能ですが、変更が終わったら <command>locale-gen</command> を実行するべきです。<command>locale-gen</command> は追加されたロケールを動作させるために必要なファイルを生成し、古いファイルを削除します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The second question, entitled “Default locale for the system environment”, requests a default locale. The recommended choice in the U.S.A. is “<literal>en_US.UTF-8</literal>”. British English speakers will prefer “<literal>en_GB.UTF-8</literal>”, and Canadians will prefer either “<literal>en_CA.UTF-8</literal>” or, for French, “<literal>fr_CA.UTF-8</literal>”. The <filename>/etc/default/locale</filename> file will then be modified to store this choice. From there, it is picked up by all user sessions since PAM will inject its content in the <varname>LANG</varname> environment variable."
msgstr "2 番目の質問は「システム環境のデフォルトロケール」と銘打たれ、ここでデフォルトロケールを選択します。アメリカ合衆国では「<literal>en_US.UTF-8</literal>」を選ぶことを推奨します。イギリス英語話者は「<literal>en_GB.UTF-8</literal>」、カナダ人は「<literal>en_CA.UTF-8</literal>」またはフランス語の「<literal>fr_CA.UTF-8</literal>」のどちらかを好むでしょう。その後、デフォルトロケールを保存する <filename>/etc/default/locale</filename> ファイルが修正されます。これ以降、設定されたデフォルトロケールがすべてのユーザセッションに適用されます。なぜなら、PAM が <varname>LANG</varname> 環境変数内に <filename>/etc/default/locale</filename> ファイルの内容を代入するからです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>environment</primary>"
msgstr "<primary>環境</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>locale</primary>"
msgstr "<primary>ロケール</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><varname>LANG</varname></primary>"
msgstr "<primary><varname>LANG</varname></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BEHIND THE SCENES</emphasis> <filename>/etc/environment</filename> and <filename>/etc/default/locale</filename>"
msgstr "<emphasis>BEHIND THE SCENES</emphasis> <filename>/etc/environment</filename> と <filename>/etc/default/locale</filename>"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: https://wiki.debian.org/Locale;
msgid "The <filename>/etc/environment</filename> file provides the <command>login</command>, <command>gdm</command>, or even <command>ssh</command> programs with the correct environment variables to be created."
msgstr "<filename>/etc/environment</filename> ファイルには <command>login</command>、<command>gdm</command>、<command>ssh</command> プログラムが設定する正しい環境変数が含まれています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "These applications do not create these variables directly, but rather via a PAM (<filename>pam_env.so</filename>) module. PAM (Pluggable Authentication Module) is a modular library centralizing the mechanisms for authentication, session initialization, and password management. See <xref linkend=\"sect.config-pam\" /> for an example of PAM configuration."
msgstr "これらのアプリケーションは環境変数を直接設定するものではありませんが、PAM (<filename>pam_env.so</filename>) モジュール経由で環境変数を設定します。PAM (Pluggable Authentication Module) は認証、セッション初期化、パスワード管理のメカニズムを一元管理化するモジュール式のライブラリです。PAM 設定の例は<xref linkend=\"sect.config-pam\" />をご覧ください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <filename>/etc/default/locale</filename> file works in a similar manner, but contains only the <varname>LANG</varname> environment variable. Thanks to this split, some PAM users can inherit a complete environment without localization. Indeed, it is generally discouraged to run server programs with localization enabled; on the other hand, localization and regional settings are recommended for programs that open user sessions."
msgstr "<filename>/etc/default/locale</filename> ファイルも同様に動作しますが、ファイルに含まれているのは <varname>LANG</varname> 環境変数だけです。このようにファイルを分離しているおかげで、一部の PAM ユーザは地域化せずに完全な環境を継承できます。実際のところ、サーバプログラムを地域化した状態で実行することは推奨されません。その一方で、ユーザセッションを開くプログラムが地域化と地域設定を行うことは推奨されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>PAM</primary>"
msgstr "<primary>PAM</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><filename>pam_env.so</filename></primary>"
msgstr "<primary><filename>pam_env.so</filename></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Configuring the Keyboard"
msgstr "キーボードの設定"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>keyboard layout</primary>"
msgstr "<primary>キーボードレイアウト</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>layout, keyboard</primary>"
msgstr "<primary>レイアウト、キーボード</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Even if the keyboard layout is managed differently in console and graphical mode, Debian offers a single configuration interface that works for both: it is based on debconf and is implemented in the <emphasis role=\"pkg\">keyboard-configuration</emphasis> package. Thus the <command>dpkg-reconfigure keyboard-configuration</command> command can be used at any time to reset the keyboard layout."
msgstr "キーボードレイアウトの管理方法がコンソールとグフラフィカルモードで違っていたとしても、Debian には両方を設定できる単一の設定インターフェースが提供されています。設定インターフェースは debconf に基づいており、<emphasis role=\"pkg\">keyboard-configuration</emphasis> パッケージに実装されています。キーボードレイアウトをリセットする際には、<command>dpkg-reconfigure keyboard-configuration</command> を使います。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis>console-data</emphasis></primary>"
msgstr "<primary><emphasis>console-data</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis>console-tools</emphasis></primary>"
msgstr "<primary><emphasis>console-tools</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis>keyboard-configuration</emphasis></primary>"
msgstr "<primary><emphasis>keyboard-configuration</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: PTAL:
# Tag: Localized;
msgid "<indexterm><primary><literal>azerty</literal></primary></indexterm>The questions are relevant to the physical keyboard layout (a standard PC keyboard in the US will be a “Generic 104 key”), then the layout to choose (generally “US”), and then the position of the AltGr key (right Alt). Finally comes the question of the key to use for the “Compose key”, which allows for entering special characters by combining keystrokes. Type successively <keycombo action=\"seq\"><keycap>Compose</keycap><keycap>'</keycap><keycap>e</keycap></keycombo> and produce an e-acute (“é”). All these combinations are described in the <filename>/usr/share/X11/locale/en_US.UTF-8/Compose</filename> file (or another file, determined according to the current locale indicated by <filename>/usr/share/X11/locale/compose.dir</filename>)."
msgstr "<indexterm><primary><literal>QWERTY</literal></primary></indexterm>ここでは、キーボードモデル (日本で使われる一般的な PC キーボードの場合「標準 105 キー (国際) PC」)、キーボードレイアウト (通常「日本語」)、AltGr キーの場所 (「キーボード配置のデフォルト」) について質問されます。最後に「Compose キー」として使うキーが質問されます (「コンポーズキーなし」)。Compose キーはキーストロークを組み合わせて特殊文字を入力する際に使われます。<keycombo action=\"seq\"><keycap>Compose</keycap><keycap>'</keycap><keycap>e</keycap></keycombo> を入力すると、アクセント付き e「é」が入力できるはずです。キーストロークの組み合わせは <filename>/usr/share/X11/locale/ja_JP.UTF-8/Compose</filename> ファイル (または、<filename>/usr/share/X11/locale/compose.dir</filename> に書かれた現在のロケールに従って定義された別ファイル) に記述されています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><literal>Compose</literal>, key</primary>"
msgstr "<primary><literal>Compose</literal>、キー</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><literal>Meta</literal>, key</primary>"
msgstr "<primary><literal>メタ</literal>、キー</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>key</primary><secondary><literal>Meta</literal></secondary>"
msgstr "<primary>キー</primary><secondary><literal>メタ</literal></secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>key</primary><secondary><literal>Compose</literal></secondary>"
msgstr "<primary>キー</primary><secondary><literal>Compose</literal></secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Note that the keyboard configuration for graphical mode described here only affects the default layout; the GNOME and KDE environments, among others, provide a keyboard control panel in their preferences allowing each user to have their own configuration. Some additional options regarding the behavior of some particular keys are also available in these control panels."
msgstr "ここで述べたグラフィカルモードのキーボード設定によって影響を受けるのはデフォルトレイアウトだけです。特に GNOME と KDE 環境では、環境設定の中にキーボードコントロールパネルがあり、これを使うことで各ユーザが固有のキーボードを設定することが可能です。特別なキーの挙動に関する追加的オプションもこのコントロールパネルから設定できます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Migrating to UTF-8"
msgstr "UTF-8 への移行"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The generalization of UTF-8 encoding has been a long awaited solution to numerous difficulties with interoperability, since it facilitates international exchange and removes the arbitrary limits on characters that can be used in a document. The one drawback is that it had to go through a rather difficult transition phase. Since it could not be completely transparent (that is, it could not happen at the same time all over the world), two conversion operations were required: one on file contents, and the other on filenames. Fortunately, the bulk of this migration has been completed and we discuss it largely for reference."
msgstr "UTF-8 エンコーディングのような一般化は、相互運用性の多くの困難を解決できるとして、長く待ち望まれていました。なぜなら、一般化することで、国際交流が簡単になり、文書で使うことのできる文字を好き勝手に制限する必要がなくなるからです。こうすることによる欠点の 1 つが、厳しい移行期間を切り抜けなければいけない点です。移行期間は完全に透過的にできない (つまり、全世界で同時に移行することはできない) ため、2 つの変換操作が必要です。具体的に言えば、ファイル内容とファイル名のエンコーディングを変換する必要があります。幸いなことに、この移行はほとんど完了していますが、参考までに大筋を議論します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>CULTURE</emphasis> <foreignphrase>Mojibake</foreignphrase> and interpretation errors"
msgstr "<emphasis>CULTURE</emphasis> <foreignphrase>文字化け</foreignphrase>と解釈エラー"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "When a text is sent (or stored) without encoding information, it is not always possible for the recipient to know with certainty what convention to use for determining the meaning of a set of bytes. You can usually get an idea by getting statistics on the distribution of values present in the text, but that doesn't always give a definite answer. When the encoding system chosen for reading differs from that used in writing the file, the bytes are mis-interpreted, and you get, at best, errors on some characters, or, at worst, something completely illegible."
msgstr "エンコーディング情報なしにテキストが送信 (または保存) された場合、受信者にとって、どのような変換を使えばバイトセットの意味を決定できるかを確定することは、常に可能なことではありません。通常、テキスト内に存在する値の分布の統計を取ることで、変換に必要な情報を得ることができますが、常に確定的な答えを得られるわけではありません。読み出し時に使ったエンコーディングシステムが書き込み時に使ったものと異なる場合、バイトセットは間違って解釈され、良くてもいくつかの文字が間違って表示され、悪ければ全く判読できなくなります。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: PTAL;
msgid "Thus, if a French text appears normal with the exception of accented letters and certain symbols which appear to be replaced with sequences of characters like “Ã©” or Ã¨” or “Ã§”, it is probably a file encoded as UTF-8 but interpreted as ISO-8859-1 or ISO-8859-15. This is a sign of a local installation that has not yet been migrated to UTF-8. If, instead, you see question marks instead of accented letters — even if these question marks seem to also replace a character that should have followed the accented letter — it is likely that your installation is already configured for UTF-8 and that you have been sent a document encoded in Western ISO."
msgstr "そんなわけで、フランス語テキストが「Ã©」、「Ã¨」、「Ã§」などの文字列で置き換えらたアクセント付き文字と若干の記号を除いて正常に表示された場合、これはおそらく UTF-8 にエンコードされたファイルを ISO-8859-1 または ISO-8859-15 で解釈して表示したということでしょう。この状況は、ローカル設定がまだ UTF-8 に移行されていないことの証です。逆に、アクセント付き文字ではなく疑問符が表示され、さらにその疑問符をアクセント付き文字とその後に続く適当な文字に置き換えることができそうな場合、ローカル設定は既に UTF-8 に移行されていて西欧の ISO でエンコードされていたファイルを UTF-8 で解釈して表示したということかもしれません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "So much for “simple” cases. These cases only appear in Western culture, since Unicode (and UTF-8) was designed to maximize the common points with historical encodings for Western languages based on the Latin alphabet, which allows recognition of parts of the text even when some characters are missing."
msgstr "「単純な」場合はそんなところです。西欧言語圏ではこれだけで済むかもしれません。なぜなら、Unicode (と UTF-8) はラテンアルファベットに基づく西欧言語向けの歴史的なエンコーディングとの共通点を最大化するように設計されたからです。このため、いくつかの文字が欠落してもテキストの一部を理解できるのです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "In more complex configurations, which, for example, involve two environments corresponding to two different languages that do not use the same alphabet, you often get completely illegible results — a series of abstract symbols that have nothing to do with each other. This is especially common with Asian languages due to their numerous languages and writing systems. The Japanese word <foreignphrase>mojibake</foreignphrase> has been adopted to describe this phenomenon. When it appears, diagnosis is more complex and the simplest solution is often to simply migrate to UTF-8 on both sides."
msgstr "より複雑な構成の場合、たとえば異なる文字体系を使う 2 つの異なる言語向けの 2 つの環境の間で情報をやり取りする場合、全く判読できない結果 (互いに関連性のない抽象記号) が表示されることが多いです。アジア圏では、言語と表記体系が数多くあるために、このような状況が良く起こります。<foreignphrase>文字化け</foreignphrase>という日本の言葉がこの状況を言い表すために使われ続けています。<foreignphrase>文字化け</foreignphrase>した場合、原因分析はさらに複雑です。<foreignphrase>文字化け</foreignphrase>に対する元も単純な解決策は双方が UTF-8 に移行することです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "As far as file names are concerned, the migration can be relatively simple. The <command>convmv</command> tool (in the package with the same name) was created specifically for this purpose; it allows renaming files from one encoding to another. The use of this tool is relatively simple, but we recommend doing it in two steps to avoid surprises. The following example illustrates a UTF-8 environment containing directory names encoded in ISO-8859-15, and the use of <command>convmv</command> to rename them."
msgstr "ファイル名だけについて言えば、移行は比較的単純です。<command>convmv</command> ツール (同名のパッケージに含まれます) はこの目的専用に作られました。従って、これはファイル名をあるエンコーディングから他のエンコーディングに変更します。このツールの使い方は比較的単純ですが、意図しない変換を避けるために 2 段階に分けて行うことを推奨します。以下の例では、ISO-8859-15 でエンコードされたディレクトリ名を含む UTF-8 環境で、<command>convmv</command> を使ってディレクトリ名をリネームする方法を示しています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"<computeroutput>$ </computeroutput><userinput>ls travail/</userinput>\n"
"<computeroutput>Ic?nes  ?l?ments graphiques  Textes\n"
"$ </computeroutput><userinput>convmv -r -f iso-8859-15 -t utf-8 travail/</userinput>\n"
"<computeroutput>Starting a dry run without changes...\n"
"mv \"travail/�l�ments graphiques\"        \"travail/Éléments graphiques\"\n"
"mv \"travail/Ic�nes\"     \"travail/Icônes\"\n"
"No changes to your files done. Use --notest to finally rename the files.\n"
"$ </computeroutput><userinput>convmv -r --notest -f iso-8859-15 -t utf-8 travail/</userinput>\n"
"<computeroutput>mv \"travail/�l�ments graphiques\"        \"travail/Éléments graphiques\"\n"
"mv \"travail/Ic�nes\"     \"travail/Icônes\"\n"
"Ready!\n"
"$ </computeroutput><userinput>ls travail/</userinput>\n"
"<computeroutput>Éléments graphiques  Icônes  Textes</computeroutput>"
msgstr ""
"<computeroutput>$ </computeroutput><userinput>ls travail/</userinput>\n"
"<computeroutput>Ic?nes  ?l?ments graphiques  Textes\n"
"$ </computeroutput><userinput>convmv -r -f iso-8859-15 -t utf-8 travail/</userinput>\n"
"<computeroutput>Starting a dry run without changes...\n"
"mv \"travail/�l�ments graphiques\"        \"travail/Éléments graphiques\"\n"
"mv \"travail/Ic�nes\"     \"travail/Icônes\"\n"
"No changes to your files done. Use --notest to finally rename the files.\n"
"$ </computeroutput><userinput>convmv -r --notest -f iso-8859-15 -t utf-8 travail/</userinput>\n"
"<computeroutput>mv \"travail/�l�ments graphiques\"        \"travail/Éléments graphiques\"\n"
"mv \"travail/Ic�nes\"     \"travail/Icônes\"\n"
"Ready!\n"
"$ </computeroutput><userinput>ls travail/</userinput>\n"
"<computeroutput>Éléments graphiques  Icônes  Textes</computeroutput>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "For the file content, conversion procedures are more complex due to the vast variety of existing file formats. Some file formats include encoding information that facilitates the tasks of the software used to treat them; it is sufficient, then, to open these files and re-save them specifying UTF-8 encoding. In other cases, you have to specify the original encoding (ISO-8859-1 or “Western”, or ISO-8859-15 or “Western (Euro)”, according to the formulations) when opening the file."
msgstr "ファイル内容について言えば、既存のファイルフォーマットにはたくさんの種類があるため、変換手順はさらに複雑になります。いくつかのファイルフォーマットにはエンコーディング情報が含まれているため、そのフォーマットを取り扱うソフトウェアは適切にエンコーディング情報を取り扱うことが可能です。さらにこの場合、ファイルを開いて UTF-8 エンコーディングを指定して再保存するだけ十分です。その他の場合、そのファイルを開く際に元のエンコーディングを指定 (形式に従って ISO-8859-1 や「西欧」、ISO-8859-15 や「西欧 (ユーロ)」など) しなければいけません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "For simple text files, you can use <command>recode</command> (in the package of the same name) which allows automatic recoding. This tool has numerous options so you can play with its behavior. We recommend you consult the documentation, the <citerefentry> <refentrytitle>recode</refentrytitle> <manvolnum>1</manvolnum> </citerefentry> man page, or the <citerefentry> <refentrytitle>recode</refentrytitle> </citerefentry> info page (more complete)."
msgstr "単純なテキストファイルの場合、<command>recode</command> (同名のパッケージに含まれます) を使えば自動的にエンコーディングを変換できます。このツールは数多くのオプションを備えていますので、いろいろと試してみてください。<citerefentry> <refentrytitle>recode</refentrytitle> <manvolnum>1</manvolnum> </citerefentry> man ページ、<citerefentry> <refentrytitle>recode</refentrytitle> </citerefentry> info ページ (より詳しい) などの文書を調べることもお勧めします。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Configuring the Network"
msgstr "ネットワークの設定"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> Essential network concepts (Ethernet, IP address, subnet, broadcast)"
msgstr "<emphasis>BACK TO BASICS</emphasis> ネットワークの本質的概念 (イーサネット、IP アドレス、サブネット、ブロードキャスト)"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Ethernet</primary>"
msgstr "<primary>イーサネット</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>10BASE-T</primary>"
msgstr "<primary>10BASE-T</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>100BASE-T</primary>"
msgstr "<primary>100BASE-T</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>1000BASE-T</primary>"
msgstr "<primary>1000BASE-T</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>10GBASE-T</primary>"
msgstr "<primary>10GBASE-T</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>connector, RJ45</primary>"
msgstr "<primary>コネクタ、RJ45</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>RJ45 connector</primary>"
msgstr "<primary>RJ45 コネクタ</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Most modern local networks use the Ethernet protocol, where data is split into small blocks called frames and transmitted on the wire one frame at a time. Data speeds vary from 10 Mb/s for older Ethernet cards to 10 Gb/s in the newest cards (with the most common rate currently growing from 100 Mb/s to 1 Gb/s). The most widely used cables are called 10BASE-T, 100BASE-T, 1000BASE-T or 10GBASE-T depending on the throughput they can reliably provide (the T stands for “twisted pair”); those cables end in an RJ45 connector. There are other cable types, used mostly for speeds of 1 Gb/s and above."
msgstr "多くの現代的なローカルネットワークがイーサネットプロトコルを使っています。データはフレームと呼ばれる小さなブロックに分割され、一度に 1 つのフレームがワイヤ上で転送されます。データ転送速度は古いイーサネットカードの 10 Mb/s から新しいカードの 10 Gb/s (現在最も一般的な速度は 100 Mb/s から 1 Gb/s) までさまざまあります。最も広く使われているケーブルは、確実に保証される転送速度に依存して 10BASE-T、100BASE-T、1000BASE-T、10GBASE-T と呼ばれています(T は「ツイストペア」を意味しています)。ケーブルの終端には RJ45 コネクタが付いています。他のケーブル型もあり、それらは 1 Gb/s 以上の速度で使われています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>address, IP address</primary>"
msgstr "<primary>アドレス、IP アドレス</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>IP address</primary>"
msgstr "<primary>IP アドレス</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "An IP address is a number used to identify a network interface on a computer on a local network or the Internet. In the currently most widespread version of IP (IPv4), this number is encoded in 32 bits, and is usually represented as 4 numbers separated by periods (e.g. <literal>192.168.0.1</literal>), each number being between 0 and 255 (inclusive, which corresponds to 8 bits of data). The next version of the protocol, IPv6, extends this addressing space to 128 bits, and the addresses are generally represented as a series of hexadecimal numbers separated by colons (e.g., 2001:0db8:13bb:0002:0000:0000:0000:0020, or 2001:db8:13bb:2::20 for short)."
msgstr "IP アドレスは、ローカルネットワークやインターネットでコンピュータのネットワークインターフェースを識別するために使われる番号です。IP の現在最も広く使われているバージョン (IPv4) では、IP アドレスは 32 ビットにエンコードされ、通常ピリオドで区切った 4 個の数字で表現されます (例 <literal>192.168.0.1</literal>)、それぞれの数字は 0 以上 255 以下です (8 ビットのデータに対応します)。IP の次期バージョン IPv6 では、アドレス空間を 128 ビットに拡張し、IP アドレスは通常コロンで区切られた 16 進数列で表されます (たとえば 2001:0db8:13bb:0002:0000:0000:0000:0020 などで、これは短縮形の場合 2001:db8:13bb:2::20 と表されます)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>subnet</primary>"
msgstr "<primary>サブネット</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>mask</primary><secondary>subnet mask</secondary>"
msgstr "<primary>マスク</primary><secondary>サブネットマスク</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>network</primary><secondary>address</secondary>"
msgstr "<primary>ネットワーク</primary><secondary>アドレス</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: https://en.wikipedia.org/wiki/Host_address;
# Tag: PTAL;
msgid "A subnet mask (netmask) defines in its binary code which portion of an IP address corresponds to the network, the remainder specifying the machine. In the example of configuring a static IPv4 address given here, the subnet mask, <literal>255.255.255.0</literal> (24 “1”s followed by 8 “0”s in binary representation) indicates that the first 24 bits of the IP address correspond to the network address, and the other 8 are specific to the machine. In IPv6, for readability, only the number of “1”s is expressed; the netmask for an IPv6 network could, thus, be <literal>64</literal>."
msgstr "サブネットマスク (ネットマスク) は 2 進コードの形で、ある IP アドレスのネットワークに相当する部分を定義します。残りの部分はマシンに相当する部分を定義します。ここで挙げる静的 IPv4 アドレスの設定例では、サブネットマスク <literal>255.255.255.0</literal> (2 進数表記では 24 個の「1」の後に 8 個の「0」が並ぶ) は IP アドレスの最初の 24 ビット分がネットワークアドレスに対応し、残りの 8 ビット分がマシンに固有のアドレスであることを意味しています。IPv6 では可読性を高めるためにネットマスクを 2 進数表記した際に「1」となるビットの個数で表すので、ネットマスクは <literal>64</literal> のように書けます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The network address is an IP address in which the part describing the machine's number is 0. The range of IPv4 addresses in a complete network is often indicated by the syntax, <emphasis>a.b.c.d/e</emphasis>, in which <emphasis>a.b.c.d</emphasis> is the network address and <emphasis>e</emphasis> is the number of bits affected to the network part in an IP address. The example network would thus be written: <literal>192.168.0.0/24</literal>. The syntax is similar in IPv6: <literal>2001:db8:13bb:2::/64</literal>."
msgstr "ネットワークアドレスは IP アドレスの一種で、マシン番号を表現する部分は 0 で表されます。完全なネットワークにおける IPv4 アドレスの範囲は通常 <emphasis>a.b.c.d/e</emphasis> という構文で表現されます。ここで、<emphasis>a.b.c.d</emphasis> はネットワークアドレスで <emphasis>e</emphasis> は IP アドレスのネットワーク部分を表すビット数です。つまり例のネットワークは <literal>192.168.0.0/24</literal> のように表現されます。IPv6 の場合も構文は似ており、<literal>2001:db8:13bb:2::/64</literal> のように表現されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>router</primary>"
msgstr "<primary>ルータ</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>bridge</primary>"
msgstr "<primary>ブリッジ</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "A router is a machine that connects several networks to each other. All traffic coming through a router is guided to the correct network. To do this, the router analyzes incoming packets and redirects them according to the IP address of their destination. The router is often known as a gateway; in this configuration, it works as a machine that helps reach out beyond a local network (towards an extended network, such as the Internet)."
msgstr "ルータとは、複数のネットワークを相互に接続するマシンです。ルータを通過するすべてのトラフィックは接続されたネットワークに誘導されます。これを行うために、ルータは着信パケットを解析し、宛先の IP アドレスに従ってパケットを転送します。ルータは通常ゲートウェイとしても知られています。ルータがゲートウェイの役割を果たす場合、ルータはローカルネットワークを越える (インターネットなどの外部ネットワークに向かう) ためのマシンとして機能します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>broadcast</primary>"
msgstr "<primary>ブロードキャスト</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The special broadcast address connects all the stations in a network. Almost never “routed”, it only functions on the network in question. Specifically, it means that a data packet addressed to the broadcast never passes through the router."
msgstr "ブロードキャストアドレスは特殊なアドレスでネットワークにいるすべてのマシンに対応付けられています。ブロードキャストアドレスは、ほとんど「転送され」ませんし、当該のネットワークだけを対象に働きます。具体的に言うと、ブロードキャスト宛のデータパケットはルータを通過しないことを意味しています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "This chapter focuses on IPv4 addresses, since they are currently the most commonly used. The details of the IPv6 protocol are approached in <xref linkend=\"sect.ipv6\" />, but the concepts remain the same."
msgstr "この章では IPv4 アドレスだけに注目します。なぜなら IPv4 アドレスは現在最も一般的に利用されているからです。IPv6 プロトコルの詳細は<xref linkend=\"sect.ipv6\" />で説明されていますが、その概念は IPv4 と同じです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Since the network is automatically configured during the initial installation, the <filename>/etc/network/interfaces</filename> file already contains a valid configuration. A line starting with <literal>auto</literal> gives a list of interfaces to be automatically configured on boot by <emphasis role=\"pkg\">ifupdown</emphasis> and its <filename>/etc/init.d/networking</filename> init script. This will often be <literal>eth0</literal>, which refers to the first Ethernet card."
msgstr "ネットワークは初回インストール時に自動設定されますので、<filename>/etc/network/interfaces</filename> ファイルには既にさまざまな設定が含まれています。<literal>auto</literal> で始まる行は、起動時に <emphasis role=\"pkg\">ifupdown</emphasis> と <filename>/etc/init.d/networking</filename> init スクリプトで自動的に設定したい、インターフェースのリストです。通常 <literal>eth0</literal> は自動設定したいインターフェースで、1 つ目のイーサネットカードを意味しています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>network</primary><secondary>configuration</secondary>"
msgstr "<primary>ネットワーク</primary><secondary>設定</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>configuration</primary><secondary>of the network</secondary>"
msgstr "<primary>設定</primary><secondary>ネットワークの設定</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>interface</primary><secondary>network interface</secondary>"
msgstr "<primary>インターフェース</primary><secondary>ネットワークインターフェース</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><literal>eth0</literal></primary>"
msgstr "<primary><literal>eth0</literal></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>ALTERNATIVE</emphasis> NetworkManager"
msgstr "<emphasis>ALTERNATIVE</emphasis> NetworkManager"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis role=\"pkg\">network-manager</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">network-manager</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: PTAL;
msgid "If Network Manager is particularly recommended in roaming setups (see <xref linkend=\"sect.roaming-network-config\" />), it is also perfectly usable as the default network management tool. You can create “System connections” that are used as soon as the computer boots either manually with a <filename>.ini</filename>-like file in <filename>/etc/NetworkManager/system-connections/</filename> or through a graphical tool (<command>nm-connection-editor</command>). Just remember to deactivate all entries in <filename>/etc/network/interfaces</filename> if you want Network Manager to handle them. <ulink type=\"block\" url=\"https://wiki.gnome.org/Projects/NetworkManager/SystemSettings/jessie\" /> <ulink type=\"block\" url=\"https://developer.gnome.org/NetworkManager/0.9/ref-settings.html\" />"
msgstr "NetworkManager はマシンを移動して使う場合に特に推奨され (<xref linkend=\"sect.roaming-network-config\" />を参照してください)、デフォルトのネットワーク管理ツールとしても極めて便利です。コンピュータの起動の可能な限り早い段階で使われる「システム接続」を作るには、<filename>/etc/NetworkManager/system-connections/</filename> 内の <filename>.ini</filename> 系ファイルを手作業で編集するか、またはグラフィカルツール (<command>nm-connection-editor</command>) を使います。NetworkManager でネットワーク接続を管理する場合、<filename>/etc/network/interfaces</filename> に含まれるすべてのエントリを無効化するのを忘れないでください。<ulink type=\"block\" url=\"https://wiki.gnome.org/Projects/NetworkManager/SystemSettings/jessie\" /><ulink type=\"block\" url=\"https://developer.gnome.org/NetworkManager/0.9/ref-settings.html\" />"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Ethernet Interface"
msgstr "イーサネットインターフェース"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "If the computer has an Ethernet card, the IP network that is associated with it must be configured by choosing from one of two methods. The simplest method is dynamic configuration with DHCP, and it requires a DHCP server on the local network. It may indicate a desired hostname, corresponding to the <literal>hostname</literal> setting in the example below. The DHCP server then sends configuration settings for the appropriate network."
msgstr "コンピュータにイーサネットカードが付けられている場合、イーサネットカードに関連付けられる IP ネットワークは 1 つか 2 つの方法で必ず設定されなければいけません。最も簡単な方法は DHCP を使う動的設定で、これにはローカルネットワークで DHCP サーバを動かす必要があります。動的設定では、以下の例で <literal>hostname</literal> 設定に対応する、希望ホスト名を示すことが可能です。そして、DHCP サーバは適切なネットワーク設定を送信します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>DHCP</primary>"
msgstr "<primary>DHCP</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "DHCP configuration"
msgstr "DHCP 設定"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"auto eth0\n"
"iface eth0 inet dhcp\n"
"  hostname arrakis"
msgstr ""
"\n"
"auto eth0\n"
"iface eth0 inet dhcp\n"
"  hostname arrakis"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "A “static” configuration must indicate network settings in a fixed manner. This includes at least the IP address and subnet mask; network and broadcast addresses are also sometimes listed. A router connecting to the exterior will be specified as a gateway."
msgstr "「静的」設定の場合、必ず決められた方法でネットワーク設定を定義しなければいけません。「静的」設定には少なくとも IP アドレスとサブネットマスクが含まれます。さらに場合によってはネットワークとブロードキャストアドレスが含まれることがあります。ゲートウェイには外部に接続しているルータを指定します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Static configuration"
msgstr "静的設定"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"auto eth0\n"
"iface eth0 inet static\n"
"  address 192.168.0.3\n"
"  netmask 255.255.255.0\n"
"  broadcast 192.168.0.255\n"
"  network 192.168.0.0\n"
"  gateway 192.168.0.1"
msgstr ""
"\n"
"auto eth0\n"
"iface eth0 inet static\n"
"  address 192.168.0.3\n"
"  netmask 255.255.255.0\n"
"  broadcast 192.168.0.255\n"
"  network 192.168.0.0\n"
"  gateway 192.168.0.1"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>NOTE</emphasis> Multiple addresses"
msgstr "<emphasis>NOTE</emphasis> 複数アドレス"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "It is possible not only to associate several interfaces to a single, physical network card, but also several IP addresses to a single interface. Remember also that an IP address may correspond to any number of names via DNS, and that a name may also correspond to any number of numerical IP addresses."
msgstr "複数のインターフェースに 1 つの物理ネットワークカードを関連付けることだけでなく、1 つのインターフェースに複数の IP アドレスを関連付けることも可能です。ある IP アドレスは DNS 経由で複数の名前に関連付けられているかもしれませんし、ある名前は複数の数値 IP アドレスに関連付けられているかもしれません。この点も忘れないでください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "As you can guess, the configurations can be rather complex, but these options are only used in very special cases. The examples cited here are typical of the usual configurations."
msgstr "お察しの通り、この設定はちょっと複雑で、この設定が必要になるのはとても特殊な場合だけです。ここで引用しているのは、典型的な通常設定の例です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Connecting with PPP through a PSTN Modem"
msgstr "PSTN モデム経由の PPP 接続"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>PPP</primary>"
msgstr "<primary>PPP</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>point to point</primary>"
msgstr "<primary>2 点間</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>connection</primary><secondary>by PSTN modem</secondary>"
msgstr "<primary>接続</primary><secondary>PSTN モデムを使った接続</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>modem</primary><secondary>PSTN</secondary>"
msgstr "<primary>モデム</primary><secondary>PSTN</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "A point to point (PPP) connection establishes an intermittent connection; this is the most common solution for connections made with a telephone modem (“PSTN modem”, since the connection goes over the public switched telephone network)."
msgstr "2 点間 (PPP) 接続は断続的な接続を確立します。さらに PPP 接続は電話モデム (「PSTN モデム」とも呼ばれます。この名前は公衆交換電話網を経由して接続するところから付けられました) を使って接続する場合の最も一般的な接続方法です。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Checked-By: Osamu Aoki;
msgid "A connection by telephone modem requires an account with an access provider, including a telephone number, username, password, and, sometimes the authentication protocol to be used. Such a connection is configured using the <command>pppconfig</command> tool in the Debian package of the same name. By default, it sets up a connection named <literal>provider</literal> (as in Internet service provider). When in doubt about the authentication protocol, choose <emphasis>PAP</emphasis>: it is offered by the majority of Internet service providers."
msgstr "電話モデムを使って接続する場合、アクセスプロバイダのアカウント (電話番号、ユーザ名、パスワード) が必要で、認証プロトコルを使うこともあります。PPP 接続は <command>pppconfig</command> ツール (同名の Debian パッケージに含まれます) を使って設定されます。デフォルトで、<command>pppconfig</command> ツールは <literal>provider</literal> (インターネットサービスプロバイダのように) と名付けられた接続を設定します。認証プロトコルがよく分からなければ、<emphasis>PAP</emphasis> を使ってください。大多数のインターネットサービスプロバイダは <emphasis>PAP</emphasis> を提供しています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>pppconfig</command></primary>"
msgstr "<primary><command>pppconfig</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>PAP</primary>"
msgstr "<primary>PAP</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "After configuration, it is possible to connect using the <command>pon</command> command (giving it the name of the connection as a parameter, when the default value of <literal>provider</literal> is not appropriate). The link is disconnected with the <command>poff</command> command. These two commands can be executed by the root user, or by any other user, provided they are in the <literal>dip</literal> group."
msgstr "設定が完了したら、<command>pon</command> コマンドを使って接続することが可能です (デフォルト接続名である <literal>provider</literal> が適切でない場合、接続名をパラメータとして与えてください)。リンクを切断するには <command>poff</command> コマンドを使ってください。これら 2 つのコマンドを実行できるのは、root ユーザと <literal>dip</literal> グループに所属するユーザだけです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>pon</command></primary>"
msgstr "<primary><command>pon</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>poff</command></primary>"
msgstr "<primary><command>poff</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Connecting through an ADSL Modem"
msgstr "ADSL モデム経由の接続"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>connection</primary><secondary>by ADSL modem</secondary>"
msgstr "<primary>接続</primary><secondary>ADSL モデムによる接続</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>modem</primary><secondary>ADSL</secondary>"
msgstr "<primary>モデム</primary><secondary>ADSL</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>ADSL, modem</primary>"
msgstr "<primary>ADSL、モデム</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The generic term “ADSL modem” covers a multitude of devices with very different functions. The modems that are simplest to use with Linux are those that have an Ethernet interface (and not only a USB interface). These tend to be popular; most ADSL Internet service providers lend (or lease) a “box” with Ethernet interfaces. Depending on the type of modem, the configuration required can vary widely."
msgstr "「ADSL モデム」という一般名称の意味には、全く違う機能を持つ数多くの装置が含まれています。Linux で使うのが最も簡単なモデムはイーサネットインターフェースを持つものです (USB インターフェースではありません)。この種のモデムは人気になりつつあります。さらに、多くの ADSL インターネットサービスプロバイダはイーサネットインターフェース付きの「ボックス」を貸与します (またはリースします)。モデムの種類に依存して、必要な設定は広範囲にわたります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Modems Supporting PPPOE"
msgstr "PPPOE をサポートするモデム"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>PPPOE</primary>"
msgstr "<primary>PPPOE</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>pppoeconf</command></primary>"
msgstr "<primary><command>pppoeconf</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Some Ethernet modems work with the PPPOE protocol (Point to Point Protocol over Ethernet). The <command>pppoeconf</command> tool (from the package with the same name) will configure the connection. To do so, it modifies the <filename>/etc/ppp/peers/dsl-provider</filename> file with the settings provided and records the login information in the <filename>/etc/ppp/pap-secrets</filename> and <filename>/etc/ppp/chap-secrets</filename> files. It is recommended to accept all modifications that it proposes."
msgstr "一部のイーサネットモデムは PPPOE プロトコル (Point to Point Protocol over Ethernet) に対応しています。PPPOE 接続を設定するには、<command>pppoeconf</command> ツール (同名のパッケージに含まれます) を使います。PPPOE 接続を設定するために、<command>pppoeconf</command> ツールは与えられた設定で <filename>/etc/ppp/peers/dsl-provider</filename> ファイルを修正し、ログイン情報を <filename>/etc/ppp/pap-secrets</filename> と <filename>/etc/ppp/chap-secrets</filename> ファイルに記録します。<command>pppoeconf</command> ツールが提案したすべての変更を受け入れることを推奨します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Once this configuration is complete, you can open the ADSL connection with the command, <command>pon dsl-provider</command> and disconnect with <command>poff dsl-provider</command>."
msgstr "この設定が完了したら、<command>pon dsl-provider</command> で ADSL 接続を開始、<command>poff dsl-provider</command> で切断できます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><literal>dsl-provider</literal></primary>"
msgstr "<primary><literal>dsl-provider</literal></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>TIP</emphasis> Starting <command>ppp</command> at boot"
msgstr "<emphasis>TIP</emphasis> 起動時に <command>ppp</command> を開始"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>systemd</command></primary>"
msgstr "<primary><command>systemd</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>init</command></primary>"
msgstr "<primary><command>init</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "PPP connections over ADSL are, by definition, intermittent. Since they are usually not billed according to time, there are few downsides to the temptation of keeping them always open. The standard means to do so is to use the init system."
msgstr "定義によれば、ADSL 上の PPP 接続は断続的なものです。しかしながら、通常サービスプロバイダは時間に依存して従量課金しないので、常に接続状態を保つという誘惑に対して、ほとんど不利な点はありません。常時接続状態を保つ標準的な方法は init システムを使うことです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The default init system on <emphasis role=\"distribution\">Jessie</emphasis> is <command>systemd</command>. Adding an automatically restarting task for the ADSL connection is a simple matter of creating a “unit file” such as <filename>/etc/systemd/system/adsl-connection.service</filename>, with contents such as the following:"
msgstr "<emphasis role=\"distribution\">Jessie</emphasis> のデフォルト init システムは <command>systemd</command> です。ADSL 接続用の自動再開タスクを追加するには、以下の内容を含む <filename>/etc/systemd/system/adsl-connection.service</filename> などの「ユニットファイル」を作成するだけで簡単に行うことが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: http://www.freedesktop.org/software/systemd/man/systemd.unit.html;
# Tag: PTAL;
msgid ""
"[Unit]\n"
"Description=ADSL connection\n"
"\n"
"[Service]\n"
"Type=forking\n"
"ExecStart=/usr/sbin/pppd call dsl-provider\n"
"Restart=always\n"
"\n"
"[Install]\n"
"WantedBy=multi-user.target"
msgstr ""
"[Unit]\n"
"Description=ADSL connection\n"
"\n"
"[Service]\n"
"Type=forking\n"
"ExecStart=/usr/sbin/pppd call dsl-provider\n"
"Restart=always\n"
"\n"
"[Install]\n"
"WantedBy=multi-user.target"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Once this unit file has been defined, it needs to be enabled with <command>systemctl enable adsl-connection</command>. Then the loop can be started manually with <command>systemctl start adsl-connection</command>; it will also be started automatically on boot."
msgstr "このユニットファイルの配置を完了したら、<command>systemctl enable adsl-connection</command> を実行してこれを有効化する必要があります。その後手作業で <command>systemctl start adsl-connection</command> を実行してループを開始します。起動時にはこれが自動的に実行されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "On systems not using <command>systemd</command> (including <emphasis role=\"distribution\">Wheezy</emphasis> and earlier versions of Debian), the standard SystemV init works differently. On such systems, all that is needed is to add a line such as the following at the end of the <filename>/etc/inittab</filename> file; then, any time the connection is disconnected, <command>init</command> will reconnect it."
msgstr "<command>systemd</command> を使っていないシステム (Debian <emphasis role=\"distribution\">Wheezy</emphasis> およびそれ以前のバージョンのシステム) では、標準的な SystemV init を別の方法で設定します。このようなシステムでは、<filename>/etc/inittab</filename> ファイルの最後に以下の 1 行を追加するだけで設定は完了します。このように設定することで、接続が切断されたらいつでも、<command>init</command> が再接続を試行するようになります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"adsl:2345:respawn:/usr/sbin/pppd call dsl-provider"
msgstr ""
"\n"
"adsl:2345:respawn:/usr/sbin/pppd call dsl-provider"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "For ADSL connections that auto-disconnect on a daily basis, this method reduces the duration of the interruption."
msgstr "ADSL 接続が 1 日に 1 回自動切断されるような場合、この方法を取ることで、通信が遮断される期間を短くすることが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Modems Supporting PPTP"
msgstr "PPTP をサポートするモデム"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>PPTP</primary>"
msgstr "<primary>PPTP</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The PPTP (Point-to-Point Tunneling Protocol) protocol was created by Microsoft. Deployed at the beginning of ADSL, it was quickly replaced by PPPOE. If this protocol is forced on you, see <xref linkend=\"sect.pptp\" />."
msgstr "PPTP (Point-to-Point Tunneling Protocol) プロトコルは Microsoft によって作られました。PPTP は 初期の ADSL で使われましたが、すぐに PPPOE によって置き換えられました。PPTP を使わなければいけない場合は、<xref linkend=\"sect.pptp\" />をご覧ください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Modems Supporting DHCP"
msgstr "DHCP をサポートするモデム"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "When a modem is connected to the computer by an Ethernet cable (crossover cable) you typically configure a network connection by DHCP on the computer; the modem automatically acts as a gateway by default and takes care of routing (meaning that it manages the network traffic between the computer and the Internet)."
msgstr "モデムとコンピュータがイーサネットケーブル (クロスケーブル) で接続されている場合、通常は DHCP でコンピュータのネットワーク接続を設定します。さらにそのようなモデムは自動的にデフォルトでゲートウェイとして働き、ルーティングを処理します (これは、モデムがコンピュータとインターネットの間のネットワークトラフィックを管理することを意味しています)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> Crossover cable for a direct Ethernet connection"
msgstr "<emphasis>BACK TO BASICS</emphasis> 直接イーサネット接続用のクロスケーブル"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>crossover cable</primary>"
msgstr "<primary>クロスケーブル</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Computer network cards expect to receive data on specific wires in the cable, and send their data on others. When you connect a computer to a local network, you usually connect a cable (straight or crossover) between the network card and a repeater or switch. However, if you want to connect two computers directly (without an intermediary switch or repeater), you must route the signal sent by one card to the receiving side of the other card, and vice-versa. This is the purpose of a crossover cable, and the reason it is used."
msgstr "コンピュータネットワークカードはケーブルの特定のワイヤからデータを受信し、別のワイヤからデータを送信します。コンピュータをローカルネットワークに接続する場合、通常ネットワークカードとリピータまたはスイッチの間をケーブル (ストレートまたはクロスケーブル) で接続します。しかしながら、2 台のコンピュータを直接 (中間にスイッチやリピータを介さずに) 接続したい場合、必ず送信側カードからみた送信ワイヤに伝わる信号を受信側カードからみた受信ワイヤに (その逆も) 伝送させなければいけません。これがクロスケーブルの目的であり、クロスケーブルが使われる理由です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Note that this distinction has become almost irrelevant over time, as modern network cards are able do detect the type of cable present and adapt accordingly, so it won't be unusual that both kinds of cable will work in a given location."
msgstr "ケーブルの種類を区別して用途に合わせて使うという作業は、時間とともにほとんど無意味な作業になりつつある点に注意してください。なぜなら、最近のネットワークカードはケーブルの種類を検出して適切に適用できるからです。従って、ある場所で両方の種類のケーブルが使えるというのは異常ではありません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Most “ADSL routers” on the market can be used like this, as do most of the ADSL modems provided by Internet services providers."
msgstr "市場に出ている多くの「ADSL ルータ」とインターネットサービスプロバイダによって提供されるほとんどの ADSL モデムはこのような方法で使われます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Automatic Network Configuration for Roaming Users"
msgstr "ローミングユーザ向けの自動ネットワーク設定"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>network</primary><secondary>roaming configuration</secondary>"
msgstr "<primary>ネットワーク</primary><secondary>ローミング設定</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Many Falcot engineers have a laptop computer that, for professional purposes, they also use at home. The network configuration to use differs according to location. At home, it may be a wifi network (protected by a WPA key), while the workplace uses a wired network for greater security and more bandwidth."
msgstr "Falcot の多くのエンジニアはラップトップコンピュータを持っており、自宅でも職務上の目的を果たすためにそれを使います。使用するネットワーク設定は場所によって異なります。自宅では wifi ネットワーク (WPA 鍵で保護されている) を使っているかもしれませんし、その一方で職場ではセキュリティと帯域幅を向上させるために有線ネットワークを使っています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "To avoid having to manually connect or disconnect the corresponding network interfaces, administrators installed the <emphasis role=\"pkg\">network-manager</emphasis> package on these roaming machines. This software enables a user to easily switch from one network to another using a small icon displayed in the notification area of their graphical desktop. Clicking on this icon displays a list of available networks (both wired and wireless), so they can simply choose the network they wish to use. The program saves the configuration for the networks to which the user has already connected, and automatically switches to the best available network when the current connection drops."
msgstr "対応するネットワークインターフェースを手作業で接続したり切断するのを避けるために、管理者はローミングマシンに <emphasis role=\"pkg\">network-manager</emphasis> パッケージをインストールしました。NetworkManager を使うと、ユーザはグラフィカルデスクトップの通知エリアに表示された小さなアイコンを使って、あるネットワークから別のネットワークに簡単に切り替えることが可能です。NetworkManager のアイコンをクリックすると、利用できるネットワーク (有線と無線の両方) のリストが表示されます。このためユーザは単純に使いたいネットワークを選ぶだけです。NetworkManager は接続済みのネットワークの設定を保存します。そして現在の接続が切断された場合、利用できるネットワークから最適なものを選んで、自動的に切り替えます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "In order to do this, the program is structured in two parts: a daemon running as root handles activation and configuration of network interfaces and a user interface controls this daemon. PolicyKit handles the required authorizations to control this program and Debian configured PolicyKit in such a way so that members of the netdev group can add or change Network Manager connections."
msgstr "これを行うために、NetworkManager プログラムは 2 つに分割されています。すなわち、ネットワークインターフェースの有効化と設定を担当している root として動くデーモンと、このデーモンを操作するユーザインターフェースの 2 つに分割されています。PolicyKit は NetworkManager プログラムを操作する際に要求される認証を取り扱います。Debian は PolicyKit を設定して、netdev グループが NetworkManager の接続を追加したり、変えることができるようにしています。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: https://wiki.debian.org/NetworkManager;
# Tag: PTAL;
msgid "Network Manager knows how to handle various types of connections (DHCP, manual configuration, local network), but only if the configuration is set with the program itself. This is why it will systematically ignore all network interfaces in <filename>/etc/network/interfaces</filename> for which it is not suited. Since Network Manager doesn't give details when no network connections are shown, the easy way is to delete from <filename>/etc/network/interfaces</filename> any configuration for all interfaces that must be managed by Network Manager."
msgstr "NetworkManager はさまざまな種類の接続 (DHCP、手作業設定、ローカルネットワーク) をサポートしていますが、設定をうまく動作させるには NetworkManager プログラム以外を使ってはいけません。このため、NetworkManager は <filename>/etc/network/interfaces</filename> に含まれるすべてのネットワークインターフェースのうち、不適切なものを系統的に無視します。NetworkManager はネットワーク接続が見つからない場合にその詳細を教えてくれないので、<filename>/etc/network/interfaces</filename> から NetworkManager で管理されるすべてのインターフェースに関する設定を削除するのが簡単です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Note that this program is installed by default when the “Desktop Environment” task is chosen during initial installation."
msgstr "NetworkManager は最初のインストール中に「デスクトップ環境」タスクを選んだ場合にデフォルトでインストールされることに注意してください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>ALTERNATIVE</emphasis> Configuration by “network profile”"
msgstr "<emphasis>ALTERNATIVE</emphasis> 「ネットワークプロファイル」を使った設定"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis role=\"pkg\">guessnet</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">guessnet</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "More advanced users may want to try the <emphasis role=\"pkg\">guessnet</emphasis> package for automatic network configuration. A group of test scripts determine which network profile should be activated and configure it on the fly."
msgstr "さらに熟練したユーザは、自動的にネットワークを設定するために <emphasis role=\"pkg\">guessnet</emphasis> パッケージを試したくなるかもしれません。<emphasis role=\"pkg\">guessnet</emphasis> パッケージは臨機応変に有効化および設定すべきネットワークプロファイルがどれかを判断する一連のテストスクリプト集です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Users who prefer to manually select a network profile will prefer the <emphasis role=\"pkg\">netenv</emphasis> program, found in the package of the same name."
msgstr "ネットワークプロファイルを手作業で選択するのを好むユーザは <emphasis role=\"pkg\">netenv</emphasis> プログラムを好むかもしれません。このプログラムは同名のパッケージに含まれます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Setting the Hostname and Configuring the Name Service"
msgstr "ホスト名と名前解決サービスの設定"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>name</primary><secondary>attribution and resolution</secondary>"
msgstr "<primary>名前</primary><secondary>特定と解決</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>assignment of names</primary>"
msgstr "<primary>名前割り当て</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The purpose of assigning names to IP numbers is to make them easier for people to remember. In reality, an IP address identifies a network interface associated with a device such as a network card. Since each machine can have several network cards, and several interfaces on each card, one single computer can have several names in the domain name system."
msgstr "IP 番号に名前を割り当てることで、マシンを識別する情報は覚えやすくなります。実際には、IP アドレスはネットワークカードなどのデバイスと関連付けられたネットワークインターフェースを識別するものです。それぞれのマシンは複数のネットワークカードを持つことが可能ですし、それぞれのカードに複数のインターフェースを持つことが可能ですので、1 台のコンピュータはドメインネームシステムに複数の名前を持つことが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Each machine is, however, identified by a main (or “canonical”) name, stored in the <filename>/etc/hostname</filename> file and communicated to the Linux kernel by initialization scripts through the <command>hostname</command> command. The current value is available in a virtual filesystem, and you can get it with the <command>cat /proc/sys/kernel/hostname</command> command."
msgstr "しかしながら、それぞれのマシンは本名 (または「canonical」名) で識別されます。この名前は <filename>/etc/hostname</filename> ファイルに保存され、<command>hostname</command> コマンドを通じた初期化スクリプトを使って Linux カーネルに伝えられます。マシン名の現在の値は仮想ファイルシステムの中に保存されており、<command>cat /proc/sys/kernel/hostname</command> コマンドで値を確認できます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>hostname</command></primary>"
msgstr "<primary><command>hostname</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> <filename>/proc/</filename> and <filename>/sys/</filename>, virtual filesystems"
msgstr "<emphasis>BACK TO BASICS</emphasis> <filename>/proc/</filename> と <filename>/sys/</filename>、仮想ファイルシステム"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><filename>/proc/</filename></primary>"
msgstr "<primary><filename>/proc/</filename></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><filename>proc</filename></primary>"
msgstr "<primary><filename>proc</filename></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><filename>/sys/</filename></primary>"
msgstr "<primary><filename>/sys/</filename></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><filename>sys</filename></primary>"
msgstr "<primary><filename>sys</filename></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <filename>/proc/</filename> and <filename>/sys/</filename> file trees are generated by “virtual” filesystems. This is a practical means of recovering information from the kernel (by listing virtual files) and communicating them to it (by writing to virtual files)."
msgstr "<filename>/proc/</filename> と <filename>/sys/</filename> ファイルツリーは「仮想」ファイルシステムによって生成されます。仮想ファイルシステムは (仮想ファイルの内容を表示することで) カーネルから情報を回収したり、(仮想ファイルに書き込むことで) カーネルと情報をやり取りするための実用的な手段です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<filename>/sys/</filename> in particular is designed to provide access to internal kernel objects, especially those representing the various devices in the system. The kernel can, thus, share various pieces of information: the status of each device (for example, if it is in energy saving mode), whether it is a removable device, etc. Note that <filename>/sys/</filename> has only existed since kernel version 2.6."
msgstr "具体的に言うと <filename>/sys/</filename> はシステム内のさまざまなデバイスを表現する内部カーネルオブジェクトにアクセスする方法を提供するために設計されました。そんなわけで、カーネルはこの情報の塊を共有します。ここで情報の塊とは、それぞれのデバイスの状態 (たとえば、省エネルギーモードか否か) やリムーバブルデバイスがあるかなどを指します。<filename>/sys/</filename> を使えるのはカーネルバージョン 2.6 以降である点に注意してください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Surprisingly, the domain name is not managed in the same way, but comes from the complete name of the machine, acquired through name resolution. You can change it in the <filename>/etc/hosts</filename> file; simply write a complete name for the machine there at the beginning of the list of names associated with the address of the machine, as in the following example:"
msgstr "意外にもドメイン名は別の方法で管理されています。ドメイン名は名前解決を通じて得られるマシンの完全な名前で管理されています。マシンの完全な名前を変更するには <filename>/etc/hosts</filename> ファイルを使います。さらに以下の例に示す通り、マシンの完全な名前を <filename>/etc/hosts</filename> ファイルに書き込みます。マシン名のリストの最初に、そのマシンのアドレスに関連付けられた完全な名前を書きます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"127.0.0.1     localhost\n"
"192.168.0.1   arrakis.falcot.com arrakis"
msgstr ""
"\n"
"127.0.0.1     localhost\n"
"192.168.0.1   arrakis.falcot.com arrakis"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><filename>hosts</filename></primary>"
msgstr "<primary><filename>hosts</filename></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><filename>/etc/hosts</filename></primary>"
msgstr "<primary><filename>/etc/hosts</filename></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>domain</primary><secondary>name</secondary>"
msgstr "<primary>ドメイン</primary><secondary>名</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>name</primary><secondary>domain</secondary>"
msgstr "<primary>名</primary><secondary>ドメイン名</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>NSS</primary>"
msgstr "<primary>NSS</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Name Resolution"
msgstr "名前解決"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>resolution</primary><secondary>name</secondary>"
msgstr "<primary>解決</primary><secondary>名前解決</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>name</primary><secondary>resolution</secondary>"
msgstr "<primary>名前</primary><secondary>解決</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The mechanism for name resolution in Linux is modular and can use various sources of information declared in the <filename>/etc/nsswitch.conf</filename> file. The entry that involves host name resolution is <literal>hosts</literal>. By default, it contains <literal>files dns</literal>, which means that the system consults the <filename>/etc/hosts</filename> file first, then DNS servers. NIS/NIS+ or LDAP servers are other possible sources."
msgstr "Linux における名前解決のメカニズムはモジュール式であり <filename>/etc/nsswitch.conf</filename> ファイルに宣言されたさまざまな情報源を取り扱うことが可能です。ホスト名解決に関連するエントリは <literal>hosts</literal> です。デフォルトでこのエントリには <literal>files dns</literal> が含まれています。これは名前解決の際にシステムは最初に <filename>/etc/hosts</filename> ファイルを、次に DNS サーバを参照することを意味しています。NIS/NIS+ や LDAP サーバも情報源として使うことが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>NOTE</emphasis> NSS and DNS"
msgstr "<emphasis>NOTE</emphasis> NSS と DNS"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Be aware that the commands specifically intended to query DNS (especially <command>host</command>) do not use the standard name resolution mechanism (NSS). As a consequence, they do not take into consideration <filename>/etc/nsswitch.conf</filename>, and thus, not <filename>/etc/hosts</filename> either."
msgstr "DNS 問い合わせ専用のコマンド (特に <command>host</command>) は標準的な名前解決メカニズム (NSS) を使わないということに注意してください。結果として、そのようなコマンドは <filename>/etc/nsswitch.conf</filename> を考慮しませんし、<filename>/etc/hosts</filename> も考慮しません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Configuring DNS Servers"
msgstr "DNS サーバの設定"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>DNS</primary>"
msgstr "<primary>DNS</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Domain Name Service</primary>"
msgstr "<primary>ドメインネームサービス</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "DNS (Domain Name Service) is a distributed and hierarchical service mapping names to IP addresses, and vice-versa. Specifically, it can turn a human-friendly name such as <literal>www.eyrolles.com</literal> into the actual IP address, <literal>213.244.11.247</literal>."
msgstr "DNS (ドメインネームサービス) は IP アドレスと名前を双方向に対応付ける分散型の階層的サービスです。具体的に言うと、このサービスは人間に都合の良い名前、たとえば <literal>www.eyrolles.com</literal> を実際の IP アドレス <literal>213.244.11.247</literal> に変換します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "To access DNS information, a DNS server must be available to relay requests. Falcot Corp has its own, but an individual user is more likely to use the DNS servers provided by their ISP."
msgstr "DNS 情報にアクセスするには、DNS サーバが要求を中継するよう設定されていなければいけません。Falcot Corp は自分の DNS サーバを持っていますが、各ユーザは自分の ISP から提供された DNS サーバを使う傾向にあります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><filename>resolv.conf</filename></primary>"
msgstr "<primary><filename>resolv.conf</filename></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><literal>nameserver</literal></primary>"
msgstr "<primary><literal>nameserver</literal></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The DNS servers to be used are indicated in the <filename>/etc/resolv.conf</filename>, one per line, with the <literal>nameserver</literal> keyword preceding an IP address, as in the following example:"
msgstr "以下の例のように、使われる DNS サーバは <filename>/etc/resolv.conf</filename> に書かれています。1 行につき 1 台の DNS サーバを書き、DNS サーバの IP アドレスの前に <literal>nameserver</literal> キーワードを書きます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"nameserver 212.27.32.176\n"
"nameserver 212.27.32.177\n"
"nameserver 8.8.8.8"
msgstr ""
"\n"
"nameserver 212.27.32.176\n"
"nameserver 212.27.32.177\n"
"nameserver 8.8.8.8"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Note that the <filename>/etc/resolv.conf</filename> file may be handled automatically (and overwritten) when the network is managed by NetworkManager or configured via DHCP."
msgstr "NetworkManager がネットワークを管理していたり DHCP でネットワークを設定する場合、<filename>/etc/resolv.conf</filename> ファイルは自動的に取り扱われる (そして上書きされる) ことがある点に注意してください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <filename>/etc/hosts</filename> file"
msgstr "<filename>/etc/hosts</filename> ファイル"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "If there is no name server on the local network, it is still possible to establish a small table mapping IP addresses and machine hostnames in the <filename>/etc/hosts</filename> file, usually reserved for local network stations. The syntax of this file is very simple: each line indicates a specific IP address followed by the list of any associated names (the first being “completely qualified”, meaning it includes the domain name)."
msgstr "ローカルネットワーク内にネームサーバがない場合、<filename>/etc/hosts</filename> ファイルの中にローカルネットワークの機器向けに通常予約されている IP アドレスとマシンのホスト名の対応表を書くことで名前解決させることが可能です。<filename>/etc/hosts</filename> ファイルの構文はとても単純です。すなわち、各行は特定の IP アドレスとそれに関連する名前のリスト (リストの先頭に書く名前は「完全修飾名」でドメイン名を含みます) を表します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "This file is available even during network outages or when DNS servers are unreachable, but will only really be useful when duplicated on all the machines on the network. The slightest alteration in correspondence will require the file to be updated everywhere. This is why <filename>/etc/hosts</filename> generally only contains the most important entries."
msgstr "<filename>/etc/hosts</filename> ファイルはネットワークが停止している場合や DNS サーバに到達できない場合にも利用できますが、ネットワーク上のすべてのマシンに <filename>/etc/hosts</filename> ファイルのコピーを配置できる場合を除けば役に立ちません。つまり、このファイルをほんの少しでも変更すれば、すべてのマシンでファイルの内容を更新しなければいけません。このため、通常 <filename>/etc/hosts</filename> には最重要のエントリだけが含まれています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "This file will be sufficient for a small network not connected to the Internet, but with 5 machines or more, it is recommended to install a proper DNS server."
msgstr "<filename>/etc/hosts</filename> ファイルによる名前管理は、インターネットに接続されていない小さなネットワークでは十分ですが、5 台以上のマシンで構成されるネットワークでは、適切な DNS サーバをインストールすることを推奨します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>TIP</emphasis> Bypassing DNS"
msgstr "<emphasis>TIP</emphasis> DNS の迂回"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Since applications check the <filename>/etc/hosts</filename> file before querying DNS, it is possible to include information in there that is different from what the DNS would return, and therefore to bypass normal DNS-based name resolution."
msgstr "アプリケーションは DNS 問い合わせの前に <filename>/etc/hosts</filename> ファイルを確認しますので、通常の DNS 問い合わせで返される結果とは違う情報をこのファイルに書いておくことで、通常の DNS に基づいた名前解決を迂回することが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "This allows, in the event of DNS changes not yet propagated, to test access to a website with the intended name even if this name is not properly mapped to the correct IP address yet."
msgstr "つまり DNS の変更がまだ伝搬されておらず、まだ名前が正しい IP アドレスに適切に対応付けられていない場合でも、その名前で運用される予定のウェブサイトへのアクセスをテストすることが可能になります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Another possible use is to redirect traffic intended for a specific host to the localhost, thus preventing any communication with the given host. For example, hostnames of servers dedicated to serving ads could be diverted which would bypass these ads resulting in more fluid, less distracting, navigation."
msgstr "<filename>/etc/hosts</filename> ファイルのもう 1 つの使われ方としては、特定のホストに向けられたトラフィックをローカルホストにリダイレクトすることです。これで特定のホストとの通信を避けることができます。たとえば、広告を提供する専用サーバのホスト名をリダイレクトすれば広告を迂回することが可能です。こうすることでトラフィックが改善され、気をそらされることなくウェブサイトを巡回することが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "User and Group Databases"
msgstr "ユーザとグループのデータベース"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>user</primary><secondary>database</secondary>"
msgstr "<primary>ユーザ</primary><secondary>データベース</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>group</primary><secondary>database</secondary>"
msgstr "<primary>グループ</primary><secondary>データベース</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>database</primary><secondary>of users</secondary>"
msgstr "<primary>データベース</primary><secondary>ユーザのデータベース</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>database</primary><secondary>of groups</secondary>"
msgstr "<primary>データベース</primary><secondary>グループのデータベース</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The list of users is usually stored in the <filename>/etc/passwd</filename> file, while the <filename>/etc/shadow</filename> file stores encrypted passwords. Both are text files, in a relatively simple format, which can be read and modified with a text editor. Each user is listed there on a line with several fields separated with a colon (“<literal>:</literal>”)."
msgstr "ユーザのリストは通常 <filename>/etc/passwd</filename> ファイルに保存されており、<filename>/etc/shadow</filename> ファイルには暗号化されたパスワードが保存されています。どちらのファイルもテキストファイルで、比較的単純なフォーマットで書かれており、テキストエディタを使って読んだり変更することが可能です。各ユーザはこれらのファイルにリストされ、各行はコロン (「<literal>:</literal>」) で区切られたいくつかのフィールドを含んでいます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>NOTE</emphasis> Editing system files"
msgstr "<emphasis>NOTE</emphasis> システムファイルの編集"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The system files mentioned in this chapter are all plain text files, and can be edited with a text editor. Considering their importance to core system functionality, it is always a good idea to take extra precautions when editing system files. First, always make a copy or backup of a system file before opening or altering it. Second, on servers or machines where more than one person could potentially access the same file at the same time, take extra steps to guard against file corruption."
msgstr "この章で述べるシステムファイルはすべてプレーンテキストファイルで、テキストエディタを使って編集することが可能です。システムファイルが中核システムの機能性に対して重要な役割を担っている点を考慮すると、システムファイルを編集する際に特別な注意を払うことはどんな場合でも良い考えです。最初に、システムファイルを開くか変更する前には必ず、そのコピーかバックアップを作ってください。2 番目に、潜在的に 1 人以上が同じファイルに同時にアクセスする可能性のあるサーバおよびマシンでは、ファイルの破壊を防ぐために特別な手順を踏んでください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "For this purpose, it is enough to use the <command>vipw</command> command to edit the <filename>/etc/passwd</filename> file, or <command>vigr</command> to edit <filename>/etc/group</filename>. These commands lock the file in question prior to running the text editor, (<command>vi</command> by default, unless the <varname>EDITOR</varname> environment variable has been altered). The <literal>-s</literal> option in these commands allows editing the corresponding <foreignphrase>shadow</foreignphrase> file."
msgstr "この目的を達成するには、<filename>/etc/passwd</filename> ファイルを編集する際に <command>vipw</command> コマンドを使ったり <filename>/etc/group</filename> ファイルを編集する際に <command>vigr</command> コマンドを使ったりするだけで十分です。これらのコマンドはテキストエディタ (デフォルトで <command>vi</command>。エディタを設定するには <varname>EDITOR</varname> 環境変数を使います) を実行する前に対象のファイルをロックします。これらのコマンドに <literal>-s</literal> オプションを付けることで、対応する <foreignphrase>shadow</foreignphrase> ファイルを編集することも可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> Crypt, a one-way function"
msgstr "<emphasis>BACK TO BASICS</emphasis> crypt、一方向性関数"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>crypt</primary>"
msgstr "<primary>crypt</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: $ man 3 crypt;
msgid "<command>crypt</command> is a one-way function that transforms a string (<varname>A</varname>) into another string (<varname>B</varname>) in a way that <varname>A</varname> cannot be derived from <varname>B</varname>. The only way to identify <varname>A</varname> is to test all possible values, checking each one to determine if transformation by the function will produce <varname>B</varname> or not. It uses up to 8 characters as input (string <varname>A</varname>) and generates a string of 13, printable, ASCII characters (string <varname>B</varname>)."
msgstr "<command>crypt</command> は一方向性関数で、ある文字列 (<varname>A</varname>) を別の文字列 (<varname>B</varname>) に変換します。変換の際には <varname>B</varname> から <varname>A</varname> を得ることが不可能な方法を使います。<varname>A</varname> を得るにはすべての可能性をテストするしかありません。テストは各可能性を <command>crypt</command> で変換して得られた結果が <varname>B</varname> か否かで判断されます。<command>crypt</command> は入力 (文字列 <varname>A</varname>) として 8 文字目までを受け付け、13 文字の表示できる ASCII 文字 (文字列 <varname>B</varname>) を生成します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "User List: <filename>/etc/passwd</filename>"
msgstr "ユーザリスト、<filename>/etc/passwd</filename>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Here is the list of fields in the <filename>/etc/passwd</filename> file:"
msgstr "以下は <filename>/etc/passwd</filename> ファイルに含まれるフィールドのリストです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>passwd</command></primary>"
msgstr "<primary><command>passwd</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><filename>/etc/passwd</filename></primary>"
msgstr "<primary><filename>/etc/passwd</filename></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><literal>uid</literal></primary>"
msgstr "<primary><literal>uid</literal></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><literal>gid</literal></primary>"
msgstr "<primary><literal>gid</literal></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><literal>GECOS</literal></primary>"
msgstr "<primary><literal>GECOS</literal></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><literal>login</literal></primary>"
msgstr "<primary><literal>login</literal></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "login, for example <literal>rhertzog</literal>;"
msgstr "ログイン名。これはたとえば <literal>rhertzog</literal> です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "password: this is a password encrypted by a one-way function (<command>crypt</command>), relying on <literal>DES</literal>, <literal>MD5</literal>, <literal>SHA-256</literal> or <literal>SHA-512</literal>. The special value “<literal>x</literal>” indicates that the encrypted password is stored in <filename>/etc/shadow</filename>;"
msgstr "パスワード、これは一方向性関数 (<command>crypt</command>) によって暗号化されたパスワードです。使われる暗号化アルゴリズムは <literal>DES</literal>、<literal>MD5</literal>、<literal>SHA-256</literal>、<literal>SHA-512</literal> などです。このフィールドの値が特別な値「<literal>x</literal>」だった場合、これは暗号化されたパスワードが <filename>/etc/shadow</filename> に保存されていることを意味しています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>uid</literal>: unique number identifying each user;"
msgstr "<literal>uid</literal>。これは各ユーザを識別する一意的な番号です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>gid</literal>: unique number for the user's main group (Debian creates a specific group for each user by default);"
msgstr "<literal>gid</literal>。これはユーザのメイングループを示す一意的な番号です (Debian はデフォルトで各ユーザに固有のグループを作成します)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>GECOS</literal>: data field usually containing the user's full name;"
msgstr "<literal>GECOS</literal>。通常これはユーザの氏名を含むデータフィールドです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "login directory, assigned to the user for storage of their personal files (the environment variable <varname>$HOME</varname> generally points here);"
msgstr "ログインディレクトリ。これはユーザが個人ファイルを保存するために割り当てられたディレクトリです (環境変数 <varname>$HOME</varname> は通常このディレクトリを指します)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "program to execute upon login. This is usually a command interpreter (shell), giving the user free rein. If you specify <command>/bin/false</command> (which does nothing and returns control immediately), the user cannot login."
msgstr "ログイン時に実行されるプログラム。通常これはユーザに行動の自由を与えるコマンドインタプリタ (シェル) です。<command>/bin/false</command> (何もせずすぐにコントロールを返すプログラム) が指定された場合、ユーザはログインできません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> Unix group"
msgstr "<emphasis>BACK TO BASICS</emphasis> Unix グループ"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>group</primary>"
msgstr "<primary>グループ</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "A Unix group is an entity including several users so that they can easily share files using the integrated permission system (by benefiting from the same rights). You can also restrict use of certain programs to a specific group."
msgstr "Unix グループには複数のユーザが所属します。ユーザは統合されたパーミッションシステムを使って簡単にファイルを共有できます (あるグループに所属するユーザはそのグループに与えられた権限を執行できます)。また、あるプログラムの使用を特定のグループに制限することも可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The Hidden and Encrypted Password File: <filename>/etc/shadow</filename>"
msgstr "隠された暗号化パスワードファイル、<filename>/etc/shadow</filename>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><filename>shadow</filename></primary>"
msgstr "<primary><filename>shadow</filename></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><filename>/etc/shadow</filename></primary>"
msgstr "<primary><filename>/etc/shadow</filename></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <filename>/etc/shadow</filename> file contains the following fields:"
msgstr "<filename>/etc/shadow</filename> ファイルには以下のフィールドが含まれます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "login;"
msgstr "ログイン名。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "encrypted password;"
msgstr "暗号化されたパスワード。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "several fields managing password expiration."
msgstr "パスワードの有効期限を管理するいくつかのフィールド。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>DOCUMENTATION</emphasis> <filename>/etc/passwd</filename>, <filename>/etc/shadow</filename> and <filename>/etc/group</filename> file formats"
msgstr "<emphasis>DOCUMENTATION</emphasis> <filename>/etc/passwd</filename>、<filename>/etc/shadow</filename>、<filename>/etc/group</filename> ファイルのフォーマット"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "These formats are documented in the following man pages: <citerefentry><refentrytitle>passwd</refentrytitle><manvolnum>5</manvolnum></citerefentry>, <citerefentry><refentrytitle>shadow</refentrytitle><manvolnum>5</manvolnum></citerefentry>, and <citerefentry><refentrytitle>group</refentrytitle><manvolnum>5</manvolnum></citerefentry>."
msgstr "これらのファイルのフォーマットの説明は以下の man ページに書かれています。すなわち <citerefentry><refentrytitle>passwd</refentrytitle><manvolnum>5</manvolnum></citerefentry>、<citerefentry><refentrytitle>shadow</refentrytitle><manvolnum>5</manvolnum></citerefentry>、<citerefentry><refentrytitle>group</refentrytitle><manvolnum>5</manvolnum></citerefentry> に書かれています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>SECURITY</emphasis> <filename>/etc/shadow</filename> file security"
msgstr "<emphasis>SECURITY</emphasis> <filename>/etc/shadow</filename> ファイルのセキュリティ"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<filename>/etc/shadow</filename>, unlike its alter-ego, <filename>/etc/passwd</filename>, cannot be read by regular users. Any encrypted password stored in <filename>/etc/passwd</filename> is readable by anybody; a cracker could try to “break” (or reveal) a password by one of several “brute force” methods which, simply put, guess at commonly used combinations of characters. This attack — called a \"dictionary attack\" — is no longer possible on systems using <filename>/etc/shadow</filename>."
msgstr "一般ユーザが <filename>/etc/shadow</filename> を読むことは不可能ですが、その分身である <filename>/etc/passwd</filename> を読むことは可能です。すなわち <filename>/etc/passwd</filename> に保存されている暗号化パスワードは誰でも読むことが可能です。さらにクラッカーは、いくつかの「総当り」法の 1 つを使って、簡単に言えばよく使われる文字の組み合わせを推測することで、パスワードを「破壊」(または明らかに) しようと試みることが可能です。<filename>/etc/shadow</filename> を使っているシステムではもはや、「辞書攻撃」と呼ばれるこの種の攻撃方法は不可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Modifying an Existing Account or Password"
msgstr "既存のアカウントやパスワードの変更"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>chsh</command></primary>"
msgstr "<primary><command>chsh</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>chfn</command></primary>"
msgstr "<primary><command>chfn</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>chage</command></primary>"
msgstr "<primary><command>chage</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>password</primary>"
msgstr "<primary>パスワード</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The following commands allow modification of the information stored in specific fields of the user databases: <command>passwd</command> permits a regular user to change their password, which in turn, updates the <filename>/etc/shadow</filename> file; <command>chfn</command> (CHange Full Name), reserved for the super-user (root), modifies the <literal>GECOS</literal> field. <command>chsh</command> (CHange SHell) allows the user to change their login shell, however available choices will be limited to those listed in <filename>/etc/shells</filename>; the administrator, on the other hand, is not bound by this restriction and can set the shell to any program of their choosing."
msgstr "以下のコマンドはユーザデータベースの特定のフィールドに保存されている情報を変更します。すなわち <command>passwd</command> を使うと、一般ユーザは自分のパスワードを変更できます。つまり <filename>/etc/shadow</filename> ファイルが更新されます。さらに <command>chfn</command> (CHange Full Name) を使うと <literal>GECOS</literal> フィールドが変更されます。このコマンドはスーパーユーザ (root) 専用です。<command>chsh</command> (CHange SHell) を使うと、一般ユーザはログインシェルを変更できます。しかしながら、ここで設定できるのは <filename>/etc/shells</filename> に書かれたシェルだけです。その一方で、管理者はこの制限に縛られず、シェルにどんなプログラムを設定することも可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Finally, the <command>chage</command> (CHange AGE) command allows the administrator to change the password expiration settings (the <literal>-l <replaceable>user</replaceable></literal> option will list the current settings). You can also force the expiration of a password using the <command>passwd -e <replaceable>user</replaceable></command> command, which will require the user to change their password the next time they log in."
msgstr "最後に、<command>chage</command> (CHange AGE) コマンドを使うと、管理者はパスワードの有効期限設定を変更できます (<literal>-l <replaceable>user</replaceable></literal> オプションで現在の設定を表示します)。<command>passwd -e <replaceable>user</replaceable></command> コマンドを使うと、パスワードを強制的に失効させることが可能です。ユーザは次回のログイン時にパスワード変更を要求されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Disabling an Account"
msgstr "アカウントの失効"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Disable an account</primary>"
msgstr "<primary>アカウントの失効</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>account</primary><secondary>disable</secondary>"
msgstr "<primary>アカウント</primary><secondary>失効</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "You may find yourself needing to “disable an account” (lock out a user), as a disciplinary measure, for the purposes of an investigation, or simply in the event of a prolonged or definitive absence of a user. A disabled account means the user cannot login or gain access to the machine. The account remains intact on the machine and no files or data are deleted; it is simply inaccessible. This is accomplished by using the command <command>passwd -l <replaceable>user</replaceable></command> (lock). Re-enabling the account is done in similar fashion, with the <literal>-u</literal> option (unlock)."
msgstr "「アカウントを失効」する (ユーザを締め出す) 必要が出てくるかもしれません。これが必要になるのは、ユーザの懲戒処分、調査目的、単純に長期にわたって明らかにログインしていない場合などが考えられます。失効されたアカウントとは、ユーザがログインできないかマシンへのアクセスを獲得できないことを意味しています。アカウントは単にアクセスできない状態になっているだけで、アカウントがマシンから削除されるわけでもなければファイルおよびデータが削除されるわけでもありません。アカウントを失効するには <command>passwd -l <replaceable>user</replaceable></command> (lock) を使ってください。もう一度アカウントを有効化するには同様の方法で <literal>-u</literal> オプション (unlock) を付けてください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>GOING FURTHER</emphasis> NSS and system databases"
msgstr "<emphasis>GOING FURTHER</emphasis> NSS とシステムデータベース"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Name Service Switch</primary>"
msgstr "<primary>Name Service Switch</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Instead of using the usual files to manage lists of users and groups, you could use other types of databases, such as LDAP or <command>db</command>, by using an appropriate NSS (Name Service Switch) module. The modules used are listed in the <filename>/etc/nsswitch.conf</filename> file, under the <literal>passwd</literal>, <literal>shadow</literal> and <literal>group</literal> entries. See <xref linkend=\"sect.config-nss\" /> for a specific example of the use of an NSS module by LDAP."
msgstr "ユーザやグループのリストを管理する際に適切な NSS (Name Service Switch) モジュールを使えば、通常のファイルを使う代わりに LDAP や <command>db</command> などの他の種類のデータベースを使うことも可能です。<filename>/etc/nsswitch.conf</filename> ファイルの <literal>passwd</literal>、<literal>shadow</literal>、<literal>group</literal> エントリにはデータベースとして使われるモジュールがリストされています。LDAP で NSS モジュールを使う方法の具体例は<xref linkend=\"sect.config-nss\" />をご覧ください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Group List: <filename>/etc/group</filename>"
msgstr "グループリスト、<filename>/etc/group</filename>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Groups are listed in the <filename>/etc/group</filename> file, a simple textual database in a format similar to that of the <filename>/etc/passwd</filename> file, with the following fields:"
msgstr "グループは <filename>/etc/group</filename> ファイルにリストされています。<filename>/etc/group</filename> ファイルは単純なテキストデータベースで、フォーマットは <filename>/etc/passwd</filename> ファイルとよく似ており、以下のフィールドを持っています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "group name;"
msgstr "グループ名。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: $ man 5 gshadow;
msgid "password (optional): This is only used to join a group when one is not a usual member (with the <command>newgrp</command> or <command>sg</command> commands, see sidebar <xref linkend=\"sidebar.working-with-several-groups\" />);"
msgstr "パスワード (任意)。これはグループメンバーでないユーザがそのグループに参加する際に使われます (<command>newgrp</command> および <command>sg</command> コマンドを使います。補注<xref linkend=\"sidebar.working-with-several-groups\" />を参照してください)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>gid</literal>: unique group identification number;"
msgstr "<literal>gid</literal>。これはグループを識別する一意的な番号です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "list of members: list of names of users who are members of the group, separated by commas."
msgstr "メンバーのリスト。これはグループに所属するユーザ名のコンマ区切りリストです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> Working with several groups"
msgstr "<emphasis>BACK TO BASICS</emphasis> 複数のグループに所属する"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>newgrp</command></primary>"
msgstr "<primary><command>newgrp</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>sg</command></primary>"
msgstr "<primary><command>sg</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>id</command></primary>"
msgstr "<primary><command>id</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>group</primary><secondary>change</secondary>"
msgstr "<primary>グループ</primary><secondary>変更</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Each user may be a member of many groups; one of them is their “main group”. A user's main group is, by default, created during initial user configuration. By default, each file that a user creates belongs to them, as well as to their main group. This is not always desirable; for example, when the user needs to work in a directory shared by a group other than their main group. In this case, the user needs to change their main group using one of the following commands: <command>newgrp</command>, which starts a new shell, or <command>sg</command>, which simply executes a command using the supplied alternate group. These commands also allow the user to join a group to which they do not belong. If the group is password protected, they will need to supply the appropriate password before the command is executed."
msgstr "ユーザは複数のグループに所属することが可能です。そして所属グループの 1 つが「メイングループ」です。ユーザのメイングループはデフォルトで最初のユーザ設定中に作成されます。デフォルトで、ユーザが作成したファイルは本人とそのメイングループの所有物になります。この状態が望ましくない場合もあります。たとえば、ユーザが自分のメイングループではないグループ用に共有されたディレクトリ内で仕事をする必要がある場合を考えてみましょう。この場合、ユーザは以下のコマンドのどちらかを使ってメイングループを変更する必要があります。具体的に言えば、新しいシェルを開始する <command>newgrp</command> か、与えられた別グループでコマンドを実行する <command>sg</command> を使う必要があります。これらのコマンドを使うと、ユーザは自分が所属していないグループに参加することが可能です。グループがパスワードで保護されていた場合、ユーザはコマンドを実行する前に適切なパスワードを入力する必要があります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Alternatively, the user can set the <literal>setgid</literal> bit on the directory, which causes files created in that directory to automatically belong to the correct group. For more details, see sidebar <xref linkend=\"sidebar.setgid-dir\" />."
msgstr "別の方法として、ディレクトリに <literal>setgid</literal> ビットを設定することが可能です。こうすることで、そのディレクトリの下に作成されたファイルのグループを自動的に適切なものにすることが可能です。詳細は補注<xref linkend=\"sidebar.setgid-dir\" />をご覧ください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <command>id</command> command displays the current state of a user, with their personal identifier (<varname>uid</varname> variable), current main group (<varname>gid</varname> variable), and the list of groups to which they belong (<varname>groups</varname> variable)."
msgstr "<command>id</command> コマンドはユーザのユーザ名 (<varname>uid</varname> 変数)、現在のメイングループ (<varname>gid</varname> 変数)、所属するグループのリスト (<varname>groups</varname> 変数) を表示します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><filename>group</filename></primary>"
msgstr "<primary><filename>group</filename></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><filename>/etc/group</filename></primary>"
msgstr "<primary><filename>/etc/group</filename></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <command>addgroup</command> and <command>delgroup</command> commands add or delete a group, respectively. The <command>groupmod</command> command modifies a group's information (its <literal>gid</literal> or identifier). The command <command>passwd -g <replaceable>group</replaceable></command> changes the password for the group, while the <command>passwd -r -g <replaceable>group</replaceable></command> command deletes it."
msgstr "<command>addgroup</command> コマンドはグループを追加、<command>delgroup</command> コマンドはグループを削除します。<command>groupmod</command> コマンドは指定したグループの情報 (<literal>gid</literal> またはグループ名など) を変更します。<command>passwd -g <replaceable>group</replaceable></command> は <replaceable>group</replaceable> で指定したグループのパスワードを変更し、一方で <command>passwd -r -g <replaceable>group</replaceable></command> コマンドは <replaceable>group</replaceable> で指定したグループを削除します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>addgroup</command></primary>"
msgstr "<primary><command>addgroup</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>delgroup</command></primary>"
msgstr "<primary><command>delgroup</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>groupmod</command></primary>"
msgstr "<primary><command>groupmod</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>group</primary><secondary>creation</secondary>"
msgstr "<primary>グループ</primary><secondary>作成</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>creation</primary><secondary>of groups</secondary>"
msgstr "<primary>作成</primary><secondary>グループの作成</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>group</primary><secondary>deletion</secondary>"
msgstr "<primary>グループ</primary><secondary>削除</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>deletion of a group</primary>"
msgstr "<primary>グループの削除</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>TIP</emphasis> <command>getent</command>"
msgstr "<emphasis>TIP</emphasis> <command>getent</command>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>getent</command></primary>"
msgstr "<primary><command>getent</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <command>getent</command> (get entries) command checks the system databases the standard way, using the appropriate library functions, which in turn call the NSS modules configured in the <filename>/etc/nsswitch.conf</filename> file. The command takes one or two arguments: the name of the database to check, and a possible search key. Thus, the command <command>getent passwd rhertzog</command> will give the information from the user database regarding the user <literal>rhertzog</literal>."
msgstr "<command>getent</command> (get entries) コマンドは、適当なライブラリ関数を使い <filename>/etc/nsswitch.conf</filename> ファイルで設定された NSS モジュールを呼び出すという標準的な方法で、システムデータベースを確認します。<command>getent</command> コマンドは 1 つか 2 つの引数を取ります。具体的に言えば、引数としてデータベースの名前と検索キーを取ります。そんなわけで、<command>getent passwd rhertzog</command> コマンドはユーザデータベースから <literal>rhertzog</literal> ユーザに関する情報を表示します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Creating Accounts"
msgstr "アカウントの作成"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>account</primary><secondary>creation</secondary>"
msgstr "<primary>アカウント</primary><secondary>作成</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>creation</primary><secondary>of user accounts</secondary>"
msgstr "<primary>作成</primary><secondary>ユーザアカウントの作成</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "One of the first actions an administrator needs to do when setting up a new machine is to create user accounts. This is typically done using the <command>adduser</command> command which takes a user-name for the new user to be created, as an argument."
msgstr "新しいマシンをセットアップする際に、管理者が最初にする作業の 1 つにユーザアカウントの作成作業があります。典型的に、ユーザアカウントの作成作業は <command>adduser</command> コマンドを使って行われます。このコマンドは作成する新しいユーザのユーザ名を引数に取ります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>adduser</command></primary>"
msgstr "<primary><command>adduser</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <command>adduser</command> command asks a few questions before creating the account, but its usage is fairly straightforward. Its configuration file, <filename>/etc/adduser.conf</filename>, includes all the interesting settings: it can be used to automatically set a quota for each new user by creating a user template, or to change the location of user accounts; the latter is rarely useful, but it comes in handy when you have a large number of users and want to divide their accounts over several disks, for instance. You can also choose a different default shell."
msgstr "<command>adduser</command> コマンドはアカウントを作成する前にいくつかの質問を尋ねますが、その使い方はかなり簡単です。<command>adduser</command> コマンドの設定ファイル <filename>/etc/adduser.conf</filename> には興味深い設定が含まれます。すなわち、この設定ファイルは、ユーザテンプレートを作成することで自動的に新しいユーザにクォータを課したり、ユーザアカウントの場所を変更するために使われます。ユーザアカウントの場所を変更することが役に立つ場面は少ないですが、たとえば多くのユーザを管理していて、各アカウントを複数のディスクに分散させたい場合には、役立ちます。また、デフォルトシェルを別のシェルに変えることも可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> Quota"
msgstr "<emphasis>BACK TO BASICS</emphasis> クォータ"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>quota</primary>"
msgstr "<primary>クォータ</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The term “quota” refers to a limit on machine resources that a user is allowed to use. This frequently refers to disk space."
msgstr "「クォータ」という用語はユーザが使えるマシンリソースの制限値を意味しています。マシンリソースとは通常ディスク領域を指します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The creation of an account populates the user's home directory with the contents of the <filename>/etc/skel/</filename> template. This provides the user with a set of standard directories and configuration files."
msgstr "アカウントが作成されると、<filename>/etc/skel/</filename> テンプレートの内容がユーザのホームディレクトリにコピーされます。<filename>/etc/skel/</filename> テンプレートには標準的なディレクトリと設定ファイルが含まれます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>group</primary><secondary>add a user</secondary>"
msgstr "<primary>グループ</primary><secondary>ユーザの追加</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>add a user to a group</primary>"
msgstr "<primary>グループにユーザを追加する</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "In some cases, it will be useful to add a user to a group (other than their default “main” group) in order to grant them additional permissions. For example, a user who is included in the <emphasis>audio</emphasis> group can access audio devices (see sidebar <xref linkend=\"sidebar.special-files\" />). This can be achieved with a command such as <command>adduser <replaceable>user</replaceable> <replaceable>group</replaceable></command>."
msgstr "あるユーザに追加のパーミッションを与える目的で、そのユーザを (デフォルトの「メイン」グループ以外の) あるグループに所属させると便利な場合があります。たとえば、<emphasis>audio</emphasis> グループに属するユーザは音声デバイスにアクセスできます (補注<xref linkend=\"sidebar.special-files\" />を参照してください)。これは <command>adduser <replaceable>user</replaceable> <replaceable>group</replaceable></command> コマンドで達成されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> Device access permissions"
msgstr "<emphasis>BACK TO BASICS</emphasis> デバイスアクセスパーミッション"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>device</primary><secondary>access permissions</secondary>"
msgstr "<primary>デバイス</primary><secondary>アクセスパーミッション</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>file</primary><secondary>special</secondary>"
msgstr "<primary>ファイル</primary><secondary>スペシャルファイル</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>mode</primary><secondary>character</secondary>"
msgstr "<primary>モード</primary><secondary>キャラクタモード</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>mode</primary><secondary>block</secondary>"
msgstr "<primary>モード</primary><secondary>ブロックモード</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>block, mode</primary>"
msgstr "<primary>ブロック、モード</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>character, mode</primary>"
msgstr "<primary>キャラクタ、モード</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>special, file</primary>"
msgstr "<primary>スペシャル、ファイル</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>mknod</command></primary>"
msgstr "<primary><command>mknod</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Each hardware peripheral device is represented under Unix with a special file, usually stored in the file tree under <filename>/dev/</filename> (DEVices). Two types of special files exist according to the nature of the device: “character mode” and “block mode” files, each mode allowing for only a limited number of operations. While character mode limits interaction with read/write operations, block mode also allows seeking within the available data. Finally, each special file is associated with two numbers (“major” and “minor”) that identify the device to the kernel in a unique manner. Such a file, created by the <command>mknod</command> command, simply contains a symbolic (and more human-friendly) name."
msgstr "Unix はハードウェア周辺機器デバイスをスペシャルファイルとして表します。スペシャルファイルは通常 <filename>/dev/</filename> (DEVices) ツリーの下に格納されます。デバイスの性質に依存して、2 種類のスペシャルファイルが存在します。具体的に言えば「キャラクタモード」と「ブロックモード」ファイルです、それぞれのモードでは行える操作が限定されています。キャラクタモードの場合、許可されている操作は読み/書きだけですが、ブロックモードの場合、読み/書き操作に加えて利用できるデータのシークも許可されています。最後に、それぞれのスペシャルファイルは (「メジャー」と「マイナー」の) 2 つの番号に関連付けられており、カーネルはこの番号を使って一意的な方法でデバイスを識別します。スペシャルファイルは <command>mknod</command> コマンドで作成され、シンボリック名 (人間にとって使いやすい名前) を付けられます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The permissions of a special file map to the permissions necessary to access the device itself. Thus, a file such as <filename>/dev/mixer</filename>, representing the audio mixer, only has read/write permissions for the root user and members of the <literal>audio</literal> group. Only these users can operate the audio mixer."
msgstr "スペシャルファイルのパーミッションは関連付けられたデバイスへのアクセスに必要なパーミッションを意味します。そのため、音声ミキサを表す <filename>/dev/mixer</filename> などのファイルには、root と <literal>audio</literal> グループに所属するユーザの読み/書きを許可するパーミッションが設定されています。音声ミキサを操作できるのは、これらのユーザだけです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "It should be noted that the combination of <emphasis role=\"pkg\">udev</emphasis>, <emphasis role=\"pkg\">consolekit</emphasis> and <emphasis role=\"pkg\">policykit</emphasis> can add additional permissions to allow users physically connected to the console (and not through the network) to access to certain devices."
msgstr "<emphasis role=\"pkg\">udev</emphasis>、<emphasis role=\"pkg\">consolekit</emphasis>、<emphasis role=\"pkg\">policykit</emphasis> を組み合わせて使うことで、コンソールに物理的に接続された (ネットワーク経由でない) ユーザに対して一部のデバイスへのアクセスを許可する追加的なパーミッションを設定できるという点に注意してください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Shell Environment"
msgstr "シェル環境"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Command interpreters (or shells) can be a user's first point of contact with the computer, and they must therefore be rather friendly. Most of them use initialization scripts that allow configuration of their behavior (automatic completion, prompt text, etc.)."
msgstr "コマンドインタプリタ (シェル) はコンピュータのユーザが最初に触れるものですから、かなり使いやすくなければいけません。ほとんどのシェルは、挙動 (自動補完、プロンプトテキストなど) を設定する初期化スクリプトを使います。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>command line interface</primary>"
msgstr "<primary>コマンドラインインターフェース</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>command interpreter</primary>"
msgstr "<primary>コマンドインタプリタ</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>shell</primary>"
msgstr "<primary>シェル</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>bash</command></primary>"
msgstr "<primary><command>bash</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<command>bash</command>, the standard shell, uses the <filename>/etc/bash.bashrc</filename> initialization script for “interactive” shells, and <filename>/etc/profile</filename> for “login” shells."
msgstr "標準的なシェルである <command>bash</command> は「対話型」シェル用に <filename>/etc/bash.bashrc</filename> 初期化スクリプトを使い、「ログイン」シェル用に <filename>/etc/profile</filename> を使います。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> Login shell and (non) interactive shell"
msgstr "<emphasis>BACK TO BASICS</emphasis> ログインシェルと (非) 対話型シェル"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "In simple terms, a login shell is invoked when you login to the console either locally or remotely via <command>ssh</command>, or when you run an explicit <command>bash --login</command> command. Regardless of whether it is a login shell or not, a shell can be interactive (in an <command>xterm</command>-type terminal for instance); or non-interactive (when executing a script)."
msgstr "簡単に言うと、ログインシェルはローカルおよびリモートの <command>ssh</command> 経由でコンソールにログインするか、明確に <command>bash --login</command> コマンドを実行してログインする際に実行されます。ログインシェルか否かに関わらず、シェルは対話的 (たとえば <command>xterm</command> 系ターミナルの中で実行される場合) にもなれば、一方で非対話的 (スクリプトとして実行される場合) にもなります。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: PTAL;
msgid "<emphasis>DISCOVERY</emphasis> Other shells, other scripts"
msgstr "<emphasis>DISCOVERY</emphasis> シェルを変えれば設定スクリプトも変わります"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Each command interpreter has a specific syntax and its own configuration files. Thus, <command>zsh</command> uses <filename>/etc/zshrc</filename> and <filename>/etc/zshenv</filename>; <command>csh</command> uses <filename>/etc/csh.cshrc</filename>, <filename>/etc/csh.login</filename> and <filename>/etc/csh.logout</filename>. The man pages for these programs document which files they use."
msgstr "各コマンドラインインタプリタには、特別な構文が決められており、専用の設定ファイルがあります。たとえば <command>zsh</command> は <filename>/etc/zshrc</filename> と <filename>/etc/zshenv</filename> を使います。一方で <command>csh</command> は <filename>/etc/csh.cshrc</filename>、<filename>/etc/csh.login</filename>、<filename>/etc/csh.logout</filename> を使います。それぞれのプログラムの man ページでは、そのプログラムがどの設定ファイルを使うかについて説明されています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>zsh</command></primary>"
msgstr "<primary><command>zsh</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>csh</command></primary>"
msgstr "<primary><command>csh</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: https://www.debian-administration.org/article/316/An_introduction_to_bash_completion_part_1;
msgid "For <command>bash</command>, it is useful to activate “automatic completion” in the <filename>/etc/bash.bashrc</filename> file (simply uncomment a few lines)."
msgstr "<command>bash</command> では、<filename>/etc/bash.bashrc</filename> ファイルを使って「自動補完」を有効化する (通常いくつかの行のコメントを外す) と便利です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> Automatic completion"
msgstr "<emphasis>BACK TO BASICS</emphasis> 自動補完"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>automatic completion</primary>"
msgstr "<primary>自動補完</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Many command interpreters provide a completion feature, which allows the shell to automatically complete a partially typed command name or argument when the user hits the <keycap>Tab</keycap> key. This lets users work more efficiently and be less error-prone."
msgstr "多くのコマンドラインインタプリタには補完機能があります。補完機能を使うと、コマンド名や引数の一部を入力した後に <keycap>Tab</keycap> キーを押すことで、残りの部分が自動的に入力されます。補完機能のおかげで、ユーザはより効率的に作業を行い、より間違いを起こしにくくなります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "This function is very powerful and flexible. It is possible to configure its behavior according to each command. Thus, the first argument following <command>apt-get</command> will be proposed according to the syntax of this command, even if it does not match any file (in this case, the possible choices are <literal>install</literal>, <literal>remove</literal>, <literal>upgrade</literal>, etc.)."
msgstr "補完機能はとても強力で柔軟です。補完機能の挙動をそれぞれのコマンドに対して設定することが可能です。従って、<command>apt-get</command> に続く 1 番目の引数は、それがどのファイル名にもマッチしなかったとしても、<command>apt-get</command> コマンドの構文に従って提案されます (この場合、<literal>install</literal>、<literal>remove</literal>、<literal>upgrade</literal> などが候補として挙げられます)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> The tilde, a shortcut to HOME"
msgstr "<emphasis>BACK TO BASICS</emphasis> チルダ記号、ホームディレクトリへのショートカット"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>~</primary>"
msgstr "<primary>~</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>tilde</primary>"
msgstr "<primary>チルダ記号</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The tilde is often used to indicate the directory to which the environment variable, <varname>HOME</varname>, points (being the user's home directory, such as <filename>/home/rhertzog/</filename>). Command interpreters automatically make the substitution: <filename>~/hello.txt</filename> becomes <filename>/home/rhertzog/hello.txt</filename>."
msgstr "チルダ記号は通常、環境変数 <varname>HOME</varname> の指すディレクトリ (ユーザのホームディレクトリ、<filename>/home/rhertzog/</filename> など) を表すために使われます。コマンドインタプリタはチルダ記号を自動的に置換します。すなわち <filename>~/hello.txt</filename> は <filename>/home/rhertzog/hello.txt</filename> のように置換されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The tilde also allows access to another user's home directory. Thus, <filename>~rmas/bonjour.txt</filename> is synonymous with <filename>/home/rmas/bonjour.txt</filename>."
msgstr "チルダ記号は他のユーザのホームディレクトリを表す場合にも使えます。従って、<filename>~rmas/bonjour.txt</filename> は <filename>/home/rmas/bonjour.txt</filename> と同じ意味になります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "In addition to these common scripts, each user can create their own <filename>~/.bashrc</filename> and <filename>~/.bash_profile</filename> to configure their shell. The most common changes are the addition of aliases; these are words that are automatically replaced with the execution of a command, which makes it faster to invoke that command. For instance, you could create the <literal>la</literal> alias for the command <command>ls -la | less</command> command; then you only have to type <command>la</command> to inspect the contents of a directory in detail."
msgstr "これらの共用スクリプトに加えて、各ユーザは自分のシェルを設定するために <filename>~/.bashrc</filename> と <filename>~/.bash_profile</filename> を作ることが可能です。最もよくある変更は、別名の追加です。別名とはコマンドの実行時に自動的に置換される単語で、別名を登録することでコマンドを素早く実行できます。たとえば、<command>ls -la | less</command> コマンドの別名として <literal>la</literal> を作成することが可能です。こうしておけば、ディレクトリの内容を細かく調査する場合に <command>la</command> を入力するだけで済みます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> Environment variables"
msgstr "<emphasis>BACK TO BASICS</emphasis> 環境変数"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>environment</primary><secondary>environment variable</secondary>"
msgstr "<primary>環境</primary><secondary>環境変数</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>variable, environment</primary>"
msgstr "<primary>変数、環境</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Environment variables allow storage of global settings for the shell or various other programs called. They are contextual (each process has its own set of environment variables) but inheritable. This last characteristic offers the possibility for a login shell to declare variables which will be passed down to all programs it executes."
msgstr "環境変数を使うことで、呼び出されたシェルや他のプログラムに対して大域的な設定を行うことが可能です。環境変数はその場限りのものです (それぞれのプロセスは自身の環境変数を持っています)。しかしながら、環境変数は継承されます。環境変数の継承という性質のおかげで、すべてのプログラムの実行時に伝えられる変数をログインシェルで宣言できます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Setting default environment variables is an important element of shell configuration. Leaving aside the variables specific to a shell, it is preferable to place them in the <filename>/etc/environment</filename> file, since it is used by the various programs likely to initiate a shell session. Variables typically defined there include <varname>ORGANIZATION</varname>, which usually contains the name of the company or organization, and <varname>HTTP_PROXY</varname>, which indicates the existence and location of an HTTP proxy."
msgstr "デフォルト環境変数の設定はシェルを設定する上で重要な要素です。あるシェルに固有の変数はさておき、デフォルト環境変数の設定は <filename>/etc/environment</filename> ファイルで行うことが好まれます。なぜなら、シェルセッションを起動するさまざまなプログラムが <filename>/etc/environment</filename> ファイルを使うからです。典型的に言って <filename>/etc/environment</filename> では会社や組織の名前を設定する <varname>ORGANIZATION</varname>、HTTP プロキシの存在とその場所を設定する <varname>HTTP_PROXY</varname> などの環境変数を設定します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>TIP</emphasis> All shells configured identically"
msgstr "<emphasis>TIP</emphasis> すべてのシェルを同様に設定する"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Users often want to configure their login and interactive shells in the same way. To do this, they choose to interpret (or “source”) the content from <filename>~/.bashrc</filename> in the <filename>~/.bash_profile</filename> file. It is possible to do the same with files common to all users (by calling <filename>/etc/bash.bashrc</filename> from <filename>/etc/profile</filename>)."
msgstr "多くの場合、ユーザはログインシェルと対話型シェルの設定を同じにしたいと思うでしょう。これを行うには、<filename>~/.bash_profile</filename> ファイルの中で <filename>~/.bashrc</filename> の内容を実行 (または「source」) します。すべてのユーザに共通のファイルで同じことをすることも可能です (<filename>/etc/profile</filename> の中で <filename>/etc/bash.bashrc</filename> を呼び出します)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Printer Configuration"
msgstr "プリンタ設定"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>configuration</primary><secondary>printing</secondary>"
msgstr "<primary>設定</primary><secondary>印刷</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>printing</primary><secondary>configuration</secondary>"
msgstr "<primary>印刷</primary><secondary>設定</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Printer configuration used to cause a great many headaches for administrators and users alike. These headaches are now mostly a thing of the past, thanks to <emphasis role=\"pkg\">cups</emphasis>, the free print server using the IPP protocol (Internet Printing Protocol)."
msgstr "以前、管理者およびユーザにとってプリンタ設定は大きな悩みの種でした。IPP プロトコル (Internet Printing Protocol) を使う自由な印刷サーバである <emphasis role=\"pkg\">cups</emphasis> のおかげで、これらの悩みの種は今やほとんど過去の物です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>IPP</primary>"
msgstr "<primary>IPP</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Internet Printing Protocol</primary>"
msgstr "<primary>Internet Printing Protocol</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>cups</command></primary>"
msgstr "<primary><command>cups</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "This program is divided over several Debian packages: <emphasis role=\"pkg\">cups</emphasis> is the central print server; <emphasis role=\"pkg\">cups-bsd</emphasis> is a compatibility layer allowing use of commands from the traditional BSD printing system (<command>lpd</command> daemon, <command>lpr</command> and <command>lpq</command> commands, etc.); <emphasis role=\"pkg\">cups-client</emphasis> contains a group of programs to interact with the server (block or unblock a printer, view or delete print jobs in progress, etc.); and finally, <emphasis role=\"pkg\">cups-driver-gutenprint</emphasis> contains a collection of additional printer drivers for <command>cups</command>."
msgstr "cups プログラムは複数の Debian パッケージに分割されています。たとえば <emphasis role=\"pkg\">cups</emphasis> は主要な印刷サーバです。そして <emphasis role=\"pkg\">cups-bsd</emphasis> は互換レイヤであり、古典的な BSD 印刷システム (<command>lpd</command> デーモン、<command>lpr</command>、<command>lpq</command> コマンドなど) からのコマンドを使えるようにします。そして <emphasis role=\"pkg\">cups-client</emphasis> にはサーバと通信する (プリンタをブロックしたりブロック解除する、進行中の印刷ジョブを表示したり削除する) ための一連のプログラムが含まれます。そして最後に、<emphasis role=\"pkg\">cups-driver-gutenprint</emphasis> には <command>cups</command> 用の追加的なプリンタドライバが含まれます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>lpr</command></primary>"
msgstr "<primary><command>lpr</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>lpd</command></primary>"
msgstr "<primary><command>lpd</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>lpq</command></primary>"
msgstr "<primary><command>lpq</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>COMMUNITY</emphasis> CUPS"
msgstr "<emphasis>COMMUNITY</emphasis> CUPS"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>CUPS</primary>"
msgstr "<primary>CUPS</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Common Unix Printing System</primary>"
msgstr "<primary>Common Unix Printing System</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "CUPS (Common Unix Printing System) is a project (and a trademark) managed by Apple, Inc. <ulink type=\"block\" url=\"http://www.cups.org/\" />"
msgstr "CUPS (Common Unix Printing System) は Apple, Inc. の管理するプロジェクトです (さらに商標でもあります)。<ulink type=\"block\" url=\"http://www.cups.org/\" />"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "After installation of these different packages, <command>cups</command> is administered easily through a web interface accessible at the local address: <literal>http://localhost:631/</literal>. There you can add printers (including network printers), remove, and administer them. You can also administer <command>cups</command> with the graphical interface provided by the desktop environment. Finally, there is also the <command>system-config-printer</command> graphical interface (from the Debian package of the same name)."
msgstr "前述したさまざまなパッケージをインストールすれば、ローカルアドレスからアクセスできるウェブインターフェース (<literal>http://localhost:631/</literal>) を通じて <command>cups</command> を簡単に管理することが可能です。このインターフェースを使えばプリンタ (ネットワークプリンタも含みます) を追加、削除、管理することが可能です。また、デスクトップ環境が提供するグラフィカルインターフェースを使っても <command>cups</command> を管理することが可能です。最後に、<command>system-config-printer</command> グラフィカルインターフェース (同名の Debian パッケージに含まれます) を使うことも可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>cups</command></primary><secondary>administration</secondary>"
msgstr "<primary><command>cups</command></primary><secondary>管理</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>NOTE</emphasis> Obsolescence of <filename>/etc/printcap</filename>"
msgstr "<emphasis>NOTE</emphasis> <filename>/etc/printcap</filename> の陳腐化"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>cups</emphasis> no longer uses the <filename>/etc/printcap</filename> file, which is now obsolete. Programs that rely upon this file to get a list of available printers will, thus, fail. To avoid this problem, delete this file and make it a symbolic link (see sidebar <xref linkend=\"sidebar.symbolic-link\" />) to <filename>/var/run/cups/printcap</filename>, which is maintained by <emphasis>cups</emphasis> to ensure compatibility."
msgstr "<emphasis>cups</emphasis> は今や時代遅れになった <filename>/etc/printcap</filename> ファイルを使っていません。このため、利用できるプリンタのリストを得る目的で <filename>/etc/printcap</filename> ファイルを利用するプログラムは機能しません。この問題を避けるには、<filename>/etc/printcap</filename> ファイルを削除し、<filename>/var/run/cups/printcap</filename> へのシンボリックリンクに変えてください (補注<xref linkend=\"sidebar.symbolic-link\" />を参照してください)。<emphasis>cups</emphasis> は互換性を保つために <filename>/var/run/cups/printcap</filename> を管理しています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><filename>printcap</filename></primary>"
msgstr "<primary><filename>printcap</filename></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Configuring the Bootloader"
msgstr "ブートローダの設定"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>loader</primary><secondary>bootloader</secondary>"
msgstr "<primary>ローダ</primary><secondary>ブートローダ</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>bootloader</primary>"
msgstr "<primary>ブートローダ</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: PTAL;
# Ref: https://www.debian.org/releases/stable/i386/ch08s07.html.en;
msgid "It is probably already functional, but it is always good to know how to configure and install the bootloader in case it disappears from the Master Boot Record. This can occur after installation of another operating system, such as Windows. The following information can also help you to modify the bootloader configuration if needed."
msgstr "ブートローダは既に機能しているかもしれませんが、ブートローダがマスターブートレコードから消えてしまった状況に備えて、ブートローダの設定方法とイントール方法を知っておくのは常に良い考えです。この状況は Windows などの他のオペレーティングシステムをインストールした後に起こる場合があります。以下の情報はブートローダ設定の変更が必要になった際にそれを変更するための助けになるでしょう。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> Master boot record"
msgstr "<emphasis>BACK TO BASICS</emphasis> マスターブートレコード"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>MBR</primary>"
msgstr "<primary>MBR</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Master Boot Record</primary>"
msgstr "<primary>マスターブートレコード</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The Master Boot Record (MBR) occupies the first 512 bytes of the first hard disk, and is the first thing loaded by the BIOS to hand over control to a program capable of booting the desired operating system. In general, a bootloader gets installed in the MBR, removing its previous content."
msgstr "マスターブートレコード (MBR) は最初のハードディスクの最初の 512 バイトを専有し、BIOS は対象のオペレーティングシステムを起動できるプログラムに操作を受け渡すために真っ先に MBR を読み込みます。一般にブートローダは MBR にインストールされ、その前に MBR にあった情報は削除されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Identifying the Disks"
msgstr "ディスクの識別"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>CULTURE</emphasis> <emphasis>udev</emphasis> and <filename>/dev/</filename>"
msgstr "<emphasis>CULTURE</emphasis> <emphasis>udev</emphasis> と <filename>/dev/</filename>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <filename>/dev/</filename> directory traditionally houses so-called “special” files, intended to represent system peripherals (see sidebar <xref linkend=\"sidebar.special-files\" />). Once upon a time, it used to contain all special files that could potentially be used. This approach had a number of drawbacks among which the fact that it restricted the number of devices that one could use (due to the hardcoded list of names), and that it was impossible to know which special files were actually useful."
msgstr "伝統的に、<filename>/dev/</filename> ディレクトリはシステムの周辺機器を表す目的でいわゆる「スペシャル」ファイルを保存する場所でした (補注<xref linkend=\"sidebar.special-files\" />を参照してください)。昔 <filename>/dev/</filename> ディレクトリには、潜在的に利用する可能性のあるすべてのスペシャルファイルが含まれていました。このやり方には多くの欠点がありました。特に使うことのできるデバイスの数が制限されていた点 (名前リストがハードコードされていた点)、実際に使えるスペシャルファイルがどれなのか分からない点が問題でした。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Nowadays, the management of special files is entirely dynamic and matches better the nature of hot-swappable computer devices. The kernel cooperates with <emphasis>udev</emphasis> to create and delete them as needed when the corresponding devices appear and disappear. For this reason, <filename>/dev/</filename> doesn't need to be persistent and is thus a RAM-based filesystem that starts empty and contains only the relevant entries."
msgstr "今日、スペシャルファイルの管理は完全に動的に行われるようになっており、ホットスワップできるコンピュータデバイスの性質とうまく合っています。カーネルは <emphasis>udev</emphasis> と協力し、対応するデバイスが取り付けられたり取り外された際に、スペシャルファイルを作成したり削除したりします。この理由により <filename>/dev/</filename> を保存しておく必要はなくなり、RAM ベースのファイルシステムでは最初 <filename>/dev/</filename> ディレクトリを空にしておいて関連するエントリだけを含めるようにしています。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: http://www.linuxfromscratch.org/lfs/view/stable/chapter07/udev.html;
msgid "The kernel communicates lots of information about any newly added device and hands out a pair of major/minor numbers to identify it. With this <command>udevd</command> can create the special file under the name and with the permissions that it wants. It can also create aliases and perform additional actions (such as initialization or registration tasks). <command>udevd</command>'s behavior is driven by a large set of (customizable) rules."
msgstr "カーネルは新たに追加されたデバイスに関する多くの情報をやり取りして、そのデバイスを識別するメジャー/マイナー番号の組を配布します。<command>udevd</command> はデバイスに必要なパーミッション設定と命名を行ったスペシャルファイルを作成します。さらに <command>udevd</command> は別名を作成し、追加的操作 (デバイスの初期化や登録作業など) を実行することも可能です。<command>udevd</command> の挙動は (カスタマイズが可能な) 巨大ルール群によって決定されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "With dynamically assigned names, you can thus keep the same name for a given device, regardless of the connector used or the connection order, which is especially useful when you use various USB peripherals. The first partition on the first hard drive can then be called <filename>/dev/sda1</filename> for backwards compatibility, or <filename>/dev/root-partition</filename> if you prefer, or even both at the same time since <command>udevd</command> can be configured to automatically create a symbolic link."
msgstr "動的に名前を付けることで、あるデバイスに常に同じ名前を持たせることが可能になります。名前は接続するコネクタや接続順に依存しないので、特に複数の USB 周辺機器を使う場合に便利です。1 台目のハードドライブの最初のパーティションは後方互換性を保つために <filename>/dev/sda1</filename> と呼ばれます。しかしあなたがそう望むなら <filename>/dev/root-partition</filename> と呼ぶことも可能ですし、両方の名前を同時に使うことも可能です。なぜなら <command>udevd</command> を設定すれば自動的にシンボリックリンクを作成するようにできるからです。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: PTAL;
msgid "In ancient times, some kernel modules did automatically load when you tried to access the corresponding device file. This is no longer the case, and the peripheral's special file no longer exists prior to loading the module; this is no big deal, since most modules are loaded on boot thanks to automatic hardware detection. But for undetectable peripherals (such as very old disk drives or PS/2 mice), this doesn't work. Consider adding the modules, <literal>floppy</literal>, <literal>psmouse</literal> and <literal>mousedev</literal> to <filename>/etc/modules</filename> in order to force loading them on boot."
msgstr "古くは、一部のカーネルモジュールはユーザが関連するデバイスファイルにアクセスを試行した時点で自動的に読み込まれていました。今現在この方針は使われておらず、モジュールを読み込む前に周辺機器のスペシャルファイルが存在することはありません。しかしこれは大きな問題ではありません。なぜなら、自動ハードウェア検出のおかげで多くのモジュールは起動時に読み込まれるからです。しかし、検出できない周辺機器 (非常に古いディスクドライブや PS/2 マウスなど) ではこの挙動が問題になります。<literal>floppy</literal>、<literal>psmouse</literal>、<literal>mousedev</literal> モジュールを <filename>/etc/modules</filename> に追加して、起動時に強制的にこれらのモジュールを読み込むことを検討してください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>hard drive, names</primary>"
msgstr "<primary>ハードドライブ、名前</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>names</primary><secondary>of hard drives</secondary>"
msgstr "<primary>名前</primary><secondary>ハードドライブの名前</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Configuration of the bootloader must identify the different hard drives and their partitions. Linux uses “block” special files stored in the <filename>/dev/</filename> directory, for this purpose. Since Debian <emphasis role=\"distribution\">Squeeze</emphasis>, the naming scheme for hard drives has been unified by the Linux kernel, and all hard drives (IDE/PATA, SATA, SCSI, USB, IEEE 1394) are now represented by <filename>/dev/sd*</filename>."
msgstr "ブートローダを設定するには、必ずさまざまなハードドライブとそのパーティションを識別しなければいけません。Linux はこの目的のために <filename>/dev/</filename> ディレクトリ内で「ブロック」スペシャルファイルを使います。Debian <emphasis role=\"distribution\">Squeeze</emphasis> 以降、ハードドライブの命名規則は Linux カーネルによって統一化されました。現在、すべてのハードドライブ (IDE/PATA、SATA、SCSI、USB、IEEE 1394) は <filename>/dev/sd*</filename> と表されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Each partition is represented by its number on the disk on which it resides: for instance, <filename>/dev/sda1</filename> is the first partition on the first disk, and <filename>/dev/sdb3</filename> is the third partition on the second disk."
msgstr "それぞれのパーティションは自分が存在するディスク上の番号で表されます。たとえば、<filename>/dev/sda1</filename> は 1 台目のディスクの最初のパーティションで、<filename>/dev/sdb3</filename> は 2 台目のディスクの 3 番目のパーティションです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>partition</primary><secondary>primary</secondary>"
msgstr "<primary>パーティション</primary><secondary>プライマリ</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>partition</primary><secondary>extended</secondary>"
msgstr "<primary>パーティション</primary><secondary>拡張</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>partition</primary><secondary>secondary</secondary>"
msgstr "<primary>パーティション</primary><secondary>セカンダリ</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>partition table</primary><secondary>MS-DOS format</secondary>"
msgstr "<primary>パーティションテーブル</primary><secondary>MS-DOS フォーマット</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The PC architecture (or “i386”, including its younger cousin “amd64”) has long been limited to using the “MS-DOS” partition table format, which only allows four “primary” partitions per disk. To go beyond this limitation under this scheme, one of them has to be created as an “extended” partition, and it can then contain additional “secondary” partitions. These secondary partitions are numbered from 5. Thus the first secondary partition could be <filename>/dev/sda5</filename>, followed by <filename>/dev/sda6</filename>, etc."
msgstr "PC アーキテクチャ (つまり「i386」およびその年下のいとこである「amd64」) では、長い間「MS-DOS」パーティションテーブルフォーマットを使うよう制限を受けていました。このフォーマットはディスク 1 台当たりに作れる「プライマリ」パーティションの数を 4 つに制限していました。この制限を乗り越えるためには、プライマリパーティションの 1 つを「拡張」パーティションとして作成します。拡張パーティションには追加的な「セカンダリ」パーティションを含めることが可能です。このようなセカンダリパーティションには 5 以上の番号が割り振られます。従って、最初のセカンダリパーティションは <filename>/dev/sda5</filename>、2 番目は <filename>/dev/sda6</filename> などのように割り振られるでしょう。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Another restriction of the MS-DOS partition table format is that it only allows disks up to 2 TiB in size, which is becoming a real problem with recent disks."
msgstr "MS-DOS パーティションテーブルフォーマットのもう一つの制限は、2 TiB を超えるサイズのディスクを取り扱うことができないという点です。近年のディスクではこの制限が現実的な問題になりつつあります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>GPT</primary><secondary>partition table format</secondary>"
msgstr "<primary>GPT</primary><secondary>パーティションテーブルフォーマット</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>partition table</primary><secondary>GPT format</secondary>"
msgstr "<primary>パーティションテーブル</primary><secondary>GPT フォーマット</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "A new partition table format called GPT loosens these constraints on the number of partitions (it allows up to 128 partitions when using standard settings) and on the size of the disks (up to 8 ZiB, which is more than 8 billion terabytes). If you intend to create many physical partitions on the same disk, you should therefore ensure that you are creating the partition table in the GPT format when partitioning your disk."
msgstr "GPT と呼ばれる新しいパーティションテーブルフォーマットを使うことで上に挙げた制限が緩和されます。GPT では、パーティション数は最大で 128 個に制限され (標準的な設定を使った場合)、ディスクサイズは最大で 8 ZiB (80 億テラバイト以上) に制限されます。1 台のディスクに多くの物理パーティションを作成する場合、ディスクのパーティショニングを行う際に必ず GPT フォーマットでパーティションテーブルを作成するよう注意してください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "It is not always easy to remember what disk is connected to which SATA controller, or in third position in the SCSI chain, especially since the naming of hotplugged hard drives (which includes among others most SATA disks and external disks) can change from one boot to another. Fortunately, <command>udev</command> creates, in addition to <filename>/dev/sd*</filename>, symbolic links with a fixed name, which you could then use if you wished to identify a hard drive in a non-ambiguous manner. These symbolic links are stored in <filename>/dev/disk/by-id</filename>. On a machine with two physical disks, for example, one could find the following:"
msgstr "どのディスクがどの SATA コントローラに (たとえば SCSI チェーンの 3 番目に) 接続されているかを記憶するのは常に簡単というわけではありません。なぜなら、特にホットプラグ対応のハードドライブ (これには多くの SATA ディスクや外部ディスクが含まれます) の名前は起動の度に変わるからです。幸いなことに、<command>udev</command> は <filename>/dev/sd*</filename> に加えて、固有名のシンボリックリンクを作成します。曖昧でない方法でハードドライブを識別したい場合にはこのシンボリックリンクを使うことが可能です。これらのシンボリックリンクは <filename>/dev/disk/by-id</filename> に保存されています。たとえば 2 台の物理ディスクを備えるマシンでは以下のようなシンボリックリンクが見つかります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"<computeroutput>mirexpress:/dev/disk/by-id# </computeroutput><userinput>ls -l\n"
"</userinput><computeroutput>total 0\n"
"lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP -&gt; ../../sda\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697 -&gt; ../../sdb\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part1 -&gt; ../../sdb1\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part2 -&gt; ../../sdb2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP -&gt; ../../sda\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697 -&gt; ../../sdb\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part1 -&gt; ../../sdb1\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part2 -&gt; ../../sdb2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0 -&gt; ../../sdc\n"
"lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part1 -&gt; ../../sdc1\n"
"lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part2 -&gt; ../../sdc2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9 23 jul. 08:58 wwn-0x5000c50015c4842f -&gt; ../../sda\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 wwn-0x5000c50015c4842f-part1 -&gt; ../../sda1\n"
"[...]\n"
"mirexpress:/dev/disk/by-id# </computeroutput>"
msgstr ""
"<computeroutput>mirexpress:/dev/disk/by-id# </computeroutput><userinput>ls -l\n"
"</userinput><computeroutput>合計 0\n"
"lrwxrwxrwx 1 root root  9  7月 23 08:58 ata-STM3500418AS_9VM3L3KP -&gt; ../../sda\n"
"lrwxrwxrwx 1 root root 10  7月 23 08:58 ata-STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1\n"
"lrwxrwxrwx 1 root root 10  7月 23 08:58 ata-STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9  7月 23 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697 -&gt; ../../sdb\n"
"lrwxrwxrwx 1 root root 10  7月 23 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part1 -&gt; ../../sdb1\n"
"lrwxrwxrwx 1 root root 10  7月 23 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part2 -&gt; ../../sdb2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9  7月 23 08:58 scsi-SATA_STM3500418AS_9VM3L3KP -&gt; ../../sda\n"
"lrwxrwxrwx 1 root root 10  7月 23 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1\n"
"lrwxrwxrwx 1 root root 10  7月 23 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9  7月 23 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697 -&gt; ../../sdb\n"
"lrwxrwxrwx 1 root root 10  7月 23 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part1 -&gt; ../../sdb1\n"
"lrwxrwxrwx 1 root root 10  7月 23 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part2 -&gt; ../../sdb2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9  7月 23 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0 -&gt; ../../sdc\n"
"lrwxrwxrwx 1 root root 10  7月 23 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part1 -&gt; ../../sdc1\n"
"lrwxrwxrwx 1 root root 10  7月 23 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part2 -&gt; ../../sdc2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9  7月 23 08:58 wwn-0x5000c50015c4842f -&gt; ../../sda\n"
"lrwxrwxrwx 1 root root 10  7月 23 08:58 wwn-0x5000c50015c4842f-part1 -&gt; ../../sda1\n"
"[...]\n"
"mirexpress:/dev/disk/by-id# </computeroutput>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Note that some disks are listed several times (because they behave simultaneously as ATA disks and SCSI disks), but the relevant information is mainly in the model and serial numbers of the disks, from which you can find the peripheral file."
msgstr "いくつかのディスクは複数回リストされています (なぜなら、それらは ATA ディスクであり同時に SCSI ディスクとしても振る舞うからです)。しかしながら、ディスクに固有の情報は主にディスクの製品番号とシリアル番号であるという点に注意してください。ここから、目的の周辺機器のシンボリックリンクを見つけることが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The example configuration files given in the following sections are based on the same setup: a single SATA disk, where the first partition is an old Windows installation and the second contains Debian GNU/Linux."
msgstr "以降の節で挙げる設定ファイルの例はこれと同じディスク構成のマシンに対する設定です。具体的に言えば、1 台の SATA ディスクがあり、最初のパーティションに古い Windows がインストールされており、2 番目のパーティションに Debian GNU/Linux がインストールされている状態です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Configuring LILO"
msgstr "LILO の設定"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>LILO</primary>"
msgstr "<primary>LILO</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Linux Loader</primary>"
msgstr "<primary>Linux Loader</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>LILO</emphasis> (LInux LOader) is the oldest bootloader — solid but rustic. It writes the physical address of the kernel to boot on the MBR, which is why each update to LILO (or its configuration file) must be followed by the command <command>lilo</command>. Forgetting to do so will render a system unable to boot if the old kernel was removed or replaced as the new one will not be in the same location on the disk."
msgstr "<emphasis>LILO</emphasis> (LInux LOader) は最も古い (実直だが素朴な) ブートローダです。<emphasis>LILO</emphasis> は MBR に起動するカーネルの物理アドレスを書くため、LILO および LILO の設定ファイルを更新した際にはその後に必ず <command>lilo</command> コマンドを使わなければいけません。このルールを忘れて、古いカーネルを削除したり、置き換えた新しいカーネルを古いカーネルがあった場所と同じディスクの場所に置かなかったりすると、システムが起動できないと表示されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "LILO's configuration file is <filename>/etc/lilo.conf</filename>; a simple file for standard configuration is illustrated in the example below."
msgstr "LILO の設定ファイルは <filename>/etc/lilo.conf</filename> です。標準的な設定を行う単純なファイルは以下の例のように書けます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "LILO configuration file"
msgstr "LILO の設定ファイル"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: $ man 5 lilo.conf;
msgid ""
"\n"
"# The disk on which LILO should be installed.\n"
"# By indicating the disk and not a partition.\n"
"# you order LILO to be installed on the MBR.\n"
"boot=/dev/sda\n"
"# the partition that contains Debian\n"
"root=/dev/sda2\n"
"# the item to be loaded by default\n"
"default=Linux\n"
"\n"
"# the most recent kernel image\n"
"image=/vmlinuz\n"
"  label=Linux\n"
"  initrd=/initrd.img\n"
"  read-only\n"
"\n"
"# Old kernel (if the newly installed kernel doesn't boot)\n"
"image=/vmlinuz.old\n"
"  label=LinuxOLD\n"
"  initrd=/initrd.img.old\n"
"  read-only\n"
"  optional\n"
"\n"
"# only for Linux/Windows dual boot\n"
"other=/dev/sda1\n"
"  label=Windows"
msgstr ""
"\n"
"# このディスクに LILO をインストールします。\n"
"# ここではパーティションではなくディスクを指定してください。\n"
"# LILO は MBR にインストールされます。\n"
"boot=/dev/sda\n"
"# Debian がインストールされているパーティション\n"
"root=/dev/sda2\n"
"# デフォルトで起動させるアイテム\n"
"default=Linux\n"
"\n"
"# 最新のカーネルイメージ\n"
"image=/vmlinuz\n"
"  label=Linux\n"
"  initrd=/initrd.img\n"
"  read-only\n"
"\n"
"# 古いカーネル (最新のカーネルが起動しなかった際に使います)\n"
"image=/vmlinuz.old\n"
"  label=LinuxOLD\n"
"  initrd=/initrd.img.old\n"
"  read-only\n"
"  optional\n"
"\n"
"# Linux と Windows のデュアルブート用\n"
"other=/dev/sda1\n"
"  label=Windows"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "GRUB 2 Configuration"
msgstr "GRUB 2 の設定"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>GRUB</primary>"
msgstr "<primary>GRUB</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>GRUB 2</primary>"
msgstr "<primary>GRUB 2</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>GRUB</emphasis> (GRand Unified Bootloader) is more recent. It is not necessary to invoke it after each update of the kernel; <emphasis>GRUB</emphasis> knows how to read the filesystems and find the position of the kernel on the disk by itself. To install it on the MBR of the first disk, simply type <command>grub-install /dev/sda</command>. <indexterm><primary><command>grub-install</command></primary></indexterm>"
msgstr "<emphasis>GRUB</emphasis> (GRand Unified Bootloader) はより新しいブートローダです。カーネル更新の後に GRUB を実行する必要はありません。それどころか <emphasis>GRUB</emphasis> はファイルシステムを読む方法とディスクからカーネルを探し出す方法を知っています。GRUB を最初のディスクの MBR にインストールするためには、<command>grub-install /dev/sda</command> を実行してください。<indexterm><primary><command>grub-install</command></primary></indexterm>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>NOTE</emphasis> Disk names for GRUB"
msgstr "<emphasis>NOTE</emphasis> GRUB におけるディスク名の命名規則"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "GRUB can only identify hard drives based on information provided by the BIOS. <literal>(hd0)</literal> corresponds to the first disk thus detected, <literal>(hd1)</literal> the second, etc. In most cases, this order corresponds exactly to the usual order of disks under Linux, but problems can occur when you associate SCSI and IDE disks. GRUB stores correspondences that it detects in the file <filename>/boot/grub/device.map</filename>. If you find errors there (because you know that your BIOS detects drives in a different order), correct them manually and run <command>grub-install</command> again. <command>grub-mkdevicemap</command> can help creating a <filename>device.map</filename> file from which to start."
msgstr "GRUB は BIOS から提供される情報に従ってハードドライブを識別します。<literal>(hd0)</literal> は最初に検出されたディスクに対応し、<literal>(hd1)</literal> は 2 番目に対応します。多くの場合、この順番は Linux 上でディスクが検出される普通の順番と完全に一致しますが、SCSI や IDE ディスクを使っている場合、問題が起きるかもしれません。GRUB は検出した対応関係を <filename>/boot/grub/device.map</filename> ファイルの中に保存します。管理者がこの対応関係に間違いを見つけた場合 (BIOS が Linux と違う順番でドライブを検出するということを知っている場合)、対応関係を修正して、もう一度 <command>grub-install</command> を実行してください。<command>grub-mkdevicemap</command> を使えば、<filename>device.map</filename> ファイルのたたき台を作成することが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Partitions also have a specific name in GRUB. When you use “classical” partitions in MS-DOS format, the first partition on the first disk is labeled, <literal>(hd0,msdos1)</literal>, the second <literal>(hd0,msdos2)</literal>, etc."
msgstr "GRUB はパーティションを識別する名前も使います。MS-DOS フォーマットの「標準的な」パーティションを使っている場合、最初のディスクの最初のパーティションは <literal>(hd0,msdos1)</literal>、2 番目のパーティションは <literal>(hd0,msdos2)</literal> です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "GRUB 2 configuration is stored in <filename>/boot/grub/grub.cfg</filename>, but this file (in Debian) is generated from others. Be careful not to modify it by hand, since such local modifications will be lost the next time <command>update-grub</command> is run (which may occur upon update of various packages). The most common modifications of the <filename>/boot/grub/grub.cfg</filename> file (to add command line parameters to the kernel or change the duration that the menu is displayed, for example) are made through the variables in <filename>/etc/default/grub</filename>. To add entries to the menu, you can either create a <filename>/boot/grub/custom.cfg</filename> file or modify the <filename>/etc/grub.d/50_custom</filename> file. For more complex configurations, you can modify other files in <filename>/etc/grub.d</filename>, or add to them; these scripts should return configuration snippets, possibly by making use of external programs. These scripts are the ones that will update the list of kernels to boot: <filename>10_linux</filename> takes into consideration the installed Linux kernels; <filename>20_linux_xen</filename> takes into account Xen virtual systems, and <filename>30_os-prober</filename> lists other operating systems (Windows, OS X, Hurd)."
msgstr "GRUB 2 の設定は <filename>/boot/grub/grub.cfg</filename> に保存されていますが、このファイルは (Debian の場合) 別のファイルから生成されます。<filename>/boot/grub/grub.cfg</filename> を直接変更しないでください。なぜなら、<command>update-grub</command> が実行されたら (さまざまなパッケージの更新時に実行されることがあります) そのようなその場限りの変更は失われるからです。<filename>/boot/grub/grub.cfg</filename> ファイルに対して最も一般的な変更を加える (たとえば、カーネルに渡すコマンドラインパラメータを追加したり、メニューの表示される時間を変える) には <filename>/etc/default/grub</filename> に含まれる変数を使います。メニューにエントリを追加するには <filename>/boot/grub/custom.cfg</filename> ファイルを作成するか、<filename>/etc/grub.d/50_custom</filename> ファイルを変更してください。より複雑な設定をするには <filename>/etc/grub.d</filename> にある他のファイルを変更するか、このディレクトリにファイルを追加してください。<filename>/etc/grub.d</filename> ディレクトリに含まれるスクリプトは設定スニペットを返すスクリプトであり、場合によっては外部プログラムを使用するかもしれません。これらのスクリプトは起動したいカーネルのリストを更新するためのものです。すなわち <filename>10_linux</filename> はインストール済み Linux カーネルをリストアップします。そして <filename>20_linux_xen</filename> は Xen 仮想システムをリストアップし、<filename>30_os-prober</filename> は他のオペレーティングシステム (Windows、OS X、Hurd) をリストアップします。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "For Macintosh Computers (PowerPC): Configuring Yaboot"
msgstr "Macintosh コンピュータ (PowerPC) の場合、Yaboot の設定"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>yaboot</command></primary>"
msgstr "<primary><command>yaboot</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: $ man 8 bootstrap;
# Ref: https://www.debian.org/ports/powerpc/inst/yaboot-howto/ch6.en.html;
msgid "Yaboot is the bootloader used by old Macintosh computers using PowerPC processors. They do not boot like PCs, but rely on a “bootstrap” partition, from which the BIOS (or OpenFirmware) executes the loader, and on which the <command>ybin</command> program installs <command>yaboot</command> and its configuration file. You will only need to run this command again if the <filename>/etc/yaboot.conf</filename> is modified (it is duplicated on the bootstrap partition, and <command>yaboot</command> knows how to find the position of the kernels on the disks)."
msgstr "Yaboot は PowerPC プロセッサを搭載する古い Macintosh コンピュータ用のブートローダです。古い Macintosh コンピュータは PC のように起動せず、「bootstrap」パーティションを使って起動します。「bootstrap」パーティションには、BIOS (または OpenFirmware) が実行する Yaboot が含まれ、さらに <command>ybin</command> プログラムがインストールする <command>yaboot</command> と設定ファイルも含まれています。設定ファイル <filename>/etc/yaboot.conf</filename> (このファイルは bootstrap パーティションにコピーされ、<command>yaboot</command> がディスク上からカーネルのパーティションを見つける方法を指定するファイルです) を変更したら、<command>ybin</command> コマンドをもう一度実行する必要があります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Before executing <command>ybin</command>, you must first have a valid <filename>/etc/yaboot.conf</filename>. The following is an example of a minimal configuration. <indexterm><primary><command>ybin</command></primary></indexterm>"
msgstr "<command>ybin</command> を実行する前に、適切な <filename>/etc/yaboot.conf</filename> を作らなければいけません。以下は最低限の設定例です。<indexterm><primary><command>ybin</command></primary></indexterm>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Yaboot configuration file"
msgstr "Yaboot の設定ファイル"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: $ man 5 yaboot.conf;
# Ref: https://www.debian.org/ports/powerpc/inst/yaboot-howto/ch6.en.html;
msgid ""
"\n"
"# bootstrap partition\n"
"boot=/dev/sda2\n"
"# the disk\n"
"device=hd:\n"
"# the Linux partition\n"
"partition=3\n"
"root=/dev/sda3\n"
"# boot after 3 seconds of inactivity\n"
"# (timeout is in tenths of seconds)\n"
"timeout=30\n"
"\n"
"install=/usr/lib/yaboot/yaboot\n"
"magicboot=/usr/lib/yaboot/ofboot\n"
"enablecdboot\n"
"\n"
"# last kernel installed\n"
"image=/vmlinux\n"
"        label=linux\n"
"        initrd=/initrd.img\n"
"        read-only\n"
"\n"
"# old kernel\n"
"image=/vmlinux.old\n"
"        label=old\n"
"        initrd=/initrd.img.old\n"
"        read-only\n"
"\n"
"# only for Linux/Mac OSX dual-boot\n"
"macosx=/dev/sda5\n"
"\n"
"# bsd=/dev/sdaX and macos=/dev/sdaX\n"
"# are also possible"
msgstr ""
"\n"
"# bootstrap パーティション\n"
"boot=/dev/sda2\n"
"# ディスク\n"
"device=hd:\n"
"# Linux パーティション\n"
"partition=3\n"
"root=/dev/sda3\n"
"# 3 秒間何もしなければ起動します\n"
"# (timeout は 10 倍の値を設定してください)\n"
"timeout=30\n"
"\n"
"install=/usr/lib/yaboot/yaboot\n"
"magicboot=/usr/lib/yaboot/ofboot\n"
"enablecdboot\n"
"\n"
"# 最近インストールされたカーネル\n"
"image=/vmlinux\n"
"        label=linux\n"
"        initrd=/initrd.img\n"
"        read-only\n"
"\n"
"# 古いカーネル\n"
"image=/vmlinux.old\n"
"        label=old\n"
"        initrd=/initrd.img.old\n"
"        read-only\n"
"\n"
"# Linux と Mac OSX のデュアルブート用\n"
"macosx=/dev/sda5\n"
"\n"
"# bsd=/dev/sdaX および macos=/dev/sdaX\n"
"# の可能性もあります"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Other Configurations: Time Synchronization, Logs, Sharing Access…"
msgstr "その他の設定: 時刻同期、ログ、共有アクセス…"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The many elements listed in this section are good to know for anyone who wants to master all aspects of configuration of the GNU/Linux system. They are, however, treated briefly and frequently refer to the documentation."
msgstr "この節にリストされている多くの要素は、GNU/Linux システムの設定のあらゆる側面を極めたいと思う人なら誰でも、知っておくと良い知識です。しかしながらここでは、各要素を簡単に紹介し、頻繁に文書を参照するだけに留めます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Timezone"
msgstr "タイムゾーン"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>timezone</primary>"
msgstr "<primary>タイムゾーン</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> Symbolic links"
msgstr "<emphasis>BACK TO BASICS</emphasis> シンボリックリンク"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>link</primary><secondary>symbolic</secondary>"
msgstr "<primary>リンク</primary><secondary>シンボリック</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>symbolic link</primary>"
msgstr "<primary>シンボリックリンク</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>ln</command></primary>"
msgstr "<primary><command>ln</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "A symbolic link is a pointer to another file. When you access it, the file to which it points is opened. Removal of the link will not cause deletion of the file to which it points. Likewise, it does not have its own set of permissions, but rather retains the permissions of its target. Finally, it can point to any type of file: directories, special files (sockets, named pipes, device files, etc.), even other symbolic links."
msgstr "シンボリックリンクは他のファイルへのポインタです。シンボリックリンクにアクセスすると、シンボリックリンクの指すファイルが開かれます。シンボリックリンクを削除しても、シンボリックリンクの指すファイルは削除されません。同様に、シンボリックリンクに対してパーミッションを設定することは不可能であり、シンボリックリンクはシンボリックリンクの指すファイルと同じパーミッションを持つとみなされます。最後に、シンボリックリンクはいかなる種類のファイルを指すことも可能です。具体的に言えば、ディレクトリ、スペシャルファイル (ソケット、名前付きパイプ、デバイスファイルなど)、さらには他のシンボリックリンクでさえ指すことが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <command>ln -s <replaceable>target</replaceable> <replaceable>link-name</replaceable></command> command creates a symbolic link, named <replaceable>link-name</replaceable>, pointing to <replaceable>target</replaceable>."
msgstr "<command>ln -s <replaceable>target</replaceable> <replaceable>link-name</replaceable></command> コマンドは <replaceable>link-name</replaceable> と名付けられ <replaceable>target</replaceable> を指すシンボリックリンクを作成します。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: $ ln -fs cycliclink cycliclink && LANG=ja_JP.UTF-8 cat cycliclink && rm cycliclink;
# Tag: L-CFMD;
msgid "If the target does not exist, then the link is “broken” and accessing it will result in an error indicating that the target file does not exist. If the link points to another link, you will have a “chain” of links that turns into a “cycle” if one of the targets points to one of its predecessors. In this case, accessing one of the links in the cycle will result in a specific error (“too many levels of symbolic links”); this means the kernel gave up after several rounds of the cycle."
msgstr "シンボリックリンクのリンク先が存在しない場合リンクは「壊れて」おり、壊れたシンボリックリンクにアクセスするとリンク先のファイルが存在しないことを示すエラーが返されます。別のシンボリックリンクにシンボリックリンクを張るとシンボリックリンクが「連鎖」し、リンク先がリンク元を指していた場合にはリンクの「循環」状態になります。この状態で、循環鎖に含まれるリンクの 1 つにアクセスした場合、特定のエラー (「シンボリックリンクの階層が多すぎます」) が返されます。すなわちこれは、カーネルが何回か循環鎖を巡った後にそうすることを諦めたことを意味しています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The timezone, configured during initial installation, is a configuration item for the <emphasis role=\"pkg\">tzdata</emphasis> package. To modify it, use the <command>dpkg-reconfigure tzdata</command> command, which allows you to choose the timezone to be used in an interactive manner. Its configuration is stored in the <filename>/etc/timezone</filename> file. Additionally, the corresponding file in the <filename>/usr/share/zoneinfo</filename> directory is copied into <filename>/etc/localtime</filename>; this file contains the rules governing the dates where daylight saving time is active, for countries that use it."
msgstr "タイムゾーンは初回インストール時に設定され、<emphasis role=\"pkg\">tzdata</emphasis> パッケージを使って設定されます。タイムゾーンを変更するには、<command>dpkg-reconfigure tzdata</command> コマンドを使ってください。このコマンドを使えば、対話的に変更したいタイムゾーンを選ぶことが可能です。タイムゾーンの設定は <filename>/etc/timezone</filename> ファイルに保存されます。さらに、<filename>/usr/share/zoneinfo</filename> ディレクトリに含まれるタイムゾーンに対応するファイルが <filename>/etc/localtime</filename> の中にコピーされます。さらに <filename>/etc/localtime</filename> には、夏時間を使う国向けに夏時間が有効な場所で日付を処理するためのルールが含まれています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><filename>timezone</filename></primary>"
msgstr "<primary><filename>timezone</filename></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><filename>/etc/timezone</filename></primary>"
msgstr "<primary><filename>/etc/timezone</filename></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><filename>zoneinfo</filename></primary>"
msgstr "<primary><filename>zoneinfo</filename></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><filename>/usr/share/zoneinfo/</filename></primary>"
msgstr "<primary><filename>/usr/share/zoneinfo/</filename></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>DST</primary>"
msgstr "<primary>DST</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>daylight saving time</primary>"
msgstr "<primary>夏時間</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "When you need to temporarily change the timezone, use the <varname>TZ</varname> environment variable, which takes priority over the configured system default:"
msgstr "一時的にタイムゾーンを変更したい場合、<varname>TZ</varname> 環境変数を使ってください。<varname>TZ</varname> 環境変数に設定した値はシステムデフォルトで設定された値よりも優先されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><varname>TZ</varname></primary>"
msgstr "<primary><varname>TZ</varname></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>date</userinput>\n"
"<computeroutput>Thu Feb 19 11:25:18 CET 2015</computeroutput>\n"
"<computeroutput>$ </computeroutput><userinput>TZ=\"Pacific/Honolulu\" date</userinput>\n"
"<computeroutput>Thu Feb 19 00:25:21 HST 2015</computeroutput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>date</userinput>\n"
"<computeroutput>2015年  2月 19日 木曜日 19:25:18 JST</computeroutput>\n"
"<computeroutput>$ </computeroutput><userinput>TZ=\"Pacific/Honolulu\" date</userinput>\n"
"<computeroutput>2015年  2月 19日 木曜日 00:25:18 HST</computeroutput>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>NOTE</emphasis> System clock, hardware clock"
msgstr "<emphasis>NOTE</emphasis> システムクロック、ハードウェアクロック"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: http://tldp.org/HOWTO/Clock-2.html;
msgid "There are two time sources in a computer. A computer's motherboard has a hardware clock, called the “CMOS clock”. This clock is not very precise, and provides rather slow access times. The operating system kernel has its own, the software clock, which it keeps up to date with its own means (possibly with the help of time servers, see <xref linkend=\"sect.time-synchronization\" />). This system clock is generally more accurate, especially since it doesn't need access to hardware variables. However, since it only exists in live memory, it is zeroed out every time the machine is booted, contrary to the CMOS clock, which has a battery and therefore “survives” rebooting or halting of the machine. The system clock is, thus, set from the CMOS clock during boot, and the CMOS clock is updated on shutdown (to take into account possible changes or corrections if it has been improperly adjusted)."
msgstr "コンピュータには 2 種類の時間ソースがあります。コンピュータのマザーボードには「CMOS クロック」と呼ばれるハードウェアクロックがあります。ハードウェアクロックは極めて正確なものというわけではありませんし、比較的アクセスに時間がかかります。また、オペレーティングシステムカーネルにはシステムクロック (ソフトウェアクロック) があります。システムクロックは独自の方法を使って最新の状態に保たれています (タイムサーバの助けを借りているかもしれません。<xref linkend=\"sect.time-synchronization\" />をご覧ください)。システムクロックを使えば、CMOS クロックにアクセスする必要がないため、さらに正確な値を得られます。しかしながら、システムクロックは揮発性メモリの中にあるため、マシンが起動する際に毎回ゼロに設定されます。それに対して、CMOS クロックは電池を持っているので、マシンを再起動や停止しても値を「残す」ことが可能です。そんなわけで、システムクロックは起動中に CMOS クロックの値を使って設定され、CMOS クロックはシャットダウンの際に更新されます (CMOS クロックが不適切に調整されていた場合、変更または訂正された場合を考慮して更新します)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "In practice, there is a problem, since the CMOS clock is nothing more than a counter and contains no information regarding the time zone. There is a choice to make regarding its interpretation: either the system considers it runs in universal time (UTC, formerly GMT), or in local time. This choice could be a simple shift, but things are actually more complicated: as a result of daylight saving time, this offset is not constant. The result is that the system has no way to determine whether the offset is correct, especially around periods of time change. Since it is always possible to reconstruct local time from universal time and the timezone information, we strongly recommend using the CMOS clock in universal time."
msgstr "実際のところ、このやり方には問題があります。なぜなら、CMOS クロックは単なるカウンタに過ぎず、タイムゾーンに関する情報を持たないからです。CMOS クロックの値を解釈する際には選択の余地が残されています。すなわち、システムは CMOS クロックを協定世界時 (UTC、旧 GMT) またはローカル時間のどちらで解釈するかを選ばなければいけません。両者は単純な補正定数の違いに過ぎないように見えますが、しかし実際はより複雑な違いがあります。たとえば夏時間がある場合、この補正量は定数ではありません。その結果、特に夏時間が適用される期間中には、補正量の正しさを決定する術がありません。協定世界時とタイムゾーン情報からローカル時間を再構成することは常に可能ですから、CMOS クロックを協定世界時として扱うことを推奨します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Unfortunately, Windows systems in their default configuration ignore this recommendation; they keep the CMOS clock on local time, applying time changes when booting the computer by trying to guess during time changes if the change has already been applied or not. This works relatively well, as long as the system has only Windows running on it. But when a computer has several systems (whether it be a “dual-boot” configuration or running other systems via virtual machine), chaos ensues, with no means to determine if the time is correct. If you absolutely must retain Windows on a computer, you should either configure it to keep the CMOS clock as UTC (setting the registry key <literal>HKLM\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation\\RealTimeIsUniversal</literal> to “1” as a DWORD), or use <command>hwclock --localtime --set</command> on the Debian system to set the hardware clock and mark it as tracking the local time (and make sure to manually check your clock in spring and autumn)."
msgstr "不幸なことに、Windows システムのデフォルト設定はこの推奨に従いません。すなわち Windows システムは CMOS クロックをローカル時間に保ち、コンピュータの起動時には夏時間中の時間変更が既に適用されているか否かを推測して時間変更を適用します。マシン上で Windows だけが動いている場合、このやり方は比較的うまく動作します。しかしコンピュータに複数のシステムがある場合 (「デュアルブート」設定や仮想マシンを通じて他のシステムを動かす場合)、時間が正確か決定する方法は存在せず、時間設定はめちゃくちゃになります。どうしてもコンピュータに Windows を残さなければいけない場合、Windows を設定して CMOS クロックを UTC に保つ (<literal>HKLM\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation\\RealTimeIsUniversal</literal> レジストリキーを DWORD の「1」に設定する) か、Debian システムで <command>hwclock --localtime --set</command> を使いハードウェアクロックをローカル時間に保つ (そして春と秋に手作業で時計を確認する) かのどちらか一方を設定してください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Time Synchronization"
msgstr "時刻同期"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>time synchronization</primary>"
msgstr "<primary>時刻同期</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>clock</primary><secondary>synchronization</secondary>"
msgstr "<primary>時計</primary><secondary>同期</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Time synchronization, which may seem superfluous on a computer, is very important on a network. Since users do not have permissions allowing them to modify the date and time, it is important for this information to be precise to prevent confusion. Furthermore, having all of the computers on a network synchronized allows better cross-referencing of information from logs on different machines. Thus, in the event of an attack, it is easier to reconstruct the chronological sequence of actions on the various machines involved in the compromise. Data collected on several machines for statistical purposes won't make a great deal of sense if they are not synchronized."
msgstr "時刻同期は、コンピュータ上では不必要の操作のようにも見えますが、ネットワーク上では極めて重要です。ユーザは日付と時間を変更することを許可されていないので、混乱を防ぐためには時刻情報を正確に保つことがとても重要です。さらに、ネットワーク上のすべてのコンピュータの時刻を同期させておけば、異なるマシン間でログからの情報を相互参照しやすくなります。従って、攻撃を受けた際に不正アクセスを受けた複数のマシンで時系列順に操作を再構成することが簡単になります。時刻が同期されていなかった場合、統計目的で複数のマシンからデータを集めても、意味を成しません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> NTP"
msgstr "<emphasis>BACK TO BASICS</emphasis> NTP"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>NTP</primary>"
msgstr "<primary>NTP</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Network</primary><secondary>Time Protocol</secondary>"
msgstr "<primary>Network</primary><secondary>Time Protocol</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "NTP (Network Time Protocol) allows a machine to synchronize with others fairly accurately, taking into consideration the delays induced by the transfer of information over the network and other possible offsets."
msgstr "NTP (Network Time Protocol) を使うことで、あるマシンが他のマシンとかなり正確に時刻同期することが可能になります。ここで正確とは NTP がネットワーク上で情報を移動することで起こる遅延および予想される補正を考慮しているという意味です。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: http://www.pool.ntp.org/ja/zone/jp;
# Tag: LOCD;
msgid "While there are numerous NTP servers on the Internet, the more popular ones may be overloaded. This is why we recommend using the <emphasis>pool.ntp.org</emphasis> NTP server, which is, in reality, a group of machines that have agreed to serve as public NTP servers. You could even limit use to a sub-group specific to a country, with, for example, <emphasis>us.pool.ntp.org</emphasis> for the United States, or <emphasis>ca.pool.ntp.org</emphasis> for Canada, etc."
msgstr "インターネット上には数多くの NTP サーバがありますが、よく知られている NTP サーバは混んでいるかもしれません。このため、NTP サーバには <emphasis>pool.ntp.org</emphasis> を使うことを推奨します。実際のところ、<emphasis>pool.ntp.org</emphasis> は公開 NTP サーバとしての機能を果たすことに同意したマシン群です。さらに、国を限定したサブグループに制限することが可能です。たとえば、アメリカ合衆国は <emphasis>us.pool.ntp.org</emphasis>、日本は <emphasis>jp.pool.ntp.org</emphasis> などです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "However, if you manage a large network, it is recommended that you install your own NTP server, which will synchronize with the public servers. In this case, all the other machines on your network can use your internal NTP server instead of increasing the load on the public servers. You will also increase homogeneity with your clocks, since all the machines will be synchronized on the same source, and this source is very close in terms of network transfer times."
msgstr "しかしながら、巨大なネットワークを管理する場合、公開サーバに同期している自前の NTP サーバを用意することを推奨します。この場合、自分のネットワークに所属する他のマシンはすべて、公開サーバの負荷を増やす代わりに、内部の NTP サーバを使うことが可能です。さらにこうすることで時刻同期の均一性が高められます。なぜなら、すべてのマシンが同じ内部 NTP サーバを使って時刻同期しますし、公開 NTP サーバに比べて内部 NTP サーバのほうがネットワーク転送にかかる時間が短いからです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "For Workstations"
msgstr "ワークステーション向けの設定"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Since work stations are regularly rebooted (even if only to save energy), synchronizing them by NTP at boot is enough. To do so, simply install the <emphasis role=\"pkg\">ntpdate</emphasis> package. You can change the NTP server used if needed by modifying the <filename>/etc/default/ntpdate</filename> file."
msgstr "ワークステーションは (エネルギーを節約するためだけだったとしても) 日常的に再起動されますから、NTP と同期するのは起動時だけで十分です。これを行うには、<emphasis role=\"pkg\">ntpdate</emphasis> パッケージをインストールします。必要なら <filename>/etc/default/ntpdate</filename> ファイルを変更して NTP サーバを変更することも可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><filename>ntpdate</filename></primary>"
msgstr "<primary><filename>ntpdate</filename></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><filename>/etc/default/ntpdate</filename></primary>"
msgstr "<primary><filename>/etc/default/ntpdate</filename></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "For Servers"
msgstr "サーバ向けの設定"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Servers are only rarely rebooted, and it is very important for their system time to be correct. To permanently maintain correct time, you would install a local NTP server, a service offered in the <emphasis role=\"pkg\">ntp</emphasis> package. In its default configuration, the server will synchronize with <emphasis>pool.ntp.org</emphasis> and provide time in response to requests coming from the local network. You can configure it by editing the <filename>/etc/ntp.conf</filename> file, the most significant alteration being the NTP server to which it refers. If the network has a lot of servers, it may be interesting to have one local time server which synchronizes with the public servers and is used as a time source by the other servers of the network."
msgstr "サーバはめったに再起動されませんし、サーバのシステム時間を正確にすることはとても重要です。恒久的に正確な時間を保つためには、<emphasis role=\"pkg\">ntp</emphasis> パッケージの提供する NTP サーバをローカルにインストールするべきです。デフォルトの設定では、NTP サーバは <emphasis>pool.ntp.org</emphasis> と同期し、ローカルネットワークからの要求に対して時刻を提供します。<filename>/etc/ntp.conf</filename> ファイルを編集すれば NTP サーバを設定することも可能です。最も重大な影響をおよぼす設定項目は、この NTP サーバがどの NTP サーバを参照するかです。ネットワークに多くのサーバがある場合、公開 NTP サーバと同期するのは 1 台のローカルタイムサーバだけにして、そのローカルタイムサーバを他のサーバに対する時間ソースとして使ってみると良いかもしれません。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis role=\"pkg\">ntp</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">ntp</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>server</primary><secondary>NTP</secondary>"
msgstr "<primary>サーバ</primary><secondary>NTP</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>NTP</primary><secondary>server</secondary>"
msgstr "<primary>NTP</primary><secondary>サーバ</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>GOING FURTHER</emphasis> GPS modules and other time sources"
msgstr "<emphasis>GOING FURTHER</emphasis> GPS モジュールと他の時刻ソース"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>GPS</primary>"
msgstr "<primary>GPS</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>DCF-77</primary>"
msgstr "<primary>DCF-77</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "If time synchronization is particularly crucial to your network, it is possible to equip a server with a GPS module (which will use the time from GPS satellites) or a DCF-77 module (which will sync time with the atomic clock near Frankfurt, Germany). In this case, the configuration of the NTP server is a little more complicated, and prior consultation of the documentation is an absolute necessity."
msgstr "時刻同期がネットワークで決定的に重要な要素の場合、GPS モジュール (GPS 衛星からの時刻を使う) または DCF-77 モジュール (ドイツのフランクフルト近郊の原子時計と時刻を同期する) をサーバに装備することも可能です。この場合、NTP サーバの設定はもう少し複雑です。そのため必ず事前に文書を調査してください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Rotating Log Files"
msgstr "ログファイルの循環"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>file</primary><secondary>logs, rotation</secondary>"
msgstr "<primary>ファイル</primary><secondary>ログ、循環</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>logs</primary><secondary>files, rotation</secondary>"
msgstr "<primary>ログ</primary><secondary>ファイル、循環</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>rotation of log files</primary>"
msgstr "<primary>ログファイルの循環</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>logrotate</command></primary>"
msgstr "<primary><command>logrotate</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
# Tag: PTAL;
msgid "Log files can grow, fast, and it is necessary to archive them. The most common scheme is a rotating archive: the log file is regularly archived, and only the latest <replaceable>X</replaceable> archives are retained. <command>logrotate</command>, the program responsible for these rotations, follows directives given in the <filename>/etc/logrotate.conf</filename> file and all of the files in the <filename>/etc/logrotate.d/</filename> directory. The administrator may modify these files, if they wish to adapt the log rotation policy defined by Debian. The <citerefentry><refentrytitle>logrotate</refentrytitle> <manvolnum>1</manvolnum></citerefentry> man page describes all of the options available in these configuration files. You may want to increase the number of files retained in log rotation, or move the log files to a specific directory dedicated to archiving them rather than delete them. You could also send them by e-mail to archive them elsewhere."
msgstr "ログファイルのサイズは素早く増加しますから、ログファイルをアーカイブに保管することが必要です。これを実現する最も一般的なやり方はアーカイブを循環させることです。つまり、ログファイルは日常的にアーカイブに保管され、最新の <replaceable>X</replaceable> 個のアーカイブが保存されます。<command>logrotate</command> はログファイルの循環を担当しているプログラムであり、<filename>/etc/logrotate.conf</filename> ファイルと <filename>/etc/logrotate.d/</filename> ディレクトリ内に含まれるすべてのファイルに書かれた指示に従います。管理者が Debian の定義するログ循環ポリシーを改変したい場合、これらの設定ファイルを変更するかもしれません。<citerefentry><refentrytitle>logrotate</refentrytitle> <manvolnum>1</manvolnum></citerefentry> man ページでは、これらの設定ファイルで利用できるすべてのオプションが説明されています。ログ循環で保存されるファイルの数を増加させたかったり、削除せずにアーカイブ専用の特定のディレクトリにログファイルを移動させたいと思うかもしれません。また、電子メールでログを送信してログを別の場所にアーカイブすることも可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <command>logrotate</command> program is executed daily by the <command>cron</command> scheduling program (described in <xref linkend=\"sect.task-scheduling-cron-atd\" />)."
msgstr "<command>logrotate</command> プログラムは <command>cron</command> スケジューリングプログラム (<xref linkend=\"sect.task-scheduling-cron-atd\" />で説明されています) によって毎日実行されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Sharing Administrator Rights"
msgstr "管理者権限の共有"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>account</primary><secondary>administrator account</secondary>"
msgstr "<primary>アカウント</primary><secondary>管理者アカウント</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>root</primary>"
msgstr "<primary>root</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>sudo</command></primary>"
msgstr "<primary><command>sudo</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Frequently, several administrators work on the same network. Sharing the root passwords is not very elegant, and opens the door for abuse due to the anonymity such sharing creates. The solution to this problem is the <command>sudo</command> program, which allows certain users to execute certain commands with special rights. In the most common use case, <command>sudo</command> allows a trusted user to execute any command as root. To do so, the user simply executes <command>sudo <replaceable>command</replaceable></command> and authenticates using their personal password."
msgstr "しばしば、複数の管理者が同じネットワーク上で仕事をする場合があります。root パスワードの共有は的確なやり方ではありません。root パスワードを共有することでコマンドの実行者が隠匿されるため、root 権限を乱用される危険性が生まれます。この種の問題に対する解決策が <command>sudo</command> プログラムです。<command>sudo</command> プログラムは特定のユーザに特別な権限で特定のコマンドを実行することを可能にします。<command>sudo</command> の最も一般的な用途として、信頼できるユーザが root 権限でコマンドを実行できるようにするという用途があります。これを行うには、ユーザは単純に <command>sudo <replaceable>command</replaceable></command> を実行し、自分のパスワードを使って認証するだけです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "When installed, the <emphasis role=\"pkg\">sudo</emphasis> package gives full root rights to members of the <literal>sudo</literal> Unix group. To delegate other rights, the administrator must use the <command>visudo</command> command, which allows them to modify the <filename>/etc/sudoers</filename> configuration file (here again, this will invoke the <command>vi</command> editor, or any other editor indicated in the <varname>EDITOR</varname> environment variable). Adding a line with <literal><replaceable>username</replaceable> ALL=(ALL) ALL</literal> allows the user in question to execute any command as root."
msgstr "<emphasis role=\"pkg\">sudo</emphasis> パッケージがインストールされると、<literal>sudo</literal> Unix グループのメンバーは完全な root 権限を与えられます。他の権利を委譲するには、管理者は <command>visudo</command> コマンドを用いなければいけません。<command>visudo</command> コマンドを使うことで、管理者は <filename>/etc/sudoers</filename> 設定ファイルを変更することが可能です (繰り返しになりますが、これは <command>vi</command> エディタまたは <varname>EDITOR</varname> 環境変数で表されるその他のエディタを実行します)。<literal><replaceable>username</replaceable> ALL=(ALL) ALL</literal> のような行を追加することで、指定されたユーザは root としてコマンドを実行することが可能になります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>visudo</command></primary>"
msgstr "<primary><command>visudo</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><filename>sudoers</filename></primary>"
msgstr "<primary><filename>sudoers</filename></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><filename>/etc/sudoers</filename></primary>"
msgstr "<primary><filename>/etc/sudoers</filename></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "More sophisticated configurations allow authorization of only specific commands to specific users. All the details of the various possibilities are given in the <citerefentry><refentrytitle>sudoers</refentrytitle> <manvolnum>5</manvolnum></citerefentry> man page."
msgstr "より洗練された設定を使うことで、特定のコマンドに必要な権限を特定のユーザに与えることも可能です。設定できる要素のすべての詳細を確認するには <citerefentry><refentrytitle>sudoers</refentrytitle> <manvolnum>5</manvolnum></citerefentry> man ページをご覧ください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "List of Mount Points"
msgstr "マウントポイントのリスト"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>point, mount</primary>"
msgstr "<primary>ポイント、マウント</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>mount point</primary>"
msgstr "<primary>マウントポイント</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> Mounting and unmounting"
msgstr "<emphasis>BACK TO BASICS</emphasis> マウントとアンマウント"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "In a Unix-like system such as Debian, files are organized in a single tree-like hierarchy of directories. The <filename>/</filename> directory is called the “root directory”; all additional directories are sub-directories within this root. “Mounting” is the action of including the content of a peripheral device (often a hard drive) into the system's general file tree. As a consequence, if you use a separate hard drive to store users' personal data, this disk will have to be “mounted” in the <filename>/home/</filename> directory. The root filesystem is always mounted at boot by the kernel; other devices are often mounted later during the startup sequence or manually with the <command>mount</command> command."
msgstr "Debian などの Unix 系システムでは、ファイルはディレクトリの単一樹状階層構造でまとめられています。<filename>/</filename> ディレクトリは「ルートディレクトリ」と呼ばれています。そして、すべての追加的なディレクトリはこのルートディレクトリの中のサブディレクトリです。「マウント」とは周辺機器デバイス (通常はハードドライブ) の内容をシステムの一般的なファイルツリーに含める操作です。結果として、ユーザの個人データを保存するために別のハードドライブを使う場合、このディスクは <filename>/home/</filename> ディレクトリに「マウント」されなければいけません。ルートファイルシステムはカーネルによって起動時に常にマウントされます。そして、他のデバイスはしばしばその後に続くスタートアップシーケンス中か <command>mount</command> コマンドを使って手作業でマウントされます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>mount</command></primary>"
msgstr "<primary><command>mount</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Some removable devices are automatically mounted when connected, especially when using the GNOME, KDE or other graphical desktop environments. Others have to be mounted manually by the user. Likewise, they must be unmounted (removed from the file tree). Normal users do not usually have permission to execute the <command>mount</command> and <command>umount</command> commands. The administrator can, however, authorize these operations (independently for each mount point) by including the <literal>user</literal> option in the <filename>/etc/fstab</filename> file."
msgstr "いくつかのリムーバブルデバイスは接続時に自動的にマウントされます。特に GNOME、KDE、その他のグラフィカルデスクトップ環境を使っている場合には自動的にマウントされます。他のデバイスについてはユーザが手作業でマウントしなければいけません。同様に、アンマウント (ファイルツリーから削除) も手動で行わなければいけません。普通のユーザは通常 <command>mount</command> や <command>umount</command> コマンドを実行する権限を持っていません。しかしながら、<literal>user</literal> オプションを <filename>/etc/fstab</filename> ファイルに含めることで、管理者はユーザに (マウントポイント別に) これらの操作を行う権限を与えることも可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <command>mount</command> command can be used without arguments (it then lists all mounted filesystems). The following parameters are required to mount or unmount a device. For the complete list, please refer to the corresponding man pages, <citerefentry><refentrytitle>mount</refentrytitle> <manvolnum>8</manvolnum></citerefentry> and <citerefentry><refentrytitle>umount</refentrytitle> <manvolnum>8</manvolnum></citerefentry>. For simple cases, the syntax is simple too: for example, to mount the <filename>/dev/sdc1</filename> partition, which has an ext3 filesystem, into the <filename>/mnt/tmp/</filename> directory, you would simply run <command>mount -t ext3 /dev/sdc1 /mnt/tmp/</command>."
msgstr "<command>mount</command> コマンドは引数なしで使うことも可能です (すべてのマウントされたファイルシステムを表示します)。デバイスをマウントおよびアンマウントする場合はパラメータが必要です。すべてのパラメータを見るには、対応する man ページである <citerefentry><refentrytitle>mount</refentrytitle> <manvolnum>8</manvolnum></citerefentry> と <citerefentry><refentrytitle>umount</refentrytitle> <manvolnum>8</manvolnum></citerefentry> を参照してください。単純なマウントの場合、構文もまた単純です。たとえば、ext3 ファイルシステムの <filename>/dev/sdc1</filename> パーティションを <filename>/mnt/tmp/</filename> ディレクトリにマウントするには、<command>mount -t ext3 /dev/sdc1 /mnt/tmp/</command> のように実行してください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <filename>/etc/fstab</filename> file gives a list of all possible mounts that happen either automatically on boot or manually for removable storage devices. Each mount point is described by a line with several space-separated fields: <indexterm><primary><filename>fstab</filename></primary></indexterm> <indexterm><primary><filename>/etc/fstab</filename></primary></indexterm>"
msgstr "<filename>/etc/fstab</filename> ファイルには、起動時に自動マウントされるものやリムーバブルストレージデバイス用の手作業でマウントするものを含めて、すべての考え得るマウントポイントがリストされています。それぞれのマウントポイントは空白区切りフィールドを持つ各行によって表現されます。<indexterm><primary><filename>fstab</filename></primary></indexterm><indexterm><primary><filename>/etc/fstab</filename></primary></indexterm>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "device to mount: this can be a local partition (hard drive, CD-ROM) or a remote filesystem (such as NFS)."
msgstr "マウントするデバイス。このフィールドにはローカルパーティション (ハードドライブ、CD-ROM) またはリモートファイルシステム (NFS など) を指定します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "This field is frequently replaced with the unique ID of the filesystem (which you can determine with <command>blkid <userinput>device</userinput></command>) prefixed with <literal>UUID=</literal>. This guards against a change in the name of the device in the event of addition or removal of disks, or if disks are detected in a different order."
msgstr "このフィールドではしばしば、<literal>UUID=</literal> を前に付けたファイルシステムの一意的な ID が使われることがあります (ID は <command>blkid <userinput>device</userinput></command> を使えばわかります)。一意的な ID を使うことで、ディスクを取り付けたり取り外したことや異なる順番でディスクが検出されたことによりデバイスの名前が変わっても問題がなくなります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "mount point: this is the location on the local filesystem where the device, remote system, or partition will be mounted."
msgstr "マウントポイント。このフィールドではデバイス、リモートシステム、パーティションがマウントされるローカルファイルシステムの場所を指定します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "type: this field defines the filesystem used on the mounted device. <literal>ext4</literal>, <literal>ext3</literal>, <literal>vfat</literal>, <literal>ntfs</literal>, <literal>btrfs</literal>, <literal>xfs</literal> are a few examples."
msgstr "ファイルシステムタイプ。このフィールドではマウントされたデバイスで使われているファイルシステムを定義します。<literal>ext4</literal>、<literal>ext3</literal>、<literal>vfat</literal>、<literal>ntfs</literal>、<literal>btrfs</literal>、<literal>xfs</literal> などがその例です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>BACK TO BASICS</emphasis> NFS, a network filesystem"
msgstr "<emphasis>BACK TO BASICS</emphasis> NFS、ネットワークファイルシステム"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "NFS is a network filesystem; under Linux, it allows transparent access to remote files by including them in the local filesystem."
msgstr "NFS はネットワークファイルシステムです。Linux の下では、NFS を使ってローカルファイルシステムにリモートファイルを含めることにより、リモートファイルへの透過的なアクセスが可能になります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "A complete list of known filesystems is available in the <citerefentry><refentrytitle>mount</refentrytitle> <manvolnum>8</manvolnum></citerefentry> man page. The <literal>swap</literal> special value is for swap partitions; the <literal>auto</literal> special value tells the <command>mount</command> program to automatically detect the filesystem (which is especially useful for disk readers and USB keys, since each one might have a different filesystem);"
msgstr "既知のファイルシステムの完全なリストは <citerefentry><refentrytitle>mount</refentrytitle> <manvolnum>8</manvolnum></citerefentry> man ページに書かれています。<literal>swap</literal> は swap パーティション専用の特殊値です。そして <literal>auto</literal> は <command>mount</command> プログラムに自動的にファイルシステムを検出させるための特殊値です (この値はディスクリーダと USB メモリで特に便利です。なぜなら、機器ごとに異なるファイルシステムを使っている可能性があるからです)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "options: there are many of them, depending on the filesystem, and they are documented in the <command>mount</command> man page. The most common are"
msgstr "オプション。ファイルシステムごとに多くのオプションがあり、これらの値は <command>mount</command> man ページに書かれています。最もよく使われるものを以下に挙げます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>rw</literal> or <literal>ro</literal>, meaning, respectively, that the device will be mounted with read/write or read-only permissions."
msgstr "<literal>rw</literal> または <literal>ro</literal>。これはデバイスが読み書き可能状態または読み取り専用でマウントされることを意味しています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>noauto</literal> deactivates automatic mounting on boot."
msgstr "<literal>noauto</literal>。これは起動時の自動マウントを無効化します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>nofail</literal> allows the boot to proceed even when the device is not present. Make sure to put this option for external drives that might be unplugged when you boot, because <command>systemd</command> really ensures that all mount points that must be automatically mounted are actually mounted before letting the boot process continue to its end. Note that you can combine this with <literal>x-systemd.device-timeout=5s</literal> to tell <command>systemd</command> to not wait more than 5 seconds for the device to appear (see <citerefentry><refentrytitle>systemd.mount</refentrytitle><manvolnum>5</manvolnum></citerefentry>)."
msgstr "<literal>nofail</literal>。<literal>nofail</literal> オプションを使えば、デバイスが見つからなかった場合にも起動処理が中断されなくなります。<literal>nofail</literal> オプションを使うデバイスは起動中に取り外されている可能性のある外付けドライブ上のデバイスだけにしてください。なぜなら、<command>systemd</command> は起動処理を続行する前に自動的にマウントされなければならないすべてのマウントポイントが実際にマウントされていることを確認するからです。<literal>nofail</literal> オプションは <literal>x-systemd.device-timeout=5s</literal> オプションと併用することが可能であるという点に注意してください。両者を併用することで、<command>systemd</command> は 5 秒間だけデバイスを探索し、その後起動処理を続行するようになります (<citerefentry><refentrytitle>systemd.mount</refentrytitle><manvolnum>5</manvolnum></citerefentry> を参照してください)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>user</literal> authorizes all users to mount this filesystem (an operation which would otherwise be restricted to the root user)."
msgstr "<literal>user</literal>。<literal>user</literal> オプションを使うことですべてのユーザが対象のファイルシステムをマウント可能になります (<literal>user</literal> オプションを指定しなければ、マウントおよびアンマウント操作をできるのは root ユーザだけに限られます)。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<literal>defaults</literal> means the group of default options: <literal>rw</literal>, <literal>suid</literal>, <literal>dev</literal>, <literal>exec</literal>, <literal>auto</literal>, <literal>nouser</literal> and <literal>async</literal>, each of which can be individually disabled after <literal>defaults</literal> by adding <literal>nosuid</literal>, <literal>nodev</literal> and so on to block <literal>suid</literal>, <literal>dev</literal> and so on. Adding the <literal>user</literal> option reactivates it, since <literal>defaults</literal> includes <literal>nouser</literal>."
msgstr "<literal>defaults</literal>。<literal>defaults</literal> オプションを使うとデフォルトオプション群を指定したことになります。デフォルトオプション群とは <literal>rw</literal>、<literal>suid</literal>、<literal>dev</literal>、<literal>exec</literal>、<literal>auto</literal>、<literal>nouser</literal>、<literal>async</literal> です。<literal>defaults</literal> の後に <literal>nosuid</literal>、<literal>nodev</literal> などを付ければ、<literal>suid</literal>、<literal>dev</literal> をブロックし、これらのオプションを無効化することも可能です。<literal>user</literal> オプションを追加すればこれが再有効化されます。なぜなら <literal>defaults</literal> は <literal>nouser</literal> を含むからです。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: https://wiki.debian.org/fstab;
msgid "backup: this field is almost always set to <literal>0</literal>. When it is <literal>1</literal>, it tells the <command>dump</command> tool that the partition contains data that is to be backed up."
msgstr "バックアップ。このフィールドにはほぼ必ず <literal>0</literal> を設定します。<literal>1</literal> を設定した場合、<command>dump</command> ツールに対してこのパーティションにはバックアップされるデータが含まれることが伝えられます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "check order: this last field indicates whether the integrity of the filesystem should be checked on boot, and in which order this check should be executed. If it is <literal>0</literal>, no check is conducted. The root filesystem should have the value <literal>1</literal>, while other permanent filesystems get the value <literal>2</literal>."
msgstr "ファイルシステムのチェック順。このフィールドは起動時にファイルシステムの完全性がチェックされるか否かと、チェックが実行される順番を意味します。<literal>0</literal> の場合、完全性はチェックされません。ルートファイルシステムに対しては <literal>1</literal> を設定するべきです。他の恒久的なファイルシステムに対しては <literal>2</literal> を設定するべきです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Example <filename>/etc/fstab</filename> file"
msgstr "<filename>/etc/fstab</filename> ファイルの例"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"# /etc/fstab: static file system information.\n"
"#\n"
"# &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;\n"
"proc            /proc           proc    defaults        0       0\n"
"# / was on /dev/sda1 during installation\n"
"UUID=c964222e-6af1-4985-be04-19d7c764d0a7 / ext3 errors=remount-ro 0 1\n"
"# swap was on /dev/sda5 during installation\n"
"UUID=ee880013-0f63-4251-b5c6-b771f53bd90e none swap sw  0       0\n"
"/dev/scd0       /media/cdrom0   udf,iso9660 user,noauto 0       0\n"
"/dev/fd0        /media/floppy   auto    rw,user,noauto  0       0\n"
"arrakis:/shared /shared         nfs     defaults        0       0"
msgstr ""
"\n"
"# /etc/fstab: 固定ファイルシステムの情報。\n"
"#\n"
"# &lt;ファイルシステム&gt; &lt;マウントポイント&gt; &lt;タイプ&gt; &lt;オプション&gt; &lt;ダンプ&gt; &lt;チェック順&gt;\n"
"proc            /proc           proc    defaults        0       0\n"
"# インストール中に / は /dev/sda1 にありました\n"
"UUID=c964222e-6af1-4985-be04-19d7c764d0a7 / ext3 errors=remount-ro 0 1\n"
"# インストール中に swap は /dev/sda5 にありました\n"
"UUID=ee880013-0f63-4251-b5c6-b771f53bd90e none swap sw  0       0\n"
"/dev/scd0       /media/cdrom0   udf,iso9660 user,noauto 0       0\n"
"/dev/fd0        /media/floppy   auto    rw,user,noauto  0       0\n"
"arrakis:/shared /shared         nfs     defaults        0       0"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The last entry in this example corresponds to a network filesystem (NFS): the <filename>/shared/</filename> directory on the <emphasis>arrakis</emphasis> server is mounted at <filename>/shared/</filename> on the local machine. The format of the <filename>/etc/fstab</filename> file is documented on the <citerefentry><refentrytitle>fstab</refentrytitle><manvolnum>5</manvolnum></citerefentry> man page."
msgstr "この例の最後のエントリはネットワークファイルシステム (NFS) を表しています。すなわち <emphasis>arrakis</emphasis> サーバの <filename>/shared/</filename> ディレクトリがローカルマシンの <filename>/shared/</filename> にマウントされます。<filename>/etc/fstab</filename> ファイルのフォーマットは <citerefentry><refentrytitle>fstab</refentrytitle><manvolnum>5</manvolnum></citerefentry> man ページに書かれています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>GOING FURTHER</emphasis> Auto-mounting"
msgstr "<emphasis>GOING FURTHER</emphasis> 自動マウント"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <emphasis>am-utils</emphasis> package provides the <command>amd</command> auto-mounting utility, able to mount removable media on demand when a user attempts to access their usual mount point. It will unmount these devices when no process is accessing them any longer."
msgstr "<emphasis>am-utils</emphasis> パッケージは <command>amd</command> 自動マウントユーティリティを提供します。<command>amd</command> ユーティリティを使うと、通常のマウントポイントを通じてリムーバブルメディアにアクセスすれば、リムーバブルメディアをマウントできます。<command>amd</command> はリムーバブルメディアにアクセスしているプロセスがなくなればそのメディアをアンマウントします。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis>am-utils</emphasis></primary>"
msgstr "<primary><emphasis>am-utils</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>amd</command></primary>"
msgstr "<primary><command>amd</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>automount</command></primary>"
msgstr "<primary><command>automount</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis>autofs</emphasis></primary>"
msgstr "<primary><emphasis>autofs</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>automounter</primary>"
msgstr "<primary>自動マウントユーティリティ</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Other auto-mounting utilities exist, such as <command>automount</command> in the <emphasis>autofs</emphasis> package."
msgstr "他の自動マウントユーティリティも存在します。たとえば <emphasis>autofs</emphasis> パッケージに含まれる <command>automount</command> です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Note also that GNOME, KDE, and other graphical desktop environments work together with <emphasis>udisks</emphasis>, and can automatically mount removable media when they are connected."
msgstr "GNOME、KDE、その他のグラフィカルデスクトップ環境は <emphasis>udisks</emphasis> と協調して、リムーバブルメディアが接続されたらそれを自動的にマウントします。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<command>locate</command> and <command>updatedb</command>"
msgstr "<command>locate</command> と <command>updatedb</command>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>locate</command></primary>"
msgstr "<primary><command>locate</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>updatedb</command></primary>"
msgstr "<primary><command>updatedb</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>mlocate</command></primary>"
msgstr "<primary><command>mlocate</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The <command>locate</command> command can find the location of a file when you only know part of the name. It sends a result almost instantaneously, since it consults a database that stores the location of all the files on the system; this database is updated daily by the <command>updatedb</command> command. There are multiple implementations of the <command>locate</command> command and Debian picked <emphasis role=\"pkg\">mlocate</emphasis> for its standard system."
msgstr "<command>locate</command> コマンドを使うと、名前の一部を知っているだけのファイルの場所を見つけ出すことが可能です。結果はほぼ一瞬で返されます。なぜなら <command>locate</command> コマンドはシステムのファイルのすべての場所を保存するデータベースを参照しているからです。さらにこのデータベースは <command>updatedb</command> コマンドを使って毎日更新されます。<command>locate</command> コマンドには複数の実装があり、Debian は標準的なシステム向けに <emphasis role=\"pkg\">mlocate</emphasis> を選んでいます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<command>mlocate</command> is smart enough to only return files which are accessible to the user running the command even though it uses a database that knows about all files on the system (since its <command>updatedb</command> implementation runs with root rights). For extra safety, the administrator can use <varname>PRUNEDPATHS</varname> in <filename>/etc/updatedb.conf</filename> to exclude some directories from being indexed."
msgstr "<command>mlocate</command> は賢明なので、システムのすべてのファイルについて知っているデータベースを使っている (なぜなら、<command>mlocate</command> の <command>updatedb</command> 実装は root 権限で実行されるからです) にも関わらず、コマンドを実行したユーザがアクセスできるファイルだけを返します。さらなる安全性のために、管理者は <filename>/etc/updatedb.conf</filename> の中で <varname>PRUNEDPATHS</varname> を使って、いくつかのディレクトリのインデックス化を避けることが可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Compiling a Kernel"
msgstr "カーネルのコンパイル"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>compilation</primary><secondary>of a kernel</secondary>"
msgstr "<primary>コンパイル</primary><secondary>カーネルのコンパイル</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>kernel</primary><secondary>compilation</secondary>"
msgstr "<primary>カーネル</primary><secondary>コンパイル</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: http://www.ibm.com/developerworks/library/l-kernel-memory-access/;
# Tag: PTAL;
msgid "The kernels provided by Debian include the largest possible number of features, as well as the maximum of drivers, in order to cover the broadest spectrum of existing hardware configurations. This is why some users prefer to recompile the kernel in order to only include what they specifically need. There are two reasons for this choice. First, it may be to optimize memory consumption, since the kernel code, even if it is never used, occupies memory for nothing (and never “goes down” on the swap space, since it is actual RAM that it uses), which can decrease overall system performance. A locally compiled kernel can also limit the risk of security problems since only a fraction of the kernel code is compiled and run."
msgstr "Debian の提供するカーネルは、既存のハードウェア構成の広い領域をカバーするために、できる限り多くの機能およびドライバを組み込んでいます。このため、一部のユーザにとっては本当に必要なものだけを含める目的でカーネルを再コンパイルするほうが良い場合もあります。カーネルを再コンパイルする理由は 2 つあります。1 つ目は、メモリ消費量を最適化できるかもしれないからです。全く使われないカーネルコードは無駄にメモリを専有するため (カーネルコードは決してスワップ領域に「移動」されません。なぜなら、カーネルコードがスワップ用の RAM 領域を管理しているからです)、システム全体のパフォーマンスを低下させます。2 つ目は、カーネルを自前でコンパイルすればカーネルコードのごく一部をコンパイルして実行することになり、セキュリティ問題の危険性を限定することが可能だからです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>NOTE</emphasis> Security updates"
msgstr "<emphasis>NOTE</emphasis> セキュリティ更新"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "If you choose to compile your own kernel, you must accept the consequences: Debian cannot ensure security updates for your custom kernel. By keeping the kernel provided by Debian, you benefit from updates prepared by the Debian Project's security team."
msgstr "自前でカーネルをコンパイルする場合、以下の点に同意しなければいけません。それは、Debian は自前でコンパイルしたカスタムカーネルに対するセキュリティ更新を保証できないという点です。Debian が提供するカーネルを使うことにすれば、Debian プロジェクトのセキュリティチームが用意した更新の恩恵を受けることができます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Recompilation of the kernel is also necessary if you want to use certain features that are only available as patches (and not included in the standard kernel version)."
msgstr "さらに、パッチの形でしか供給されていない (標準的なカーネルのバージョンに含まれていない) 特定の機能を使いたい場合もカーネルの再コンパイルが必要です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>GOING FURTHER</emphasis> The Debian Kernel Handbook"
msgstr "<emphasis>GOING FURTHER</emphasis> Debian カーネルハンドブック"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis role=\"pkg\">debian-kernel-handbook</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">debian-kernel-handbook</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The Debian kernel teams maintains the “Debian Kernel Handbook” (also available in the <emphasis role=\"pkg\">debian-kernel-handbook</emphasis> package) with comprehensive documentation about most kernel related tasks and about how official Debian kernel packages are handled. This is the first place you should look into if you need more information than what is provided in this section. <ulink type=\"block\" url=\"http://kernel-handbook.alioth.debian.org\" />"
msgstr "Debian カーネルチームは「Debian カーネルハンドブック」をメンテナンスしています (「Debian カーネルハンドブック」は <emphasis role=\"pkg\">debian-kernel-handbook</emphasis> パッケージからも入手できます)。「Debian カーネルハンドブック」ではカーネルに関連する多くの作業と公式 Debian カーネルパッケージの取り扱い方法が包括的に説明されています。「Debian カーネルハンドブック」はこの節で提供される情報よりも詳しい情報が必要になった場合に最初に調べるべき文書です。<ulink type=\"block\" url=\"http://kernel-handbook.alioth.debian.org\" />"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Introduction and Prerequisites"
msgstr "前置きと前提条件"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Unsurprisingly Debian manages the kernel in the form of a package, which is not how kernels have traditionally been compiled and installed. Since the kernel remains under the control of the packaging system, it can then be removed cleanly, or deployed on several machines. Furthermore, the scripts associated with these packages automate the interaction with the bootloader and the initrd generator."
msgstr "当然ながら、Debian はパッケージの形でカーネルを管理します。このやり方はカーネルをコンパイルおよびインストールする伝統的な方法とは異なります。しかしながら、カーネルをパッケージングシステムの制御下に置くことで、カーネルを完全に削除したり複数のマシンに配備したりすることが可能になります。さらに、カーネルのパッケージに関連付けられたスクリプトのおかげで、ブートローダと initrd ジェネレータとの連動が自動化されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The upstream Linux sources contain everything needed to build a Debian package of the kernel. But you still need to install <emphasis role=\"pkg\">build-essential</emphasis> to ensure that you have the tools required to build a Debian package. Furthermore, the configuration step for the kernel requires the <emphasis role=\"pkg\">libncurses5-dev</emphasis> package. Finally, the <emphasis role=\"pkg\">fakeroot</emphasis> package will enable creation of the Debian package without using administrator's rights."
msgstr "上流開発の Linux ソースには、カーネルの Debian パッケージをビルドするために必要な要素のすべてが含まれています。しかし、Debian パッケージをビルドするのに必要なツールを確実にそろえるためには <emphasis role=\"pkg\">build-essential</emphasis> のインストールも必要です。さらに、カーネルを設定するためには <emphasis role=\"pkg\">libncurses5-dev</emphasis> パッケージも必要です。最後に、<emphasis role=\"pkg\">fakeroot</emphasis> パッケージを使えば管理者権限を使わずに Debian パッケージを作成することも可能になります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>CULTURE</emphasis> The good old days of <emphasis role=\"pkg\">kernel-package</emphasis>"
msgstr "<emphasis>CULTURE</emphasis> <emphasis role=\"pkg\">kernel-package</emphasis> の古き良き時代"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis role=\"pkg\">kernel-package</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">kernel-package</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Before the Linux build system gained the ability to build proper Debian packages, the recommended way to build such packages was to use <command>make-kpkg</command> from the <emphasis role=\"pkg\">kernel-package</emphasis> package."
msgstr "Linux ビルドシステムに適切な Debian パッケージをビルドする能力がなかった時代、Debian パッケージをビルドするのに推奨されていた方法は <emphasis role=\"pkg\">kernel-package</emphasis> パッケージに含まれる <command>make-kpkg</command> を使うやり方でした。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Getting the Sources"
msgstr "ソースの取得"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>Linux kernel sources</primary>"
msgstr "<primary>Linux カーネルソース</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>kernel</primary><secondary>sources</secondary>"
msgstr "<primary>カーネル</primary><secondary>ソース</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>source</primary><secondary>of the Linux kernel</secondary>"
msgstr "<primary>ソース</primary><secondary>Linux カーネルのソース</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Like anything that can be useful on a Debian system, the Linux kernel sources are available in a package. To retrieve them, just install the <emphasis role=\"pkg\">linux-source-<replaceable>version</replaceable></emphasis> package. The <command>apt-cache search ^linux-source</command> command lists the various kernel versions packaged by Debian. The latest version is available in the <emphasis role=\"distribution\">Unstable</emphasis> distribution: you can retrieve them without much risk (especially if your APT is configured according to the instructions of <xref linkend=\"sect.apt-mix-distros\" />). Note that the source code contained in these packages does not correspond precisely with that published by Linus Torvalds and the kernel developers; like all distributions, Debian applies a number of patches, which might (or might not) find their way into the upstream version of Linux. These modifications include backports of fixes/features/drivers from newer kernel versions, new features not yet (entirely) merged in the upstream Linux tree, and sometimes even Debian specific changes."
msgstr "Debian システム上で便利に使えるプログラムと同様に、Linux カーネルソースはパッケージとして提供されています。Linux カーネルソースを手に入れるには、<emphasis role=\"pkg\">linux-source-<replaceable>version</replaceable></emphasis> パッケージをインストールしてください。Debian がパッケージングしたカーネルのさまざまなバージョンを確認するには <command>apt-cache search ^linux-source</command> コマンドを使ってください。最新のバージョンは<emphasis role=\"distribution\">不安定版</emphasis>ディストリビューションに含まれています。すなわち、大して危険性を伴わずにカーネルの最新バージョンを入手できます (特に APT が<xref linkend=\"sect.apt-mix-distros\" />の説明に従って設定されている場合、大きな危険性はないと言えます)。Debian のカーネルソースパッケージに含まれるソースコードは Linus Torvalds とカーネル開発者が公開したソースコードと全く同じものではないという点に注意してください。すべてのディストリビューションと同様に、Debian もまたカーネルソースに数多くのパッチを適用します。このパッチは今後 Linux の上流開発版に取り込まれるかもしれません (取り込まれない場合もあります)。これらの変更には新しいカーネルバージョンに追加された修正/機能/ドライバのバックポート、まだ上流開発の Linux ツリーに (完全に) マージされていない新機能、場合によっては Debian 特有の変更が含まれます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The remainder of this section focuses on the 3.16 version of the Linux kernel, but the examples can, of course, be adapted to the particular version of the kernel that you want."
msgstr "この節のこれ以降の説明では、Linux カーネルのバージョン 3.16 を例に挙げます。しかしながら、この例はもちろん他のカーネルの特定のバージョンにも適用できます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "We assume the <emphasis role=\"pkg\">linux-source-3.16</emphasis> package has been installed. It contains <filename>/usr/src/linux-source-3.16.tar.xz</filename>, a compressed archive of the kernel sources. You must extract these files in a new directory (not directly under <filename>/usr/src/</filename>, since there is no need for special permissions to compile a Linux kernel): <filename>~/kernel/</filename> is appropriate."
msgstr "<emphasis role=\"pkg\">linux-source-3.16</emphasis> パッケージがインストール済みと仮定します。<emphasis role=\"pkg\">linux-source-3.16</emphasis> パッケージには、カーネルソースの圧縮アーカイブである <filename>/usr/src/linux-source-3.16.tar.xz</filename> が含まれます。この圧縮アーカイブを新しいディレクトリに展開してください (<filename>/usr/src/</filename> の下のディレクトリに展開しないよう注意してください。なぜなら、Linux カーネルをコンパイルするのに特別なパーミッションは必要ないからです)。すなわち <filename>~/kernel/</filename> に展開することが適切です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>mkdir ~/kernel; cd ~/kernel</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>tar -xaf /usr/src/linux-source-3.16.tar.xz</userinput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>mkdir ~/kernel; cd ~/kernel</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>tar -xaf /usr/src/linux-source-3.16.tar.xz</userinput>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>CULTURE</emphasis> Location of kernel sources"
msgstr "<emphasis>CULTURE</emphasis> カーネルソースの場所"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Traditionally, Linux kernel sources would be placed in <filename>/usr/src/linux/</filename> thus requiring root permissions for compilation. However, working with administrator rights should be avoided when not needed. There is a <literal>src</literal> group that allows members to work in this directory, but working in <filename>/usr/src/</filename> should be avoided nevertheless. By keeping the kernel sources in a personal directory, you get security on all counts: no files in <filename>/usr/</filename> unknown to the packaging system, and no risk of misleading programs that read <filename>/usr/src/linux</filename> when trying to gather information on the used kernel."
msgstr "伝統的に、Linux カーネルソースは <filename>/usr/src/linux/</filename> に置かれているので、カーネルをコンパイルするには root 権限が必要です。しかしながら、その必要がないにも関わらず管理者権限を使って作業するべきではありません。<literal>src</literal> グループのメンバーは <filename>/usr/src/</filename> ディレクトリの中で作業することを許されていますが、それでもなおこのディレクトリの中で作業するべきではありません。カーネルソースを個人ディレクトリに置けば、あらゆる点でセキュリティを確保できます。つまり <filename>/usr/</filename> 以下に存在するファイルはパッケージングシステムの知っているファイルだけになりますし、使用中のカーネルの情報を収集しようとして <filename>/usr/src/linux</filename> を読むプログラムを間違った方向に導く危険性もなくなります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Configuring the Kernel"
msgstr "カーネルの設定"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>kernel</primary><secondary>configuration</secondary>"
msgstr "<primary>カーネル</primary><secondary>設定</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>configuration</primary><secondary>of the kernel</secondary>"
msgstr "<primary>設定</primary><secondary>カーネルの設定</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><filename>.config</filename></primary>"
msgstr "<primary><filename>.config</filename></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The next step consists of configuring the kernel according to your needs. The exact procedure depends on the goals."
msgstr "次の段階で、必要性に応じてカーネルを設定します。完全な手順はその目標に依存します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "When recompiling a more recent version of the kernel (possibly with an additional patch), the configuration will most likely be kept as close as possible to that proposed by Debian. In this case, and rather than reconfiguring everything from scratch, it is sufficient to copy the <filename>/boot/config-<replaceable>version</replaceable></filename> file (the version is that of the kernel currently used, which can be found with the <command>uname -r</command> command) into a <filename>.config</filename> file in the directory containing the kernel sources."
msgstr "より最近のカーネルのバージョンを再コンパイルする場合 (おそらく追加的パッチを適用する場合)、その設定は Debian の提案する設定と可能な限り似たものになるでしょう。この場合、すべてを最初から再設定するのではなく、<filename>/boot/config-<replaceable>version</replaceable></filename> ファイル (ここで version は現在使っているカーネルで、<command>uname -r</command> コマンドでわかります) をカーネルソースに含まれるディレクトリ内の <filename>.config</filename> ファイルにコピーするだけで十分です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>cp /boot/config-3.16.0-4-amd64 ~/kernel/linux-source-3.16/.config</userinput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>cp /boot/config-3.16.0-4-amd64 ~/kernel/linux-source-3.16/.config</userinput>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Unless you need to change the configuration, you can stop here and skip to <xref linkend=\"sect.kernel-build\" />. If you need to change it, on the other hand, or if you decide to reconfigure everything from scratch, you must take the time to configure your kernel. There are various dedicated interfaces in the kernel source directory that can be used by calling the <command>make <replaceable>target</replaceable></command> command, where <replaceable>target</replaceable> is one of the values described below."
msgstr "設定を変更する必要がなければ、ここまでで止めて<xref linkend=\"sect.kernel-build\" />に進むことも可能です。一方で、設定を変更する必要があったり最初からすべてを再設定する場合、時間をかけてカーネルを設定しなければいけません。カーネルソースディレクトリには <command>make <replaceable>target</replaceable></command> コマンドを呼び出して使うさまざまな専用のインターフェースがあります。ここで <replaceable>target</replaceable> は以下に説明するものの 1 つです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<command>make menuconfig</command> compiles and executes a text-mode interface (this is where the <emphasis role=\"pkg\">libncurses5-dev</emphasis> package is required) which allows navigating the options available in a hierarchical structure. Pressing the <keycap>Space</keycap> key changes the value of the selected option, and <keycap>Enter</keycap> validates the button selected at the bottom of the screen; <guibutton>Select</guibutton> returns to the selected sub-menu; <guibutton>Exit</guibutton> closes the current screen and moves back up in the hierarchy; <guibutton>Help</guibutton> will display more detailed information on the role of the selected option. The arrow keys allow moving within the list of options and buttons. To exit the configuration program, choose <guibutton>Exit</guibutton> from the main menu. The program then offers to save the changes you've made; accept if you are satisfied with your choices."
msgstr "<command>make menuconfig</command> は階層構造でオプションを案内するテキストモードインターフェースをコンパイルして実行します (コンパイルおよび実行には <emphasis role=\"pkg\">libncurses5-dev</emphasis> パッケージが必要です)。<keycap>Space</keycap> キーで選択されたオプションの値を変更します。<keycap>Enter</keycap> キーで画面の下部にある選択状態のボタンを押します。さらに <guibutton>Select</guibutton> ボタンで選択されたサブメニューを返します。さらに <guibutton>Exit</guibutton> ボタンで現在の画面を閉じて階層を一段階上に戻ります。さらに <guibutton>Help</guibutton> ボタンで選択されたオプションの役割に関するより詳細な情報を表示します。矢印キーでオプションリストとボタンの間を移動します。設定プログラムを終了するには、メインメニューから <guibutton>Exit</guibutton> ボタンを選択してください。すると、このプログラムは変更を保存するよう提案します。そして変更内容に満足したら、保存してください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Other interfaces have similar features, but they work within more modern graphical interfaces; such as <command>make xconfig</command> which uses a Qt graphical interface, and <command>make gconfig</command> which uses GTK+. The former requires <emphasis role=\"pkg\">libqt4-dev</emphasis>, while the latter depends on <emphasis role=\"pkg\">libglade2-dev</emphasis> and <emphasis role=\"pkg\">libgtk2.0-dev</emphasis>."
msgstr "他のインターフェースも同様の機能を持っていますが、より現代的なグラフィカルインターフェースで機能します。<command>make xconfig</command> は Qt グラフィカルインターフェース、<command>make gconfig</command> は GTK+ を使います。<command>make xconfig</command> には <emphasis role=\"pkg\">libqt4-dev</emphasis> が必要で、<command>make gconfig</command> には <emphasis role=\"pkg\">libglade2-dev</emphasis> と <emphasis role=\"pkg\">libgtk2.0-dev</emphasis> が必要です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "When using one of those configuration interfaces, it is always a good idea to start from a reasonable default configuration. The kernel provides such configurations in <filename>arch/<replaceable>arch</replaceable>/configs/*_defconfig</filename> and you can put your selected configuration in place with a command like <command>make x86_64_defconfig</command> (in the case of a 64-bit PC) or <command>make i386_defconfig</command> (in the case of a 32-bit PC)."
msgstr "これらの設定インターフェースのうち 1 つを使う場合、合理的なデフォルト設定から始めるのが良いアイディアです。カーネルのデフォルト設定は <filename>arch/<replaceable>arch</replaceable>/configs/*_defconfig</filename> に置かれています。この設定ファイルを適切な場所に置くには、<command>make x86_64_defconfig</command> (64 ビット PC の場合) や <command>make i386_defconfig</command> (32 ビット PC の場合) などのコマンドを使います。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>TIP</emphasis> Dealing with outdated <filename>.config</filename> files"
msgstr "<emphasis>TIP</emphasis> 古い <filename>.config</filename> ファイルに対処する"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "When you provide a <filename>.config</filename> file that has been generated with another (usually older) kernel version, you will have to update it. You can do so with <command>make oldconfig</command>, it will interactively ask you the questions corresponding to the new configuration options. If you want to use the default answer to all those questions you can use <command>make olddefconfig</command>. With <command>make oldnoconfig</command>, it will assume a negative answer to all questions."
msgstr "他の (通常古い) カーネルバージョンで生成された <filename>.config</filename> ファイルを使う場合、内容を更新しなければいけません。内容を更新するには <command>make oldconfig</command> を使います。このコマンドは新しい設定オプションに関する質問を対話的に尋ねます。すべての質問に対してデフォルトの答えを使う場合、<command>make olddefconfig</command> を使ってください。すべての質問にデフォルトと反対の答えを使う場合、<command>make oldnoconfig</command> を使ってください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Compiling and Building the Package"
msgstr "パッケージのコンパイルとビルド"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>make deb-pkg</command></primary>"
msgstr "<primary><command>make deb-pkg</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>NOTE</emphasis> Clean up before rebuilding"
msgstr "<emphasis>NOTE</emphasis> 再ビルド前の片付け"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "If you have already compiled once in the directory and wish to rebuild everything from scratch (for example because you substantially changed the kernel configuration), you will have to run <command>make clean</command> to remove the compiled files. <command>make distclean</command> removes even more generated files, including your <filename>.config</filename> file too, so make sure to backup it first."
msgstr "既にそのディレクトリの中で 1 回コンパイルした状態で、(たとえばカーネル設定を大幅に変更したなどの理由で) すべてを最初から再ビルドしたい場合、<command>make clean</command> を実行してコンパイル済みファイルを削除しなければいけません。<command>make distclean</command> はさらに生成されたファイルも削除します。この中には <filename>.config</filename> ファイルも含まれますので、忘れずにバックアップしてください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Once the kernel configuration is ready, a simple <command>make deb-pkg</command> will generate up to 5 Debian packages: <emphasis role=\"pkg\">linux-image-<replaceable>version</replaceable></emphasis> that contains the kernel image and the associated modules, <emphasis role=\"pkg\">linux-headers-<replaceable>version</replaceable></emphasis> which contains the header files required to build external modules, <emphasis role=\"pkg\">linux-firmware-image-<replaceable>version</replaceable></emphasis> which contains the firmware files needed by some drivers (this package might be missing when you build from the kernel sources provided by Debian), <emphasis role=\"pkg\">linux-image-<replaceable>version</replaceable>-dbg</emphasis> which contains the debugging symbols for the kernel image and its modules, and <emphasis role=\"pkg\">linux-libc-dev</emphasis> which contains headers relevant to some user-space libraries like GNU glibc."
msgstr "カーネル設定の準備が完了したら、<command>make deb-pkg</command> で 5 つの Debian パッケージが生成されます。具体的に言えば、カーネルイメージと関連モジュールを含む <emphasis role=\"pkg\">linux-image-<replaceable>version</replaceable></emphasis>、外部モジュールのビルドに必要なヘッダファイルを含む <emphasis role=\"pkg\">linux-headers-<replaceable>version</replaceable></emphasis>、一部のドライバから要求されるファームウェアファイルを含む <emphasis role=\"pkg\">linux-firmware-image-<replaceable>version</replaceable></emphasis> (Debian の配布しているカーネルソースからカーネルをビルドする場合、このパッケージは生成されないかもしれません)、カーネルイメージとモジュールのデバッグシンボルを含む <emphasis role=\"pkg\">linux-image-<replaceable>version</replaceable>-dbg</emphasis>、GNU glibc などのユーザ空間ライブラリに関連するヘッダを含む <emphasis role=\"pkg\">linux-libc-dev</emphasis> が生成されます。"

# Checked-By: Ryuunosuke Ayanokouzi;
# Ref: $ less ./linux-source-3.16/README;
# Tag: PTAL;
msgid "The <replaceable>version</replaceable> is defined by the concatenation of the upstream version (as defined by the variables <literal>VERSION</literal>, <literal>PATCHLEVEL</literal>, <literal>SUBLEVEL</literal> and <literal>EXTRAVERSION</literal> in the <filename>Makefile</filename>), of the <literal>LOCALVERSION</literal> configuration parameter, and of the <literal>LOCALVERSION</literal> environment variable. The package version reuses the same version string with an appended revision that is regularly incremented (and stored in <filename>.version</filename>), except if you override it with the <literal>KDEB_PKGVERSION</literal> environment variable."
msgstr "ここで <replaceable>version</replaceable> は上流開発バージョン (<filename>Makefile</filename> 中の <literal>VERSION</literal>、<literal>PATCHLEVEL</literal>、<literal>SUBLEVEL</literal>、<literal>EXTRAVERSION</literal> から定義されます)、<literal>LOCALVERSION</literal> 設定パラメータ、<literal>LOCALVERSION</literal> 環境変数を連結したものです。パッケージバージョンは <replaceable>version</replaceable> に規則正しく増え続けるリビジョン番号 (<filename>.version</filename> に保存されています) を付け加えたものになります。ただし、<literal>KDEB_PKGVERSION</literal> 環境変数を使えばパッケージバージョンを上書きすることも可能です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"<computeroutput>$ </computeroutput><userinput>make deb-pkg LOCALVERSION=-falcot KDEB_PKGVERSION=$(make kernelversion)-1\n"
"</userinput><computeroutput>[...]\n"
"$ </computeroutput><userinput>ls ../*.deb\n"
"</userinput><computeroutput>../linux-headers-3.16.7-ckt4-falcot_3.16.7-1_amd64.deb\n"
"../linux-image-3.16.7-ckt4-falcot_3.16.7-1_amd64.deb\n"
"../linux-image-3.16.7-ckt4-falcot-dbg_3.16.7-1_amd64.deb\n"
"../linux-libc-dev_3.16.7-1_amd64.deb\n"
"</computeroutput>"
msgstr ""
"<computeroutput>$ </computeroutput><userinput>make deb-pkg LOCALVERSION=-falcot KDEB_PKGVERSION=$(make kernelversion)-1\n"
"</userinput><computeroutput>[...]\n"
"$ </computeroutput><userinput>ls ../*.deb\n"
"</userinput><computeroutput>../linux-headers-3.16.7-ckt4-falcot_3.16.7-1_amd64.deb\n"
"../linux-image-3.16.7-ckt4-falcot_3.16.7-1_amd64.deb\n"
"../linux-image-3.16.7-ckt4-falcot-dbg_3.16.7-1_amd64.deb\n"
"../linux-libc-dev_3.16.7-1_amd64.deb\n"
"</computeroutput>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Compiling External Modules"
msgstr "外部モジュールのコンパイル"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>kernel</primary><secondary>external modules</secondary>"
msgstr "<primary>カーネル</primary><secondary>外部モジュール</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>modules</primary><secondary>external kernel modules</secondary>"
msgstr "<primary>モジュール</primary><secondary>外部カーネルモジュール</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><command>dkms</command></primary>"
msgstr "<primary><command>dkms</command></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Some modules are maintained outside of the official Linux kernel. To use them, they must be compiled alongside the matching kernel. A number of common third party modules are provided by Debian in dedicated packages, such as <emphasis role=\"pkg\">xtables-addons-source</emphasis> (extra modules for iptables) or <emphasis role=\"pkg\">oss4-source</emphasis> (Open Sound System, some alternative audio drivers)."
msgstr "いくつかのモジュールは公式の Linux カーネルの外でメンテナンスされています。このような外部モジュールを使うには、適合するカーネルと一緒にモジュールをコンパイルしなければいけません。Debian は専用パッケージの形で数多くのサードパーティ製の外部モジュールを配布しています。たとえば、<emphasis role=\"pkg\">xtables-addons-source</emphasis> (iptables 用の追加モジュール)、<emphasis role=\"pkg\">oss4-source</emphasis> (Open Sound System、代替音声ドライバ) などがその一例です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "These external packages are many and varied and we won't list them all here; the <command>apt-cache search source$</command> command can narrow down the search field. However, a complete list isn't particularly useful since there is no particular reason for compiling external modules except when you know you need it. In such cases, the device's documentation will typically detail the specific module(s) it needs to function under Linux."
msgstr "これらの外部モジュール用パッケージは多種多様で、ここですべてを挙げることはできません。外部モジュール用パッケージを検索するには <command>apt-cache search source$</command> コマンドを使います。しかしながら、完全なリストがあったとしても、それは特に役立つわけではありません。なぜなら、外部モジュールが必要であるとわかっている場合を除いて、外部モジュールをコンパイルする特別な理由はないからです。デバイスの動作に外部モジュールが必要になる場合、デバイスの文書が Linux でそのデバイスを機能させるために必要な特定のモジュールについて詳しく説明している場合が多いです。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "For example, let's look at the <emphasis role=\"pkg\">xtables-addons-source</emphasis> package: after installation, a <filename>.tar.bz2</filename> of the module's sources is stored in <filename>/usr/src/</filename>. While we could manually extract the tarball and build the module, in practice we prefer to automate all this using DKMS. Most modules offer the required DKMS integration in a package ending with a <literal>-dkms</literal> suffix. In our case, installing <emphasis role=\"pkg\">xtables-addons-dkms</emphasis> is all that is needed to compile the kernel module for the current kernel provided that we have the <emphasis role=\"pkg\">linux-headers-*</emphasis> package matching the installed kernel. For instance, if you use <emphasis role=\"pkg\">linux-image-amd64</emphasis>, you would also install <emphasis role=\"pkg\">linux-headers-amd64</emphasis>."
msgstr "たとえば、<emphasis role=\"pkg\">xtables-addons-source</emphasis> パッケージを見てみましょう。インストールの後、モジュールのソース <filename>.tar.bz2</filename> が <filename>/usr/src/</filename> に保存されます。手作業でこの tarball を展開してモジュールをビルドすることも可能ですが、実際のところ、DKMS を使ってビルド作業を自動化する方が良いです。多くのモジュールは、パッケージ名が <literal>-dkms</literal> サフィックスで終わるパッケージの中で、DKMS 統合に必要な要素を提供します。今回の場合、インストール済みカーネルに対応する <emphasis role=\"pkg\">linux-headers-*</emphasis> パッケージを持っているならば、現在のカーネル用のカーネルモジュールをコンパイルするために必要な作業は <emphasis role=\"pkg\">xtables-addons-dkms</emphasis> をインストールするだけです。たとえば、<emphasis role=\"pkg\">linux-image-amd64</emphasis> を使っている場合、<emphasis role=\"pkg\">linux-headers-amd64</emphasis> をインストールする必要があります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>sudo apt install xtables-addons-dkms</userinput>\n"
"<computeroutput>\n"
"[...]\n"
"Setting up xtables-addons-dkms (2.6-1) ...\n"
"Loading new xtables-addons-2.6 DKMS files...\n"
"First Installation: checking all kernels...\n"
"Building only for 3.16.0-4-amd64\n"
"Building initial module for 3.16.0-4-amd64\n"
"Done.\n"
"\n"
"xt_ACCOUNT:\n"
"Running module version sanity check.\n"
" - Original module\n"
"   - No original module exists within this kernel\n"
" - Installation\n"
"   - Installing to /lib/modules/3.16.0-4-amd64/updates/dkms/\n"
"[...]\n"
"DKMS: install completed.\n"
"$ </computeroutput><userinput>sudo dkms status</userinput>\n"
"<computeroutput>xtables-addons, 2.6, 3.16.0-4-amd64, x86_64: installed\n"
"$ </computeroutput><userinput>sudo modinfo xt_ACCOUNT</userinput>\n"
"<computeroutput>filename:       /lib/modules/3.16.0-4-amd64/updates/dkms/xt_ACCOUNT.ko\n"
"license:        GPL\n"
"alias:          ipt_ACCOUNT\n"
"author:         Intra2net AG &lt;opensource@intra2net.com&gt;\n"
"description:    Xtables: per-IP accounting for large prefixes\n"
"[...]\n"
"</computeroutput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>sudo apt install xtables-addons-dkms</userinput>\n"
"<computeroutput>\n"
"[...]\n"
"xtables-addons-dkms (2.6-1) を設定しています ...\n"
"Loading new xtables-addons-2.6 DKMS files...\n"
"First Installation: checking all kernels...\n"
"Building only for 3.16.0-4-amd64\n"
"Building initial module for 3.16.0-4-amd64\n"
"Done.\n"
"\n"
"xt_ACCOUNT:\n"
"Running module version sanity check.\n"
" - Original module\n"
"   - No original module exists within this kernel\n"
" - Installation\n"
"   - Installing to /lib/modules/3.16.0-4-amd64/updates/dkms/\n"
"[...]\n"
"DKMS: install completed.\n"
"$ </computeroutput><userinput>sudo dkms status</userinput>\n"
"<computeroutput>xtables-addons, 2.6, 3.16.0-4-amd64, x86_64: installed\n"
"$ </computeroutput><userinput>sudo modinfo xt_ACCOUNT</userinput>\n"
"<computeroutput>filename:       /lib/modules/3.16.0-4-amd64/updates/dkms/xt_ACCOUNT.ko\n"
"license:        GPL\n"
"alias:          ipt_ACCOUNT\n"
"author:         Intra2net AG &lt;opensource@intra2net.com&gt;\n"
"description:    Xtables: per-IP accounting for large prefixes\n"
"[...]\n"
"</computeroutput>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<emphasis>ALTERNATIVE</emphasis> module-assistant"
msgstr "<emphasis>ALTERNATIVE</emphasis> module-assistant"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><emphasis role=\"pkg\">module-assistant</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">module-assistant</emphasis></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Before DKMS, <emphasis role=\"pkg\">module-assistant</emphasis> was the simplest solution to build and deploy kernel modules. It can still be used, in particular for packages lacking DKMS integration: with a simple command like <command>module-assistant auto-install xtables-addons</command> (or <command>m-a a-i xtables-addons</command> for short), the modules are compiled for the current kernel, put in a new Debian package, and that package gets installed on the fly."
msgstr "DKMS 以前、カーネルモジュールをビルドして配置する最も簡単な解決策は <emphasis role=\"pkg\">module-assistant</emphasis> でした。特に DKMS 統合されていないパッケージはまだ <emphasis role=\"pkg\">module-assistant</emphasis> を使っています。このようなパッケージでは、単純なコマンド <command>module-assistant auto-install xtables-addons</command> (または短縮コマンドの <command>m-a a-i xtables-addons</command>) を使えば、モジュールを現在のカーネル用にコンパイルして新しい Debian パッケージを作成できます。作成したパッケージはその場でインストールできます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Applying a Kernel Patch"
msgstr "カーネルパッチの適用"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>kernel</primary><secondary>patch</secondary>"
msgstr "<primary>カーネル</primary><secondary>パッチ</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>patch of the kernel</primary>"
msgstr "<primary>カーネルのパッチ</primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Some features are not included in the standard kernel due to a lack of maturity or to some disagreement with the kernel maintainers. Such features may be distributed as patches that anyone is then free to apply to the kernel sources."
msgstr "一部の機能は完成度の低さやカーネルメンテナとの意見の不一致が原因で標準的なカーネルに含まれていません。そのような機能をカーネルソースに対して自由に適用できるようにするために、これをパッチの形で配布する場合があります。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Debian distributes some of these patches in <emphasis role=\"pkg\">linux-patch-*</emphasis> or <emphasis role=\"pkg\">kernel-patch-*</emphasis> packages (for instance, <emphasis role=\"pkg\">linux-patch-grsecurity2</emphasis>, which tightens some of the kernel's security policies). These packages install files in the <filename>/usr/src/kernel-patches/</filename> directory."
msgstr "Debian はいくつかのパッチを <emphasis role=\"pkg\">linux-patch-*</emphasis> や <emphasis role=\"pkg\">kernel-patch-*</emphasis> パッケージの形で配布します (たとえば、<emphasis role=\"pkg\">linux-patch-grsecurity2</emphasis> はカーネルのセキュリティポリシーを厳しくするパッチです)。これらのパッケージは <filename>/usr/src/kernel-patches/</filename> ディレクトリにファイルをインストールします。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "To apply one or more of these installed patches, use the <command>patch</command> command in the sources directory then start compilation of the kernel as described above."
msgstr "インストール済みパッチをカーネルに適用するには、ソースディレクトリの中で <command>patch</command> コマンドを使い、上で述べた通り、カーネルのコンパイルを始めてください。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>cd ~/kernel/linux-source-3.16</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>make clean</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>zcat /usr/src/kernel-patches/diffs/grsecurity2/grsecurity-3.0-3.17.1-201410250027.patch.gz | patch -p1</userinput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>cd ~/kernel/linux-source-3.16</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>make clean</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>zcat /usr/src/kernel-patches/diffs/grsecurity2/grsecurity-3.0-3.17.1-201410250027.patch.gz | patch -p1</userinput>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Note that a given patch may not necessarily work with every version of the kernel; it is possible for <command>patch</command> to fail when applying them to kernel sources. An error message will be displayed and give some details about the failure; in this case, refer to the documentation available in the Debian package of the patch (in the <filename>/usr/share/doc/linux-patch-*/</filename> directory). In most cases, the maintainer indicates for which kernel versions their patch is intended."
msgstr "与えられたパッチがカーネルのどのバージョンでも動作するとは限らないことに注意してください。さらに、カーネルソースにパッチを適用する際に、<command>patch</command> が失敗することもあります。エラーメッセージが表示され、失敗に関する詳細が表示されるでしょう。この場合、そのパッチの Debian パッケージで利用できる文書 (<filename>/usr/share/doc/linux-patch-*/</filename> ディレクトリに含まれます) を参照してください。多くの場合、メンテナはそのパッチがどのカーネルバージョンを対象にしたものかを書いています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Installing a Kernel"
msgstr "カーネルのインストール"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>installation</primary><secondary>of a kernel</secondary>"
msgstr "<primary>インストール</primary><secondary>カーネルのインストール</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary>kernel</primary><secondary>installation</secondary>"
msgstr "<primary>カーネル</primary><secondary>インストール</secondary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Features of a Debian Kernel Package"
msgstr "Debian カーネルパッケージの特徴"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "<primary><filename>vmlinuz</filename></primary>"
msgstr "<primary><filename>vmlinuz</filename></primary>"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "A Debian kernel package installs the kernel image (<filename>vmlinuz-<replaceable>version</replaceable></filename>), its configuration (<filename>config-<replaceable>version</replaceable></filename>) and its symbols table (<filename>System.map-<replaceable>version</replaceable></filename>) in <filename>/boot/</filename>. The symbols table helps developers understand the meaning of a kernel error message; without it, kernel “oopses” (an “oops” is the kernel equivalent of a segmentation fault for user-space programs, in other words messages generated following an invalid pointer dereference) only contain numeric memory addresses, which is useless information without the table mapping these addresses to symbols and function names. The modules are installed in the <filename>/lib/modules/<replaceable>version</replaceable>/</filename> directory."
msgstr "Debian カーネルパッケージはカーネルイメージ (<filename>vmlinuz-<replaceable>version</replaceable></filename>) をインストールします。カーネルの設定 (<filename>config-<replaceable>version</replaceable></filename>) とシンボルテーブル (<filename>System.map-<replaceable>version</replaceable></filename>) は <filename>/boot/</filename> に置かれます。シンボルテーブルは開発者がカーネルエラーメッセージの意味を理解する際の手助けになります。それどころかシンボルテーブルがなければ、カーネルの「oops」(「oops」とはカーネル空間で起こるユーザ空間プログラムのセグメンテーション違反に相当するエラーです。言い換えれば、不正なポインタを参照して値を取得したことで生成されるメッセージです) に含まれる情報は、数字で表したメモリアドレスだけになります。アドレスとシンボルや関数名を対応付けるテーブルがなければ、この情報は役に立ちません。モジュールは <filename>/lib/modules/<replaceable>version</replaceable>/</filename> ディレクトリにインストールされます。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The package's configuration scripts automatically generate an initrd image, which is a mini-system designed to be loaded in memory (hence the name, which stands for “init ramdisk”) by the bootloader, and used by the Linux kernel solely for loading the modules needed to access the devices containing the complete Debian system (for example, the driver for SATA disks). Finally, the post-installation scripts update the symbolic links <filename>/vmlinuz</filename>, <filename>/vmlinuz.old</filename>, <filename>/initrd.img</filename> and <filename>/initrd.img.old</filename> so that they point to the latest two kernels installed, respectively, as well as the corresponding initrd images."
msgstr "カーネルパッケージの設定スクリプトは自動的に initrd イメージを生成します。initrd はブートローダによってメモリに読み込まれる小さなシステムで (このため「init RAM ディスク」と名付けられています)、Linux カーネルは initrd を使って完全な Debian システムを含むデバイス (たとえば SATA ディスクのドライバ) にアクセスするために必要なモジュールを読み込みます。最後に、カーネルパッケージの post-installation スクリプトが <filename>/vmlinuz</filename>、<filename>/vmlinuz.old</filename>、<filename>/initrd.img</filename>、<filename>/initrd.img.old</filename> のシンボリックリンクを更新します。これらはそれぞれインストールされた最新の 2 つのカーネルとカーネルに対応する initrd イメージを指します。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Most of those tasks are offloaded to hook scripts in the <filename>/etc/kernel/*.d/</filename> directories. For instance, the integration with <command>grub</command> relies on <filename>/etc/kernel/postinst.d/zz-update-grub</filename> and <filename>/etc/kernel/postrm.d/zz-update-grub</filename> to call <command>update-grub</command> when kernels are installed or removed."
msgstr "これらの作業のほとんどは <filename>/etc/kernel/*.d/</filename> ディレクトリの中にあるフックスクリプトが担っています。たとえば、<command>grub</command> との統合は、カーネルがインストールまたは削除された際に <command>update-grub</command> を呼び出す <filename>/etc/kernel/postinst.d/zz-update-grub</filename> と <filename>/etc/kernel/postrm.d/zz-update-grub</filename> が担っています。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Installing with <command>dpkg</command>"
msgstr "<command>dpkg</command> を使ったインストール"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "Using <command>apt</command> is so convenient that it makes it easy to forget about the lower-level tools, but the easiest way of installing a compiled kernel is to use a command such as <command>dpkg -i <replaceable>package</replaceable>.deb</command>, where <literal><replaceable>package</replaceable>.deb</literal> is the name of a <emphasis role=\"pkg\">linux-image</emphasis> package such as <filename>linux-image-3.16.7-ckt4-falcot_1_amd64.deb</filename>."
msgstr "<command>apt</command> はとても便利なので、簡単に低レベルツールについて忘れてしまいます。しかし、コンパイルされたカーネルをインストールする最も簡単な方法は <command>dpkg -i <replaceable>package</replaceable>.deb</command> などのコマンドを使うやり方です。ここで <literal><replaceable>package</replaceable>.deb</literal> は <emphasis role=\"pkg\">linux-image</emphasis> パッケージの名前で、たとえば <filename>linux-image-3.16.7-ckt4-falcot_1_amd64.deb</filename> です。"

# Checked-By: Ryuunosuke Ayanokouzi;
msgid "The configuration steps described in this chapter are basic and can lead both to a server system or a workstation, and it can be massively duplicated in semi-automated ways. However, it is not enough by itself to provide a fully configured system. A few pieces are still in need of configuration, starting with low-level programs known as the “Unix services”."
msgstr "この章で説明されている設定手順は基本であり、サーバシステムにもワークステーションにも適用でき、半自動化された方法で広く適用できます。しかしながら、この設定手順だけで完全に設定されたシステムを十分に提供することは不可能です。「Unix サービス」として知られている低レベルプログラムを初めとする、いくつかの要素に対する設定がまだ必要です。"

#~ msgid "<emphasis>TOOL</emphasis> On-demand connection with <command>diald</command>"
#~ msgstr "<emphasis>TOOL</emphasis> <command>diald</command> を使ったオンデマンド接続"

#~ msgid "<primary><command>diald</command></primary>"
#~ msgstr "<primary><command>diald</command></primary>"

#~ msgid "<primary>connection</primary><secondary>on demand</secondary>"
#~ msgstr "<primary>接続</primary><secondary>オンデマンド</secondary>"

#~ msgid "<command>diald</command> is an on-demand connection service that automatically establishes a connection when needed, by detecting an outgoing IP packet and disconnecting after a period of inactivity."
#~ msgstr "<command>diald</command> はオンデマンド接続サービスで、外部宛の IP パケットを検出することで必要になったら自動的に接続を確立し、未通信状態で一定時間経過したら接続を切断します。"
