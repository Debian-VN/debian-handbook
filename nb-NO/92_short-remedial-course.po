msgid ""
msgstr ""
"Project-Id-Version: 0\n"
"POT-Creation-Date: 2016-04-10 09:00+0900\n"
"PO-Revision-Date: 2017-01-24 05:52+0000\n"
"Last-Translator: Petter Reinholdtsen <pere-weblate@hungry.com>\n"
"Language-Team: Norwegian Bokmål <https://hosted.weblate.org/projects/debian-handbook/92_short-remedial-course/nb_NO/>\n"
"Language: nb-NO\n"
"MIME-Version: 1.0\n"
"Content-Type: application/x-publican; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=n != 1;\n"
"X-Generator: Weblate 2.11-dev\n"

msgid "BIOS"
msgstr "BIOS"

msgid "Kernel"
msgstr "Kjerne"

msgid "Unix"
msgstr "Unix"

msgid "Process"
msgstr "Prosess"

msgid "Hierarchy"
msgstr "Hierarki"

msgid "Basic Commands"
msgstr "Grunnleggende kommandoer"

msgid "Short Remedial Course"
msgstr "Kort støttekurs"

msgid "Even though this book primarily targets administrators and “power-users”, we wouldn't like to exclude motivated beginners. This appendix will therefore be a crash-course describing the fundamental concepts involved in handling a Unix computer."
msgstr "Selv om denne boken i hovedsak retter seg mot administratorer og «superbrukere», så ønsker vi ikke å ekskludere motiverte nybegynnere.  Dette vedlegget er derfor et krasjkurs som beskriver de grunnleggende konseptene involvert i håndtering av en Unix-datamaskin."

msgid "Shell and Basic Commands"
msgstr "Skall og grunnleggende kommandoer"

msgid "In the Unix world, every administrator has to use the command line sooner or later; for example, when the system fails to start properly and only provides a command-line rescue mode. Being able to handle such an interface, therefore, is a basic survival skill for these circumstances."
msgstr "I Unix-verden må enhver administrator bruke kommandolinjen før eller senere; for eksempel når systemet ikke starter som det skal, og kun tilbyr en redningsmodus med kommandolinje.  Det å være i stand til å håndtere et slikt grensesnitt er dermed grunnleggende overlevelseskunnskap i slike tilfeller."

#, fuzzy
msgid "<emphasis>QUICK LOOK</emphasis> Starting the command interpreter"
msgstr "<emphasis>HURTIGVISNING</emphasis> Starting av kommandotolkeren"

msgid "A command-line environment can be run from the graphical desktop, by an application known as a “terminal”. In GNOME, you can start it from the “Activities” overview (that you get when you move the mouse in the top-left corner of the screen) by typing the first letters of the application name. In KDE, you will find it in the <menuchoice><guimenu>K</guimenu> <guisubmenu>Applications</guisubmenu> <guisubmenu>System</guisubmenu></menuchoice> menu."
msgstr "Et kommandolinjemiljø kan kjøres fra det grafiske skrivebordet med et program som kalles en «terminal». I GNOME kan du starte det fra «Aktivitets»-oversikten (som du får når du beveger musen i øverste venstre hjørne av skjermen) ved å skrive de første bokstavene i navnet på programmet. I KDE vil du finne det i <menuchoice><guimenu>K</guimenu> <guisubmenu>Applikasjoner</guisubmenu> <guisubmenu>System</guisubmenu></menuchoice>-menyen."

msgid "This section only gives a quick peek at the commands. They all have many options not described here, so please refer to the abundant documentation in their respective manual pages."
msgstr "Denne delen gir bare en kort oversikt på kommandoene. Alle har mange alternativer som ikke er beskrevet her, så vis gjerne til den rikholdige dokumentasjonpå de respektive manualsidene."

msgid "Browsing the Directory Tree and Managing Files"
msgstr "Å surfe i mappetreet og operativsystemet"

msgid "Once a session is open, the <command>pwd</command> command (which stands for <emphasis>print working directory</emphasis>) displays the current location in the filesystem. The current directory is changed with the <command>cd <replaceable>directory</replaceable></command> command (<command>cd</command> is for <emphasis>change directory</emphasis>). The parent directory is always called <literal>..</literal> (two dots), whereas the current directory is also known as <literal>.</literal> (one dot). The <command>ls</command> command allows <emphasis>listing</emphasis> the contents of a directory. If no parameters are given, it operates on the current directory."
msgstr "Så snart en sesjon er åpen, viser <command>pwd</command>-kommandoen (som står for <emphasis>print working directory</emphasis>) den gjeldende plasseringen i filsystemet. Den nåværende mappen endres med <command>cd <replaceable>mappe</replaceable></command>-kommandoen, (<command>cd</command> står for <emphasis>endre mappe</emphasis>). Den overordnede mappen er alltid kalt <literal>..</literal> (to punkter), mens den gjeldende mappen også er kjent som <literal>.</literal> (ett punkt). <command>ls</command>-kommandoen åpner for å <emphasis>liste</emphasis> innholdet i en mappe/katalog. Hvis ingen parametere er angitt, opererer den på den gjeldende mappen."

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog\n"
"$ </computeroutput><userinput>cd Desktop</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog/Desktop\n"
"$ </computeroutput><userinput>cd .</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog/Desktop\n"
"$ </computeroutput><userinput>cd ..</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog\n"
"$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates\n"
"Documents  Music      Public    Videos</computeroutput>\n"
"      "
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog\n"
"$ </computeroutput><userinput>cd Desktop</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog/Desktop\n"
"$ </computeroutput><userinput>cd .</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog/Desktop\n"
"$ </computeroutput><userinput>cd ..</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog\n"
"$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates\n"
"Documents  Music      Public    Videos</computeroutput>\n"
"      "

msgid "A new directory can be created with <command>mkdir <replaceable>directory</replaceable></command>, and an existing (empty) directory can be removed with <command>rmdir <replaceable>directory</replaceable></command>. The <command>mv</command> command allows <emphasis>moving</emphasis> and/or renaming files and directories; <emphasis>removing</emphasis> a file is achieved with <command>rm <replaceable>file</replaceable></command>."
msgstr "En ny mappe kan lages med <command>mkdir <replaceable>mappe</replaceable></command>, og en eksisterende (tom) mappe kan fjernes med <command>rmdir <replaceable>mappe</replaceable></command>. <command>mv</command>-kommando åpner for <emphasis>flytting</emphasis>, og/eller for å døpe om filer og mapper; <emphasis>flytte</emphasis> en fil skjer med <command>rm <replaceable>fil</replaceable></command>."

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>mkdir test</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates  Videos\n"
"Documents  Music      Public    test\n"
"$ </computeroutput><userinput>mv test new</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  new       Public     Videos\n"
"Documents  Music      Pictures  Templates\n"
"$ </computeroutput><userinput>rmdir new</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates  Videos\n"
"Documents  Music      Public</computeroutput>\n"
"      "
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>mkdir test</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates  Videos\n"
"Documents  Music      Public    test\n"
"$ </computeroutput><userinput>mv test new</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  new       Public     Videos\n"
"Documents  Music      Pictures  Templates\n"
"$ </computeroutput><userinput>rmdir new</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates  Videos\n"
"Documents  Music      Public</computeroutput>\n"
"      "

msgid "Displaying and Modifying Text Files"
msgstr "Å vise og modifisere tekstfiler"

msgid "The <command>cat <replaceable>file</replaceable></command> command (intended to <emphasis>concatenate</emphasis> files to the standard output device) reads a file and displays its contents on the terminal. If the file is too big to fit on a screen, use a pager such as <command>less</command> (or <command>more</command>) to display it page by page."
msgstr "Kommandoen <command>cat <replaceable>fil</replaceable></command> (med formål å <emphasis>sette sammen</emphasis> filer til standard ut-enheten) leser en fil, og viser innholdet på terminalen. Hvis filen er for stor til å passe til en skjerm, kan du bruke <command>less</command> (eller <command>more</command>) for å vise den side for side."

msgid "The <command>editor</command> command starts a text editor (such as <command>vi</command> or <command>nano</command>) and allows creating, modifying and reading text files. The simplest files can sometimes be created directly from the command interpreter thanks to redirection: <command>echo \"<replaceable>text</replaceable>\" &gt;<replaceable>file</replaceable></command> creates a file named <replaceable>file</replaceable> with “<replaceable>text</replaceable>” as its contents. Adding a line at the end of this file is possible too, with a command such as <command>echo \"<replaceable>moretext</replaceable>\" &gt;&gt;<replaceable>file</replaceable></command>. Note the <literal>&gt;&gt;</literal> in this example."
msgstr "Kommandoen <command>editor</command> starter en tekstredigerer (slik som <command>vi</command> eller <command>nano</command>), og tillater å lage, modifisere og lese tekstfiler. De enkleste filene kan noen ganger opprettes direkte fra kommandokonsollen/-linjen takket være omdirigering: <command>echo «<replaceable>tekst</replaceable>» &gt;<replaceable>fil</replaceable></command> lager en fil med navnet <replaceable>fil</replaceable> med «<replaceable>tekst</replaceable>» som sitt innhold. Å legge til en linje på slutten av denne filen er også mulig, med en kommando som <command>echo «<replaceable>linje</replaceable>» &gt;&gt;<replaceable>file</replaceable></command>. Merk <literal>&gt;&gt;</literal> i dette eksemplet."

msgid "Searching for Files and within Files"
msgstr "Å søke etter filer og innenfor filer"

msgid "The <command>find <replaceable>directory</replaceable> <replaceable>criteria</replaceable></command> command looks for files in the hierarchy under <replaceable>directory</replaceable> according to several criteria. The most commonly used criterion is <literal>-name <replaceable>name</replaceable></literal>: that allows looking for a file by its name."
msgstr "Kommandoen <command>find <replaceable>mappe</replaceable> <replaceable>kriterier</replaceable></command> ser etter filer i hierarkiet under <replaceable>mappe</replaceable> etter flere kriterier. Det mest brukte er kriteriet <literal>-name <replaceable>navn</replaceable></literal>, som tillater å lete etter en fil med det navnet."

msgid "The <command>grep <replaceable>expression</replaceable> <replaceable>files</replaceable></command> command searches the contents of the files and extracts the lines matching the regular expression (see sidebar <xref linkend=\"sidebar.regexp\" />). Adding the <literal>-r</literal> option enables a recursive search on all files contained in the directory passed as a parameter. This allows looking for a file when only a part of the contents are known."
msgstr "Kommandoen <command>grep <replaceable>uttrykket</replaceable> <replaceable>filer</replaceable></command> søker igjennom innholdet i filene, og trekker ut de linjene som samsvarer med det regulære uttrykket (se sidestolpe <xref linkend=\"sidebar.regexp\" />). Å legge til <literal>-r</literal>-alternativet muliggjør at et gjentakende søk på alle filene i katalogen sendes som et parameter. Dette gjør det mulig å se etter en fil når bare en del av innholdet er kjent."

msgid "Managing Processes"
msgstr "Å håndtere prosesser"

msgid "The <command>ps aux</command> command lists the processes currently running and helps identifying them by showing their <emphasis>pid</emphasis> (process id). Once the <emphasis>pid</emphasis> of a process is known, the <command>kill -<replaceable>signal</replaceable> <replaceable>pid</replaceable></command> command allows sending it a signal (if the process belongs to the current user). Several signals exist; most commonly used are <literal>TERM</literal> (a request to terminate gracefully) and <literal>KILL</literal> (a forced kill)."
msgstr "Kommandoen <command>ps aux</command> viser prosessene som kjører og hjelper å identifisere dem ved å vise sin <emphasis>pid</emphasis> (process id). Så snart <emphasis>pid</emphasis> av en prosess er kjent, kan <command>kill -<replaceable>signal</replaceable> <replaceable>pid</replaceable></command>-kommandoen sende den et signal (hvis prosessen tilhører den aktuelle brukeren). Flere signaler finnes; de mest brukte er <literal>TERM</literal> (en elegant anmodning om å avslutte) og <literal>KILL</literal> (en tvunget avslutning)."

msgid "The command interpreter can also run programs in the background if the command is followed by a “&amp;”. By using the ampersand, the user resumes control of the shell immediately even though the command is still running (hidden from the user; as a background process). The <command>jobs</command> command lists the processes running in the background; running <command>fg %<replaceable>job-number</replaceable></command> (for <emphasis>foreground</emphasis>) restores a job to the foreground. When a command is running in the foreground (either because it was started normally, or brought back to the foreground with <command>fg</command>), the <keycombo action=\"simul\"><keycap>Control</keycap><keycap>Z</keycap></keycombo> key combination pauses the process and resumes control of the command-line. The process can then be restarted in the background with <command>bg %<replaceable>job-number</replaceable></command> (for <foreignphrase>background</foreignphrase>)."
msgstr "Kommandokonsollet kan også kjøre programmer i bakgrunnen hvis kommandoen er etterfulgt av et «&amp;». Ved å bruke &amp;-tegnet (og-tegnet/et-tegnet (ampersand)), får brukeren umiddelbart tilbake kontroll over skallet, selv om kommandoen fortsatt kjører (skjult for brukeren, som en bakgrunnsprosess). Kommandoen <command>jobs</command> lister prosesser som kjører i bakgrunnen; å kjøre <command>fg %<replaceable>jobbnummer</replaceable></command> (for <emphasis>foreground</emphasis>) gjenopprettes en jobb til forgrunnen. Når en kommando kjører i forgrunnen (enten fordi den ble startet normalt, eller bringes tilbake til forgrunnen med <command>fg</command>), pauser <keycombo action=\"simul\"><keycap>Control</keycap><keycap>Z</keycap></keycombo>-tastekombinasjonen prosessen, og gjenopptar kontrollen over kommandolinjen. Prosessen kan deretter restartes i bakgrunnen med <command>bg %<replaceable>jobbnummer</replaceable></command> (for <foreignphrase>background</foreignphrase>)."

msgid "System Information: Memory, Disk Space, Identity"
msgstr "Systeminformasjon: Minne, diskplass, identitet"

msgid "The <command>free</command> command displays information on memory; <command>df</command> (<emphasis>disk free</emphasis>) reports on the available disk space on each of the disks mounted in the filesystem. Its <literal>-h</literal> option (for <emphasis>human readable</emphasis>) converts the sizes into a more legible unit (usually mebibytes or gibibytes). In a similar fashion, the <command>free</command> command supports the <literal>-m</literal> and <literal>-g</literal> options, and displays its data either in mebibytes or in gibibytes, respectively."
msgstr "Kommandoen <command>free</command> viser informasjon om minne; <command>df</command> (<emphasis>disk free</emphasis>) rapporterer om ledig diskplass på hver av diskene montert i filsystemet. <literal>-h</literal>-valget dens (for <emphasis>human readable (lesbar)</emphasis>) konverterer størrelsene til en mer leselig enhet (vanligvis mebibytes eller gibibytes). På lignende måte støtter <command>free</command>-kommandoen <literal>-m</literal> og <literal>-g</literal>-valgene, og viser dataene dens henholdsvis enten i  mebibytes eller i gibibytes."

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>free</userinput>\n"
"<computeroutput>             total       used       free     shared    buffers     cached\n"
"Mem:       1028420    1009624      18796          0      47404     391804\n"
"-/+ buffers/cache:     570416     458004\n"
"Swap:      2771172     404588    2366584\n"
"$ </computeroutput><userinput>df</userinput>\n"
"<computeroutput>Filesystem           1K-blocks      Used Available Use% Mounted on\n"
"/dev/sda2              9614084   4737916   4387796  52% /\n"
"tmpfs                   514208         0    514208   0% /lib/init/rw\n"
"udev                     10240       100     10140   1% /dev\n"
"tmpfs                   514208    269136    245072  53% /dev/shm\n"
"/dev/sda5             44552904  36315896   7784380  83% /home\n"
"</computeroutput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>free</userinput>\n"
"<computeroutput>             total       used       free     shared    buffers     cached\n"
"Mem:       1028420    1009624      18796          0      47404     391804\n"
"-/+ buffers/cache:     570416     458004\n"
"Swap:      2771172     404588    2366584\n"
"$ </computeroutput><userinput>df</userinput>\n"
"<computeroutput>Filesystem           1K-blocks      Used Available Use% Mounted on\n"
"/dev/sda2              9614084   4737916   4387796  52% /\n"
"tmpfs                   514208         0    514208   0% /lib/init/rw\n"
"udev                     10240       100     10140   1% /dev\n"
"tmpfs                   514208    269136    245072  53% /dev/shm\n"
"/dev/sda5             44552904  36315896   7784380  83% /home\n"
"</computeroutput>"

msgid "The <command>id</command> command displays the identity of the user running the session, along with the list of groups they belong to. Since access to some files or devices may be limited to group members, checking available group membership may be useful."
msgstr "Kommandoen <command>id</command> viser identiteten til brukeren som kjører økten, sammen med listen over grupper de tilhører. Siden tilgang til noen filer eller enheter kan være begrenset til gruppemedlemmene, kan det være nyttig å sjekke tilgjengelige gruppemedlemskap."

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>id</userinput>\n"
"<computeroutput>uid=1000(rhertzog) gid=1000(rhertzog) groups=1000(rhertzog),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(netdev),109(bluetooth),115(scanner)</computeroutput>\n"
"      "
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>id</userinput>\n"
"<computeroutput>uid=1000(rhertzog) gid=1000(rhertzog) groups=1000(rhertzog),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(netdev),109(bluetooth),115(scanner)</computeroutput>\n"
"      "

msgid "Organization of the Filesystem Hierarchy"
msgstr "Organisering av filsystemhierarkiet"

msgid "<primary>Filesystem Hierarchy</primary>"
msgstr "<primary> Filsystemhierarkiet</primary>"

msgid "The Root Directory"
msgstr "Rotmappen"

msgid "A Debian system is organized along the <emphasis>Filesystem Hierarchy Standard</emphasis> (FHS). This standard defines the purpose of each directory. For instance, the top-level directories are described as follows:"
msgstr "Et Debian-system er organisert i tråd med <emphasis>Filesystem Hierarchy Standard</emphasis> (FHS). Denne standarden definerer formålet med hver mappe. For eksempel er toppnivå-mapper beskrevet som følger:"

msgid "<filename>/bin/</filename>: basic programs;"
msgstr "<filename>/bin/</filename>: basisprogrammet;"

msgid "<filename>/boot/</filename>: Linux kernel and other files required for its early boot process;"
msgstr "<filename>/boot/</filename>: Linux-kjernen og andre filer som kreves til den tidlige oppstartsprosessen;"

msgid "<filename>/dev/</filename>: device files;"
msgstr "<filename>/dev/</filename>: filer for enheter;"

msgid "<filename>/etc/</filename>: configuration files;"
msgstr "<filename>/etc/</filename>: Oppsettfiler;"

msgid "<filename>/home/</filename>: user's personal files;"
msgstr "<filename>/home/</filename>: brukerens personlige filer;"

msgid "<filename>/lib/</filename>: basic libraries;"
msgstr "<filename>/lib/</filename>: basisbiblioteker;"

msgid "<filename>/media/*</filename>: mount points for removable devices (CD-ROM, USB keys and so on);"
msgstr "<filename>/media/*</filename>: monteringspunkter for flyttbare enheter (CD-ROM, USB-nøkler, og så videre);"

msgid "<filename>/mnt/</filename>: temporary mount point;"
msgstr "<filename>/mnt/</filename>: midlertidige monteringspunkter;"

msgid "<filename>/opt/</filename>: extra applications provided by third parties;"
msgstr "<filename>/opt/</filename>: ekstra programmer levert av tredjeparter;"

msgid "<filename>/root/</filename>: administrator's (root's) personal files;"
msgstr "<filename>/root/</filename>: administrators (rots) personlige filer;"

msgid "<filename>/run/</filename>: volatile runtime data that does not persist across reboots (not yet included in the FHS);"
msgstr "<filename>/run/</filename>: omskiftelige kjøretidsdata som ikke vedvarer igjennom oppstarter (ennå ikke inkludert i FHS);"

msgid "<filename>/sbin/</filename>: system programs;"
msgstr "<filename>/sbin/</filename>: systemprogrammer;"

msgid "<filename>/srv/</filename>: data used by servers hosted on this system;"
msgstr "<filename>/srv/</filename>: data brukt av tjenere med vertskap på dette systemet;"

msgid "<filename>/tmp/</filename>: temporary files; this directory is often emptied at boot;"
msgstr "<filename>/tmp/</filename>: midlertidige filer; denne katalogen tømmes ofte ved oppstart;"

msgid "<filename>/usr/</filename>: applications; this directory is further subdivided into <filename>bin</filename>, <filename>sbin</filename>, <filename>lib</filename> (according to the same logic as in the root directory). Furthermore, <filename>/usr/share/</filename> contains architecture-independent data. <filename>/usr/local/</filename> is meant to be used by the administrator for installing applications manually without overwriting files handled by the packaging system (<command>dpkg</command>)."
msgstr "<filename>/usr/</filename>: programmer; denne katalogen er videre inndelt i <filename>bin</filename>, <filename>sbin</filename>, <filename>lib</filename> (ifølge samme logikk som i rotkatalogen). Videre inneholder <filename>/usr/share/</filename> arkitekturuavhengige data. <filename>/usr/local/</filename> er ment til å brukes av administrator for å installere programmer manuelt uten å overskrive filer som håndteres av pakkesystemet (<command>dpkg</command>)."

msgid "<filename>/var/</filename>: variable data handled by daemons. This includes log files, queues, spools, caches and so on."
msgstr "<filename>/var/</filename>: variable data som håndteres av nisser. Dette inkluderer loggfiler, køer, utskriftskøer, hurtiglagre og så videre."

msgid "<filename>/proc/</filename> and <filename>/sys/</filename> are specific to the Linux kernel (and not part of the FHS). They are used by the kernel for exporting data to user space (see <xref linkend=\"sect.userspace-presentation\" /> and <xref linkend=\"sect.user-space\" /> for explanations about this concept)."
msgstr "<filename>/proc/</filename> og <filename>/sys/</filename> er spesifikke for Linux-kjernen (og ikke en del av FHS). De brukes av kjernen for å eksportere data til brukerområde (se <xref linkend=\"sect.userspace-presentation\" /> og <xref linkend=\"sect.user-space\" /> for forklaringer på dette begrepet)."

msgid "The User's Home Directory"
msgstr "Brukerens hjemmemappe"

msgid "The contents of a user's home directory is not standardized, but there are still a few noteworthy conventions. One is that a user's home directory is often referred to by a tilde (“~”). That is useful to know because command interpreters automatically replace a tilde with the correct directory (usually <filename>/home/<replaceable>user</replaceable>/</filename>)."
msgstr "Innholdet i en brukers hjemmemappeg er ikke standardisert, men det er fortsatt noen få nevneverdige konvensjoner. Den ene er at en brukers hjemmemappe ofte er referert til av en krøllstrek («~»). Det er nyttig å vite fordi kommandokonsollet automatisk erstatter en krøllstrek med riktig katalog (vanligvis <filename>/home/<replaceable>bruker</replaceable>/</filename>)."

msgid "Traditionally, application configuration files are often stored directly under the user's home directory, but their names usually start with a dot (for instance, the <command>mutt</command> email client stores its configuration in <filename>~/.muttrc</filename>). Note that filenames that start with a dot are hidden by default; and <command>ls</command> only lists them when the <literal>-a</literal> option is used, and graphical file managers need to be told to display hidden files."
msgstr "Tradisjonelt er applikasjonens konfigurasjonsfiler ofte lagret direkte i brukerens hjemmemappe, men filnavnene deres starter vanligvis med et punktum (for eksempel e-postklient <command>mutt</command>, lagrer konfigurasjonen i <filename>~/.muttrc</filename>). Merk at filnavn som starter med en prikk er skjult som standard; og <command>ls</command> bare lister dem når <literal>-a</literal>-valget blir brukt, og grafiske fil-håndterere må få beskjed om å vise skjulte filer."

msgid "Some programs also use multiple configuration files organized in one directory (for instance, <filename>~/.ssh/</filename>). Some applications (such as the Iceweasel web browser) also use their directory to store a cache of downloaded data. This means that those directories can end up using a lot of disk space."
msgstr "Noen programmer bruker også flere konfigurasjonsfiler organisert i en mappe (for eksempel, <filename>~/.ssh/</filename>). Noen programmer (for eksempel nettleseren Iceweasel) bruker også sin mappe for å lagre et mellomlager med nedlastede data. Dette betyr at disse katalogene kan ende med å bruke mye diskplass."

msgid "These configuration files stored directly in a user's home directory, often collectively referred to as <emphasis>dotfiles</emphasis>, have long proliferated to the point that these directories can be quite cluttered with them. Fortunately, an effort led collectively under the FreeDesktop.org umbrella has resulted in the “XDG Base Directory Specification”, a convention that aims at cleaning up these files and directory. This specification states that configuration files should be stored under <filename>~/.config</filename>, cache files under <filename>~/.cache</filename>, and application data files under <filename>~/.local</filename> (or subdirectories thereof). This convention is slowly gaining traction, and several applications (especially graphical ones) have started following it."
msgstr "Disse konfigurasjonsfilene som er lagret direkte i brukerens hjemmekatalog, som ofte kollektivt er referert til som <emphasis>dotfiles</emphasis>, har lenge formert seg til det punktet at disse mappene kan bli ganske rotete. Heldigvis resulterte en innsats gjennomført i fellesskap i regi av FreeDesktop.org-paraplyen, i «XDG Base Directory Specification», en konvensjon (avtale) som tar sikte på å rydde opp i disse filene og mappene. Denne spesifikasjonen sier at konfigurasjonsfiler bør lagres under <filename>~/.config</filename>, hurtiglagerfiler under <filename>~ /.cache</filename>, og applikasjonsdatafiler under <filename>~/.local</filename> (eller undermapper under denne). Denne konvensjonen er langsomt i ferd med å få trekkraft, og flere programmer (spesielt de grafiske) har begynt å følge den."

msgid "Graphical desktops usually display the contents of the <filename>~/Desktop/</filename> directory (or whatever the appropriate translation is for systems not configured in English) on the desktop (ie, what is visible on screen once all applications are closed or iconized)."
msgstr "Grafiske skrivebord viser vanligvis innholdet i <filename>~/Desktop/</filename>-katalogen på skrivebordet (eller hva den riktige oversettelsen er for systemer som ikke er konfigurert på engelsk, dvs. det som er synlig på skjermen når alle programmer er lukket eller vises som ikoner)."

msgid "Finally, the email system sometimes stores incoming emails into a <filename>~/Mail/</filename> directory."
msgstr "Til slutt, e-postsystemet lagrer noen ganger innkommende e-poster til en <filename>~/Mail/</filename>-mappe."

msgid "Inner Workings of a Computer: the Different Layers Involved"
msgstr "Datamaskinens indre arbeid: de forskjellige involverte lagene"

msgid "A computer is often considered as something rather abstract, and the externally visible interface is much simpler than its internal complexity. Such complexity comes in part from the number of pieces involved. However, these pieces can be viewed in layers, where a layer only interacts with those immediately above or below."
msgstr "En datamaskin er ofte betraktet som noe heller abstrakt, og det ytre, synlige grensesnittet er mye enklere enn den interne kompleksiteten. Slik kompleksitet kommer delvis fra antallet deler som inngår. Imidlertid kan disse delene sees i lag, hvor et lag bare vekselvirker (samhandler) med de umiddelbart over eller under."

msgid "An end-user can get by without knowing these details… as long as everything works. When confronting a problem such as, “The internet doesn't work!”, the first thing to do is to identify in which layer the problem originates. Is the network card (hardware) working? Is it recognized by the computer? Does the Linux kernel see it? Are the network parameters properly configured? All these questions isolate an appropriate layer and focus on a potential source of the problem."
msgstr "En sluttbruker kan klare seg uten å kunne disse detaljene ... så lenge alt fungerer. Når man møter et problem som «Internett fungerer ikke!», er den første tingen å gjøre å identifisere i hvilket lag problemet stammer fra. Fungerer nettverkskortet (hardvare/maskinvaren)? Er det anerkjent av datamaskinen? Ser Linux-kjernen det? Er nettverksparametrene riktig satt opp? Alle disse spørsmålene avgrenser et passende lag, og fokuserer på en potensiell problemkilde."

msgid "The Deepest Layer: the Hardware"
msgstr "Det dypeste laget: hardvaren (maskinvaren)"

msgid "<primary>IDE</primary>"
msgstr "<primary>IDE</primary>"

msgid "<primary>SCSI</primary>"
msgstr "<primary>SCSI</primary>"

msgid "<primary>Serial ATA</primary>"
msgstr "<primary>Seriell ATA</primary>"

msgid "<primary>Parallel ATA</primary>"
msgstr "<primary>Parallel ATA</primary>"

msgid "<primary>ATA</primary>"
msgstr "<primary>ATA</primary>"

msgid "<primary>IEEE 1394</primary>"
msgstr "<primary>IEEE 1394</primary>"

msgid "<primary>Firewire</primary>"
msgstr "<primary>Firewire</primary>"

msgid "<primary>USB</primary>"
msgstr "<primary>USB</primary>"

#, fuzzy
msgid "Let us start with a basic reminder that a computer is, first and foremost, a set of hardware elements. There is generally a main board (known as the <emphasis>motherboard</emphasis>), with one (or more) processor(s), some RAM, device controllers, and extension slots for option boards (for other device controllers). Most noteworthy among these controllers are IDE (Parallel ATA), SCSI and Serial ATA, for connecting to storage devices such as hard disks. Other controllers include USB, which is able to host a great variety of devices (ranging from webcams to thermometers, from keyboards to home automation systems) and IEEE 1394 (Firewire). These controllers often allow connecting several devices so the complete subsystem handled by a controller is therefore usually known as a “bus”. Option boards include graphics cards (into which monitor screens will be plugged), sound cards, network interface cards, and so on. Some main boards are pre-built with these features, and don't need option boards."
msgstr "La oss starte med en grunnleggende påminnelse om at en datamaskin først og fremst er et sett med maskinvareelementer. Det er generelt et hovedkort (kjent som <emphasis>motherboard (hovedkortet)</emphasis>), med en (eller flere) prosessor(er), noe RAM, enhetskontrollere, og forlengelsesspor for tilleggskort (for andre enhetskontrollere). Mest bemerkelsesverdige blant disse kontrollerne er IDE (Parallel ATA), SCSI og Serial ATA, til å koble til lagringsenheter som harddisker. Andre kontrollere inkluderer USB, som er i stand til å være vert for et stort utvalg enheter (alt fra nettkameraer til termometre, fra tastaturer til hjemmeautomasjonssystemer) og IEEE 1394 (Firewire). Disse kontrollerne tillater ofte tilkobling av flere enheter slik at hele delsystemet håndteres av en kontroller, og derfor vanligvis er kjent som en «buss». Opsjonskort inkluderer grafikkort (som overvåkningsskjermer kan plugges til), lydkort, nettverkskort, og så videre. Noen av hovedkortene er forhåndsbygget med disse funksjonene, og trenger ikke tilleggskort."

msgid "<emphasis>IN PRACTICE</emphasis> Checking that the hardware works"
msgstr "<emphasis>I PRAKSIS</emphasis> Å sjekke at maskinvaren virker"

msgid "Checking that a piece of hardware works can be tricky. On the other hand, proving that it doesn't work is sometimes quite simple."
msgstr "Å kontrollere at en maskinvaredel virker, kan være vanskelig. På den annen side, å bevise at den noen ganger ikke virker er ganske enkelt."

msgid "A hard disk drive is made of spinning platters and moving magnetic heads. When a hard disk is powered up, the platter motor makes a characteristic whir. It also dissipates energy as heat. Consequently, a hard disk drive that stays cold and silent when powered up is broken."
msgstr "En harddisk er laget av spinnende plater og bevegelige magnetiske hoder. Når en harddisk er slått på, avgir tallerkenmotoren en karakteristisk svirring. Den avgir også energi som varme. Følgelig er en harddisk som forblir kald og stille, når den slås på, gått i stykker."

msgid "Network cards often include LEDs displaying the state of the link. If a cable is plugged in and leads to a working network hub or switch, at least one LED will be on. If no LED lights up, either the card itself, the network device, or the cable between them, is faulty. The next step is therefore testing each component individually."
msgstr "Nettverkskort inkluderer ofte lysdioder som viser tilstanden til linken. Hvis en kabel er koblet til, og fører til et fungerende nettverksnav eller -veksler, vil minst én LED være på. Hvis ingen LED lyser opp, er enten kortet selv, nettverksenheten, eller kabelen mellom dem, defekt. Det neste trinnet er derfor å teste hver enkelt komponent."

msgid "Some option boards — especially 3D video cards — include cooling devices, such as heat sinks and/or fans. If the fan does not spin even though the card is powered up, a plausible explanation is the card overheated. This also applies to the main processor(s) located on the main board."
msgstr "Noen opsjonskort - spesielt 3D-skjermkort - inkluderer avkjølingsenheter, for eksempel kjøleribber og/eller vifter. Hvis viften ikke spinner selv om kortet er slått på, er det en plausibel forklaring at kortet er overopphetet. Dette gjelder også for hovedprosessoren(e) som er plassert på hovedkortet ."

msgid "The Starter: the BIOS or UEFI"
msgstr "Starteren: BIOS eller UEFI"

msgid "<primary>BIOS</primary>"
msgstr "<primary>BIOS</primary>"

msgid "<primary>UEFI</primary>"
msgstr "<primary>UEFI</primary>"

msgid "<primary>Master Boot Record (MBR)</primary>"
msgstr "<primary>Master Boot Record (MBR)</primary>"

msgid "Hardware, on its own, is unable to perform useful tasks without a corresponding piece of software driving it. Controlling and interacting with the hardware is the purpose of the operating system and applications. These, in turn, require functional hardware to run."
msgstr "På egen hånd er maskinvare ute av stand til å utføre nyttige oppgaver uten et samsvarende dataprogram som kjører den. Kontroll og samspill med maskinvaren er hensikten med operativsystemet og programmene. Disse krever i sin tur funksjonell maskinvare for å kjøre."

msgid "This symbiosis between hardware and software does not happen on its own. When the computer is first powered up, some initial setup is required. This role is assumed by the BIOS or UEFI, a piece of software embedded into the main board that runs automatically upon power-up. Its primary task is searching for software it can hand over control to. Usually, in the BIOS case, this involves looking for the first hard disk with a boot sector (also known as the <emphasis>master boot record</emphasis> or <acronym>MBR</acronym>), loading that boot sector, and running it. From then on, the BIOS is usually not involved (until the next boot). In the case of UEFI, the process involves scanning disks to find a dedicated EFI partition containing further EFI applications to execute."
msgstr "Denne symbiosen mellom maskinvare og programvare skjer ikke av seg selv. Når datamaskinen først er slått på, kreves det en innledende konfigurering. Denne rollen er antatt av BIOS eller UEFI, et dataprogram innebygd i hovedkortet og som kjører automatisk ved oppstart. Den primære oppgaven er å søke etter programvare som det kan overlate kontrollen til. Vanligvis, i BIOS tilfelle, iinnebærer dette å se etter den første harddisken med en oppstartssektor  (også kjent som <emphasis>master boot record</emphasis> eller <acronym>MBR</acronym>), laster oppstartssektoren, og kjører den. Fra da av er BIOS vanligvis ikke involvert (til neste oppstart). I tilfellet med UEFI, innebærer prosessen skanning av disker for å finne en øremerket EFI-partisjon som inneholder ytterligere EFI-programmer for kjøring."

msgid "<emphasis>TOOL</emphasis> Setup, the BIOS/UEFI configuration tool"
msgstr "<emphasis>VERKTØY</emphasis> Oppsett, BIOS/UEFI-konfigurasjonsverktøyet"

msgid "<primary><emphasis>Setup</emphasis></primary>"
msgstr "<primary><emphasis>Oppsett</emphasis></primary>"

msgid "The BIOS/UEFI also contains a piece of software called Setup, designed to allow configuring aspects of the computer. In particular, it allows choosing which boot device is preferred (for instance, the floppy disk or CD-ROM drive), setting the system clock, and so on. Starting Setup usually involves pressing a key very soon after the computer is powered on. This key is often <keycap>Del</keycap> or <keycap>Esc</keycap>, sometimes <keycap>F2</keycap> or <keycap>F10</keycap>. Most of the time, the choice is flashed on screen while booting."
msgstr "BIOS/UEFI inneholder også en programvare som heter Setup, designet for å tillate datamaskinens konfigueringsaspekter. Spesielt tillater den å velge hvilke oppstartsenhet som er å foretrekke (for eksempel diskett eller CD-ROM-stasjonen), å sette systemklokken, og så videre. Å starte Setup innebærer vanligvis å trykke en tast ganske snart etter at datamaskinen er slått på. Denne nøkkelen er ofte <keycap>Del</keycap> eller <keycap>Esc</keycap>, noen ganger <keycap>F2</keycap> eller <keycap>F10</keycap>. Mesteparten av tiden blinkes valget på skjermen under oppstart."

msgid "The boot sector (or the EFI partition), in turn, contains another piece of software, called the bootloader, whose purpose is to find and run an operating system. Since this bootloader is not embedded in the main board but loaded from disk, it can be smarter than the BIOS, which explains why the BIOS does not load the operating system by itself. For instance, the bootloader (often GRUB on Linux systems) can list the available operating systems and ask the user to choose one. Usually, a time-out and default choice is provided. Sometimes the user can also choose to add parameters to pass to the kernel, and so on. Eventually, a kernel is found, loaded into memory, and executed."
msgstr "Oppstartssektoren (eller EFI-partisjonen), inneholder i sin tur et annet dataprogram, kalt oppstartslaster, med formålet å finne og kjøre et operativsystem. Siden denne oppstartslasteren ikke er innebygd i hovedkortet, men lastet fra disk, kan det være smartere enn BIOS, noe som forklarer hvorfor BIOS ikke laster operativsystemet selv. For eksempel kan oppstartslasteren (ofte GRUB på Linux-systemer) liste tilgjengelige operativsystemer, og be brukeren om å velge en. Vanligvis er et tidsavbrudd og standardvalg gitt. Noen ganger kan brukeren også velge å legge til parametere som skal sendes til kjernen, og så videre. Til slutt blir en kjerne funnet, lastet inn i minnet, og utført."

msgid "<emphasis>NOTE</emphasis> UEFI, a modern replacement to the BIOS"
msgstr "<emphasis>NOTE</emphasis> UEFI, en moderne erstatning for BIOS"

msgid "<primary>Secure Boot</primary>"
msgstr "<primary>Sikker oppstart</primary>"

msgid "UEFI is a relatively recent development. Most new computers will support UEFI booting, but usually they also support BIOS booting alongside for backwards compatibility with operating systems that are not ready to exploit UEFI."
msgstr "UEFI er en relativt ny utvikling. De fleste nye datamaskiner vil støtte UEFIs oppstart, men som regel støtter de også BIOS-oppstart samtidig for bakoverkompatibiliteten til operativsystemer som ikke er klare til å bruke UEFI."

msgid "This new system gets rid of some of the limitations of BIOS booting: with the usage of a dedicated partition, the bootloaders no longer need special tricks to fit in a tiny <emphasis>master boot record</emphasis> and then discover the kernel to boot. Even better, with a suitably built Linux kernel, UEFI can directly boot the kernel without any intermediary bootloader. UEFI is also the basic foundation used to deliver <emphasis>Secure Boot</emphasis>, a technology ensuring that you run only software validated by your operating system vendor."
msgstr "Dette nye systemet blir kvitt noen av begrensningene til BIOS-oppstart. Med bruk av en dedikert partisjon, trenger ikke oppstartsladeren lenger spesielle triks for å få plass i en liten <emphasis>master boot record (applikasjonsnivå)</emphasis>, og så oppdage kjernen for å starte opp. Enda bedre, med en passende bygget Linux-kjerne, kan UEFI starte kjernen direkte uten noen mellomledds oppstartslaster. UEFI er også fundamentet for å levere <emphasis>Secure Boot (sikker oppstart)</emphasis>, en teknologi som sikrer at du bare kjører programvare godkjent av din operativsystemleverandør."

msgid "The BIOS/UEFI is also in charge of detecting and initializing a number of devices. Obviously, this includes the IDE/SATA devices (usually hard disk(s) and CD/DVD-ROM drives), but also PCI devices. Detected devices are often listed on screen during the boot process. If this list goes by too fast, use the <keycap>Pause</keycap> key to freeze it for long enough to read. Installed PCI devices that don't appear are a bad omen. At worst, the device is faulty. At best, it is merely incompatible with the current version of the BIOS or main board. PCI specifications evolve, and old main boards are not guaranteed to handle newer PCI devices."
msgstr "BIOS/ EFI er også ansvarlig for å oppdage og initialisere en rekke enheter. Selvfølgelig omfatter dette IDE/SATA-enheter (vanligvis harddisken(e) og CD/DVD-ROM-stasjoner), men også PCI-enheter. Oppdagede enheter blir ofte oppført på skjermen under oppstartsprosessen. Hvis denne listen går for fort, kan du bruke <keycap>Pause</keycap>-nøkkelen til å fryse den lenge nok til å få den lest. Installerte PCI-enheter som ikke vises er et dårlig tegn. I verste fall er enheten defekt. I beste fall er den bare inkompatibel med den gjeldende versjonen av BIOS eller hovedkortet. PCI-spesifikasjoner utvikler seg, og gamle hovedkort er ikke garantert for å håndtere nyere PCI-enheter."

msgid "The Kernel"
msgstr "Kjernen"

msgid "Both the BIOS/UEFI and the bootloader only run for a few seconds each; now we are getting to the first piece of software that runs for a longer time, the operating system kernel. This kernel assumes the role of a conductor in an orchestra, and ensures coordination between hardware and software. This role involves several tasks including: driving hardware, managing processes, users and permissions, the filesystem, and so on. The kernel provides a common base to all other programs on the system."
msgstr "Både BIOS/UEFI og oppstartslasteren kjører bare noen få sekunder hver. Nå kommer vi til en programvaredel som kjører i lengre tid, operativsystemkjernen. Denne kjernen tar rollen som en dirigent i et orkester, og sikrer koordinering mellom maskinvare og programvare. Denne rollen innebærer flere oppgaver inkludert: Å kjøre maskinvare, administrere prosesser, brukere og tillatelser, filsystemet, og så videre. Kjernen gir en felles basis for alle andre programmer på systemet."

msgid "The User Space"
msgstr "Brukerrommet"

msgid "Although everything that happens outside of the kernel can be lumped together under “user space”, we can still separate it into software layers. However, their interactions are more complex than before, and the classifications may not be as simple. An application commonly uses libraries, which in turn involve the kernel, but the communications can also involve other programs, or even many libraries calling each other."
msgstr "Selv om alt som skjer utenfor kjernen kan bli samlet sammen under «brukerrom», kan vi likevel skille det inn i lag med programvare. Men samhandlingene deres er mer komplekse enn før, og klassifiseringene behøver ikke å være så enkle. Et program bruker ofte biblioteker, som i sin tur berører kjernen, men kommunikasjonen kan også involvere andre programmer, eller til og med mange biblioteker som kontakter hverandre."

msgid "Some Tasks Handled by the Kernel"
msgstr "Noen oppgaver som håndteres av kjernen"

msgid "Driving the Hardware"
msgstr "Å drifte maskinvaren"

msgid "The kernel is, first and foremost, tasked with controlling the hardware parts, detecting them, switching them on when the computer is powered on, and so on. It also makes them available to higher-level software with a simplified programming interface, so applications can take advantage of devices without having to worry about details such as which extension slot the option board is plugged into. The programming interface also provides an abstraction layer; this allows video-conferencing software, for example, to use a webcam independently of its make and model. The software can just use the <emphasis>Video for Linux</emphasis> (V4L) interface, and the kernel translates the function calls of this interface into the actual hardware commands needed by the specific webcam in use."
msgstr "Kjernen har først og fremst som oppgave å kontrollere maskinvaretilbehøret, oppdage det, slå det på når datamaskinen blir slått på, og så videre. Det gjør dem også tilgjengelige på et høyere nivå programvare med et forenklet programmeringsgrensesnitt, slik at programmene kan dra nytte av enheter uten å måtte bekymre seg om detaljer, slik som hvilken kortplass det valgte kortet er satt inn i. Programgrensesnittet gir også et abstraksjonslag; det tillater for eksempel at programvare for videokonferanser kan bruke et nettkamera uavhengig av merke og modell. Programvaren kan bare bruke grensesnittet <emphasis>Video for Linux</emphasis> (V4L), og kjernen oversetter funksjonspåkallingene i dette grensesnittet til de aktuelle maskinvarekommandoene som trengs når nettkameraet brukes."

msgid "<indexterm><primary><command>lspci</command></primary></indexterm> <indexterm><primary><command>lsusb</command></primary></indexterm> <indexterm><primary><command>lsdev</command></primary></indexterm> <indexterm><primary><command>lspcmcia</command></primary></indexterm> The kernel exports many details about detected hardware through the <filename>/proc/</filename> and <filename>/sys/</filename> virtual filesystems. Several tools summarize those details. Among them, <command>lspci</command> (in the <emphasis role=\"pkg\">pciutils</emphasis> package) lists PCI devices, <command>lsusb</command> (in the <emphasis role=\"pkg\">usbutils</emphasis> package) lists USB devices, and <command>lspcmcia</command> (in the <emphasis role=\"pkg\">pcmciautils</emphasis> package) lists PCMCIA cards. These tools are very useful for identifying the exact model of a device. This identification also allows more precise searches on the web, which in turn, lead to more relevant documents."
msgstr "<indexterm><primary><command>lspci</command></primary></indexterm> <indexterm><primary><command>lsusb</command></primary></indexterm> <indexterm><primary><command>lsdev</command></primary></indexterm> <indexterm><primary><command>lspcmcia</command></primary></indexterm> Kjernen eksporterer mange detaljer om programvare den finner med <filename>/proc/</filename> og <filename>/sys/</filename>-virtuelle filsystemer. Flere verktøy oppsummerer disse detaljene. Blant dem,<command>lspci</command> (i <emphasis role=\"pkg\">pciutils</emphasis> -pakken) lister PCI-enheter, <command>lsusb</command> (i <emphasis role=\"pkg\">usbutils</emphasis>-pakke) lister USB-enheter, og <command>lspcmcia</command> (i <emphasis role=\"pkg\">pcmciautils</emphasis>-pakken) lister PCMCIA-kort. Disse verktøyene er meget nyttige til å identifisere den eksakte modellen for enheten. Denne identifikasjonen gir også mer presise søk på nettet, noe som i sin tur fører til mer relevant dokumentasjon."

msgid "Example of information provided by <command>lspci</command> and <command>lsusb</command>"
msgstr "Eksempel på informasjon fra <command>lspci</command> og <command>lsusb</command>"

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>lspci</userinput>\n"
"<computeroutput>[...]\n"
"00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)\n"
"00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)\n"
"00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)\n"
"[...]\n"
"01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)\n"
"02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)\n"
"$ </computeroutput><userinput>lsusb</userinput>\n"
"<computeroutput>Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.\n"
"Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.\n"
"Bus 005 Device 007: ID 045e:00dd Microsoft Corp.\n"
"Bus 005 Device 006: ID 046d:c03d Logitech, Inc.\n"
"[...]\n"
"Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth\n"
"</computeroutput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>lspci</userinput>\n"
"<computeroutput>[...]\n"
"00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)\n"
"00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)\n"
"00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)\n"
"[...]\n"
"01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)\n"
"02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)\n"
"$ </computeroutput><userinput>lsusb</userinput>\n"
"<computeroutput>Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.\n"
"Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.\n"
"Bus 005 Device 007: ID 045e:00dd Microsoft Corp.\n"
"Bus 005 Device 006: ID 046d:c03d Logitech, Inc.\n"
"[...]\n"
"Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth\n"
"</computeroutput>"

msgid "These programs have a <literal>-v</literal> option, that lists much more detailed (but usually not necessary) information. Finally, the <command>lsdev</command> command (in the <emphasis role=\"pkg\">procinfo</emphasis> package) lists communication resources used by devices."
msgstr "Disse programmene har et <literal>-v</literal>-valg som lister mye mer detaljert (men vanligvis ikke nødvendig) informasjon. Til slutt¸ <command>lsdev</command>-kommandoen (i <emphasis role=\"pkg\">procinfo</emphasis>-pakken) lister kommunikasjonsressurser som enhetene bruker."

msgid "Applications often access devices by way of special files created within <filename>/dev/</filename> (see sidebar <xref linkend=\"sidebar.special-files\" />). These are special files that represent disk drives (for instance, <filename>/dev/hda</filename> and <filename>/dev/sdc</filename>), partitions (<filename>/dev/hda1</filename> or <filename>/dev/sdc3</filename>), mice (<filename>/dev/input/mouse0</filename>), keyboards (<filename>/dev/input/event0</filename>), soundcards (<filename>/dev/snd/*</filename>), serial ports (<filename>/dev/ttyS*</filename>), and so on."
msgstr "Programmer kobler seg ofte til enheter ved hjelp av spesielle filer som er opprettet innenfor <filename>/dev/</filename> (se sidestolpe <xref linkend=\"sidebar.special-files\" />). Dette er spesielle filer som representerer platelager (for eksempel, <filename>/dev/hda</filename> og <filename>/dev/sdc</filename>), partisjoner (<filename>/dev/hda1</filename> eller <filename>/dev/sdc3</filename>), mus (<filename>/dev/input/mouse0</filename>), tastatur (<filename>/dev/input/event0</filename>), lydkort (<filename>/dev/snd/*</filename>), serieporter (<filename>/dev/ttyS*</filename>), og så videre."

msgid "Filesystems"
msgstr "Filsystemer"

msgid "<primary>filesystem</primary>"
msgstr "<primary>filsystem</primary>"

msgid "<primary>system, filesystem</primary>"
msgstr "<primary>system, filsystem</primary>"

msgid "Filesystems are one of the most prominent aspects of the kernel. Unix systems merge all the file stores into a single hierarchy, which allows users (and applications) to access data simply by knowing its location within that hierarchy."
msgstr "Filsystemer er en av kjernens mest fremtredende aspekter. Unix-systemer fletter alle fillagre inn i et enkelt hierarki, som gir brukere (og programmer) tilgang til data ved å kjenne til plasseringen i det hierarkiet."

msgid "The starting point of this hierarchical tree is called the root, <filename>/</filename>. This directory can contain named subdirectories. For instance, the <literal>home</literal> subdirectory of <filename>/</filename> is called <filename>/home/</filename>. This subdirectory can, in turn, contain other subdirectories, and so on. Each directory can also contain files, where the actual data will be stored. Thus, the <filename>/home/rmas/Desktop/hello.txt</filename> name refers to a file named <literal>hello.txt</literal> stored in the <literal>Desktop</literal> subdirectory of the <literal>rmas</literal> subdirectory of the <literal>home</literal> directory present in the root. The kernel translates between this naming system and the actual, physical storage on a disk."
msgstr "Startpunktet til dette hierarkiske treet kalles roten, <filename>/</filename>. Denne katalogen kan inneholde navngitte underkataloger. For eksempel, <literal>home</literal>-underkatalog i <filename>/</filename> kalles <filename>/home/</filename>. Denne underkatalogen kan i sin tur inneholde andre underkataloger, og så videre. Hver katalog kan også inneholde filer, hvor de faktiske dataene blir lagret. Dermed refererer <filename>/home/rmas/Desktop/hello.txt</filename>-navnet til en fil med navnet <literal>hello.txt</literal> lagret i <literal>Desktop</literal>-underkatalog i <literal>rmas</literal>-underkatalogen i <literal>home</literal>-katalogen i roten. Kjernen oversetter mellom dette navnesystemet og den faktiske, fysiske lagring på en disk."

msgid "Unlike other systems, there is only one such hierarchy, and it can integrate data from several disks. One of these disks is used as the root, and the others are “mounted” on directories in the hierarchy (the Unix command is called <command>mount</command>); these other disks are then available under these “mount points”. This allows storing users' home directories (traditionally stored within <filename>/home/</filename>) on a second hard disk, which will contain the <literal>rhertzog</literal> and <literal>rmas</literal> directories. Once the disk is mounted on <filename>/home/</filename>, these directories become accessible at their usual locations, and paths such as <filename>/home/rmas/Desktop/hello.txt</filename> keep working."
msgstr "I motsetning til andre systemer, er det bare ett slikt hierarki, og det kan integrere data fra flere disker. En av disse diskene anvendes som referanse, og de andre er «montert» på kataloger i hierarkiet (Unix-kommandoen er kalt <command>mount</command>); disse andre diskene er deretter tilgjengelige under disse «monteringspunktene». Dette tillater lagring av brukernes hjemmeområder (tradisjonelt lagret i <filename>/home/</filename>) på en annen harddisk, som da vil inneholde <literal>rhertzog</literal> og <literal>rmas</literal>-katalogene. Så snart disken er montert på <filename>/home/</filename>, blir disse katalogene tilgjengelige på sine vanlige steder, og stier som <filename>/home/rmas/Desktop/hello.txt</filename> fortsetter å virke."

msgid "<primary><command>mkfs</command></primary>"
msgstr "<primary><command>mkfs</command></primary>"

msgid "There are many filesystem formats, corresponding to many ways of physically storing data on disks. The most widely known are <emphasis>ext2</emphasis>, <emphasis>ext3</emphasis> and <emphasis>ext4</emphasis>, but others exist. For instance, <emphasis>vfat</emphasis> is the system that was historically used by DOS and Windows operating systems, which allows using hard disks under Debian as well as under Windows. In any case, a filesystem must be prepared on a disk before it can be mounted and this operation is known as “formatting”. Commands such as <command>mkfs.ext3</command> (where <command>mkfs</command> stands for <emphasis>MaKe FileSystem</emphasis>) handle formatting. These commands require, as a parameter, a device file representing the partition to be formatted (for instance, <filename>/dev/sda1</filename>). This operation is destructive and should only be run once, except if one deliberately wishes to wipe a filesystem and start afresh."
msgstr "Det er mange filsystemformater, og tilsvarende mange måter å lagre data fysisk på disker. De mest kjente er <emphasis>ext2</emphasis>, <emphasis>ext3</emphasis> og <emphasis>ext4</emphasis>, men også andre finnes. For eksempel er <emphasis>vfat</emphasis> det systemet som  historisk ble brukt av DOS og Windows-operativsystemer, som gjør det mulig å bruke harddisker under Debian så vel som under Windows. I alle fall må et filsystem være forberedt på en disk før den kan monteres, og denne operasjonen er kjent som «formatering». Kommandoer som <command>mkfs.ext3</command> (der <command>mkfs</command> står for <emphasis>MaKe FileSystem</emphasis>) formatteringsbehandling. Disse kommandoer krever, som et parameter, en enhetsfil som representerer den partisjonen som skal formateres (f.eks <filename>/dev/sda1</filename>). Denne operasjonen er destruktiv, og bør bare kjøres en gang, bortsett fra hvis man bevisst ønsker å stryke ut et filsystem og starte på nytt."

msgid "There are also network filesystems, such as <acronym>NFS</acronym>, where data is not stored on a local disk. Instead, data is transmitted through the network to a server that stores and retrieves them on demand. The filesystem abstraction shields users from having to care: files remain accessible in their usual hierarchical way."
msgstr "Det er også filsystemer i nettverk, slik som <acronym>NFS</acronym>, der data ikke er lagret på en lokal disk. I stedet overføres data via nettverket til en tjener som lagrer og henter dem ved behov. Filsystemets atskillelse skjermer brukere fra å være bekymret: filer forblir tilgjengelige på sin vanlige hierarkiske måte."

msgid "Shared Functions"
msgstr "Delte funksjoner"

msgid "Since a number of the same functions are used by all software, it makes sense to centralize them in the kernel. For instance, shared filesystem handling allows any application to simply open a file by name, without needing to worry where the file is stored physically. The file can be stored in several different slices on a hard disk, or split across several hard disks, or even stored on a remote file server. Shared communication functions are used by applications to exchange data independently of the way the data is transported. For instance, transport could be over any combination of local or wireless networks, or over a telephone landline."
msgstr "Siden en rekke av de samme funksjonene brukes av all programvare, er det fornuftig å sentralisere dem i kjernen. For eksempel tillater et delt filsystem at et hvilket som helst program bare kan åpne en fil etter navn, uten å trenger å bekymre seg om hvor filen er lagret fysisk. Filen kan lagres i flere forskjellige disker på en harddisk, eller delt over flere harddisker, eller til og med lagret på en ekstern filtjener. Delte kommunikasjonsfunksjoner blir brukt av programmer til å utveksle data uavhengig av måten dataene transporteres. For eksempel kan transport være over hvilken som helst kombinasjon av lokale eller trådløse nettverk, eller over en fasttelefon."

msgid "<primary><emphasis>pid</emphasis></primary>"
msgstr "<primary><emphasis>pid</emphasis></primary>"

msgid "A process is a running instance of a program. This requires memory to store both the program itself and its operating data. The kernel is in charge of creating and tracking them. When a program runs, the kernel first sets aside some memory, then loads the executable code from the filesystem into it, and then starts the code running. It keeps information about this process, the most visible of which is an identification number known as <emphasis>pid</emphasis> (<emphasis>process identifier</emphasis>)."
msgstr "En prosess er en kjørende forekomst av et program. Dette krever minne til å lagre både selve programmet og dets driftsdata. Kjernen er ansvarlig for å opprette og spore dem. Når et program kjøres, setter kjernen først av litt minne, deretter laster den kjørbar kode fra filsystemet inn i det, og starter så å kjøre koden. Den tar vare på informasjon om denne prosessen, i hvilken det mest synlige er et identifikasjonsnummer som kalles <emphasis>pid</emphasis> (<emphasis>process identifier</emphasis>)."

msgid "Unix-like kernels (including Linux), like most other modern operating systems, are capable of “multi-tasking”. In other words, they allow running many processes “at the same time”. There is actually only one running process at any one time, but the kernel cuts time into small slices and runs each process in turn. Since these time slices are very short (in the millisecond range), they create the illusion of processes running in parallel, although they are actually only active during some time intervals and idle the rest of the time. The kernel's job is to adjust its scheduling mechanisms to keep that illusion, while maximizing the global system performance. If the time slices are too long, the application may not appear as responsive as desired. Too short, and the system loses time switching tasks too frequently. These decisions can be tweaked with process priorities. High-priority processes will run for longer and with more frequent time slices than low-priority processes."
msgstr "Unix-lignende kjerner (inkludert Linux), som de fleste andre moderne operativsystemer, er i stand til «fleroppgavekjøring». Med andre ord, de kan kjøre mange prosesser «samtidig». Det er faktisk bare en kjørende prosess til enhver tid, men kjernen forkorter tiden i små deler, og kjører hver prosess etter tur. Siden disse tidssnittene er meget korte (i millisekund-området), skaper de en illusjon av prosesser som kjører i parallell, selv om de faktisk bare er aktive i noen tidsintervall, og i tomgang resten av tiden. Kjernens jobb er å justere sine planleggingsmekanismer for å holde på denne illusjonen, og samtidig maksimere den globale systemytelsen. Dersom tidsintervallene er for lange, kan programmet ikke fremstå som så responsivt som ønskelig. For kort, og systemet mister tid på grunn av hyppig veksling mellom oppgaver. Disse beslutningene kan bli forskjøvet med prosessprioriteringer. Høyt prioriterte prosesser vil kjøre lenger, og med mer hyppige tidsintervaller enn lavt prioriterte prosesser."

msgid "<emphasis>NOTE</emphasis> Multi-processor systems (and variants)"
msgstr "<emphasis>NOTE</emphasis> Flerprosessorsystemer (og varianter)"

msgid "The limitation described above of only one process being able to run at a time, doesn't always apply. The actual restriction is that there can only be one running process <emphasis>per processor core</emphasis> at a time. Multi-processor, multi-core or “hyper-threaded” systems allow several processes to run in parallel. The same time-slicing system is still used, though, so as to handle cases where there are more active processes than available processor cores. This is far from unusual: a basic system, even a mostly idle one, almost always has tens of running processes."
msgstr "Begrensningen beskrevet ovenfor, at bare én prosess kan kjøre på ett tidspunkt, gjelder ikke alltid. Selve begrensningen er at det bare kan være en kjørende prosess <emphasis>per prosessorkjerne</emphasis> om gangen. Multiprosessor, multikjerne eller «hypertrådede» systemer tillater at flere prosesser kjører parallelt. Systemet med fleroppgavekjøring er fortsatt i bruk, slik som å håndtere tilfeller der det er flere aktive prosesser enn tilgjengelige prosessorkjerner. Dette er langt fra uvanlig. Et grunnleggende system, selv et stort sett inaktivt et, har nesten alltid et titalls prosesser som kjører."

msgid "Of course, the kernel allows running several independent instances of the same program. But each can only access its own time slices and memory. Their data thus remain independent."
msgstr "Selvfølgelig tillater kjernen å kjøre flere uavhengige prosesser med det samme programmet. Men hver kan bare få tilgang til sine egne tidsperioder og sitt eget minne. Deres data forblir dermed forbli uavhengig."

msgid "Rights Management"
msgstr "Å håndtere rettigheter"

msgid "Unix-like systems are also multi-user. They provide a rights management system that supports separate users and groups; it also allows control over actions based on permissions. The kernel manages data for each process, allowing it to control permissions. Most of the time, a process is identified by the user who started it. That process is only permitted to take those actions available to its owner. For instance, trying to open a file requires the kernel to check the process identity against access permissions (for more details on this particular example, see <xref linkend=\"sect.rights-management\" />)."
msgstr "Unix-lignende systemer er også flerbrukere. De gir et rettighetsforvaltningssystem som støtter egne brukere og grupper; det gir også kontroll over handlinger basert på tillatelser. Kjernen forvalter data for hver prosess, som tillater å kontrollere tillatelser. Mesteparten av tiden er en prosess identifisert med brukeren som startet den. Den prosessen er kun tillatt å gjøre det som er tilgjengelig for brukeren. For eksempel for å prøve å åpne en fil kreves det at kjernen kontrollerer prosessens identitet mot adgangstillatelser (for mer informasjon om dette eksempelet, se <xref linkend=\"sect.rights-management\" />)."

#, fuzzy
msgid "<primary>user space</primary>"
msgstr "<primary>brukerland</primary>"

#, fuzzy
msgid "<primary>kernel space</primary>"
msgstr "<primary>kjerneland</primary>"

msgid "“User space” refers to the runtime environment of normal (as opposed to kernel) processes. This does not necessarily mean these processes are actually started by users because a standard system normally has several “daemon” (or background) processes running before the user even opens a session. Daemon processes are also considered user-space processes."
msgstr "«Brukerområde» refererer til kjøretidsmiljøets normale prosesser (i motsetning til kjerneprosesser).  Dette betyr ikke nødvendigvis at disse prosessene faktisk er startet av brukere fordi et standardsystem normalt har flere «nisse»-prosesser (eller bakgrunnsprosesser)  som kjører før brukeren selv åpner en økt. Nisse-prosesser regnes også som brukerområdeprosesser."

msgid "<primary><command>init</command></primary>"
msgstr "<primary><command>init</command></primary>"

msgid "When the kernel gets past its initialization phase, it starts the very first process, <command>init</command>. Process #1 alone is very rarely useful by itself, and Unix-like systems run with many additional processes."
msgstr "Når kjernen kommer forbi, starter den aller første prosessen, <command>init</command>.  Prosess #1 er alene svært sjelden nyttig i seg selv, og Unix-lignende systemer kjører med mange prosesser i tillegg."

msgid "<primary><emphasis>fork</emphasis></primary>"
msgstr "<primary><emphasis>gaffel</emphasis></primary>"

msgid "First of all, a process can clone itself (this is known as a <emphasis>fork</emphasis>). The kernel allocates a new (but identical) process memory space, and another process to use it. At this time, the only difference between these two processes is their <emphasis>pid</emphasis>. The new process is usually called a child process, and the original process whose <emphasis>pid</emphasis> doesn't change, is called the parent process."
msgstr "Først av alt kan en prosess klone seg selv (dette er kjent som en<emphasis>gaffel</emphasis>). Kjernen tildeler et nytt (men identisk) prosessminne, og en annen prosess for å bruke det. På denne tiden er den eneste forskjellen mellom disse to prosessene deres <emphasis>pid</emphasis>. Den nye prosessen kalles vanligvis en barneprosess, og den opprinnelige prosessen, hvis <emphasis>pid</emphasis> ikke forandres, kalles foreldreprosessen."

msgid "Sometimes, the child process continues to lead its own life independently from its parent, with its own data copied from the parent process. In many cases, though, this child process executes another program. With a few exceptions, its memory is simply replaced by that of the new program, and execution of this new program begins. This is the mechanism used by the init process (with process number 1) to start additional services and execute the whole startup sequence. At some point, one process among <command>init</command>'s offspring starts a graphical interface for users to log in to (the actual sequence of events is described in more details in <xref linkend=\"sect.system-boot\" />)."
msgstr "Noen ganger fortsetter barneprosessen å leve sitt eget liv uavhengig av foreldreprosessen, med sine egne data kopiert fra den overordnede prosessen. I mange tilfeller kjører denne barneprosessen et annet program. Med noen få unntak, er minnet dens bare erstattet av det nye programmet, og gjennomføringen av dette nye programmet starter. Dette er mekanismen som brukes av init-prosessen (med prosess nummer 1) for å starte tilleggstjenester og gjennomføre hele oppstartsekvensen. På et tidspunkt starter en prosess blant <command>init</command>s avkom et grafisk grensesnitt som brukerne kan logge seg på (det faktiske hendelsesforløpet er beskrevet mer i detalj i <xref linkend=\"sect.system-boot\" />)."

#, fuzzy
msgid "When a process finishes the task for which it was started, it terminates. The kernel then recovers the memory assigned to this process, and stops giving it slices of running time. The parent process is told about its child process being terminated, which allows a process to wait for the completion of a task it delegated to a child process. This behavior is plainly visible in command-line interpreters (known as <emphasis>shells</emphasis>). When a command is typed into a shell, the prompt only comes back when the execution of the command is over. Most shells allow for running the command in the background, it is a simple matter of adding an <userinput>&amp;</userinput> to the end of the command. The prompt is displayed again right away, which can lead to problems if the command needs to display data of its own."
msgstr "Når en prosessen har fullført oppgaven den ble startet for, så avslutter den. Kjernen tar deretter tilbake minnet som er tilordnet denne prosessen, og slutter å dele ut tidsressurser den kan bruke til å kjøre. Foreldreprosessen blir fortalt at barneprosessen dens er avsluttet, noe som tillater en prosess å vente på fullføringen av en oppgave den delegerte til en barneprosess. Denne oppførselen vises tydelig i kommandolinjetolker (kjent som <emphasis>skall</emphasis>). Når en kommando er skrevet inn i et skall, kommer ledeteksten først tilbake når utførelsen av kommandoen er ferdig. De fleste skall tillater å kjøre kommandoen i bakgrunnen, som er så enkelt som å legge til <userinput>&amp;</userinput> på slutten av kommandoen. Ledeteksten vises igjen med en gang, noe som kan føre til problemer hvis kommandoen må vise sine egne data."

msgid "Daemons"
msgstr "Nisser"

msgid "<primary>daemon</primary>"
msgstr "<primary>nisse</primary>"

msgid "A “daemon” is a process started automatically by the boot sequence. It keeps running (in the background) to perform maintenance tasks or provide services to other processes. This “background task” is actually arbitrary, and does not match anything particular from the system's point of view. They are simply processes, quite similar to other processes, which run in turn when their time slice comes. The distinction is only in the human language: a process that runs with no interaction with a user (in particular, without any graphical interface) is said to be running “in the background” or “as a daemon”."
msgstr "En «nisse» er en prosess som startet automatisk ved oppstartssekvensen. Den fortsetter å kjøre (i bakgrunnen) for å utføre vedlikeholdsoppgaver, eller yte tjenester til andre prosesser. Denne «bakgrunnsoppgaven» er faktisk tilfeldig, og samsvarer ikke med noe bestemt fra systemets synspunkt. De er bare prosesser, ganske lik andre prosesser, som går igjen når deres tidskvote kommer. Forskjellen er bare i menneskelig språk: En prosess som går uten interaksjon med brukeren (særlig uten grafisk grensesnitt) sies å være kjørt «i bakgrunnen», eller «som en nisse»."

msgid "<emphasis>VOCABULARY</emphasis> Daemon, demon, a derogatory term?"
msgstr "<emphasis>ORDFORRÅD</emphasis> Nisse, demon, en nedsettende betegnelse?"

msgid "Although <emphasis>daemon</emphasis> term shares its Greek etymology with <emphasis>demon</emphasis>, the former does not imply diabolical evil, instead, it should be understood as a kind of helper spirit. This distinction is subtle enough in English; it is even worse in other languages where the same word is used for both meanings."
msgstr "Selv om <emphasis>nisse (daemon)</emphasis>-begrepet deler sin greske etymologi med <emphasis>demon</emphasis>, innebærer førstnevnte ikke noe diabolsk onde, i stedet skal den forstås som en slags hjelpende ånd. Dette skillet er subtilt nok i engelsk, men det er til og med verre i andre språk der samme ordet er brukt for begge betydninger."

msgid "Several such daemons are described in detail in <xref linkend=\"unix-services\" />."
msgstr "Forskjellige slike nisser er beskrevet i detalj i <xref linkend=\"unix-services\" />."

#, fuzzy
msgid "Inter-Process Communications"
msgstr "Inter-prosess kommunikasjoner (IPC)"

msgid "<primary>IPC</primary>"
msgstr "<primary>IPC</primary>"

#, fuzzy
msgid "<primary>Inter-Process Communications</primary>"
msgstr "<primary>Inter-Process Communications (Kommunikasjon mellom prosesser)</primary>"

msgid "An isolated process, whether a daemon or an interactive application, is rarely useful on its own, which is why there are several methods allowing separate processes to communicate together, either to exchange data or to control one another. The generic term referring to this is <emphasis>inter-process communication</emphasis>, or IPC for short."
msgstr "En isolert prosess, enten en nisse eller et interaktivt program, er sjelden nyttig i seg selv, noe som er grunnen til at det er flere metoder som lar separate prosesser kommunisere sammen, enten for å utveksle data, eller for å kontrollere hverandre. Det generiske begrepet for dette er <emphasis>inter-process communication</emphasis>, eller i kortform IPC."

msgid "The simplest IPC system is to use files. The process that wishes to send data writes it into a file (with a name known in advance), while the recipient only has to open the file and read its contents."
msgstr "Det enkleste IPC-systemet er å bruke filer. Prosessen som ønsker å sende data, skriver den inn i en fil (med et navn kjent på forhånd), mens mottakeren bare har å åpne filen, og lese innholdet."

msgid "<primary><emphasis>pipe</emphasis></primary>"
msgstr "<primary><emphasis>kanal</emphasis></primary>"

msgid "In the case where you do not wish to store data on disk, you can use a <emphasis>pipe</emphasis>, which is simply an object with two ends; bytes written in one end are readable at the other. If the ends are controlled by separate processes, this leads to a simple and convenient inter-process communication channel. Pipes can be classified into two categories: named pipes, and anonymous pipes. A named pipe is represented by an entry on the filesystem (although the transmitted data is not stored there), so both processes can open it independently if the location of the named pipe is known beforehand. In cases where the communicating processes are related (for instance, a parent and its child process), the parent process can also create an anonymous pipe before forking, and the child inherits it. Both processes will then be able to exchange data through the pipe without needing the filesystem."
msgstr "I tilfeller der du ikke ønsker å lagre data på disken, kan du bruke en <emphasis>kanal</emphasis> som rett og slett er et objekt med to ender; byte skrevet i den ene enden er lesbar i den andre. Dersom endene er styrt med separate prosesser, fører dette til en enkel og praktisk kommunikasjon mellom prosesser. Kanaler kan deles inn i to kategorier: Navngitte kanaler, og anonyme kanaler. En navngitt kanal er representert ved en oppføring i filsystemet (selv om de overførte data ikke er lagret der), slik at begge prosessene kan åpne det uavhengig om plasseringen av den navngitte kanalen er kjent på forhånd. I tilfeller hvor de kommuniserende prosessene er relatert (for eksempel en foreldre- og dens barneprosess), den overordnede prosessen kan også opprette en anonym kanal før forgreninger, og barnet arver det. Begge prosesser vil da være i stand til å utveksle data gjennom kanalen uten filsystemet."

msgid "<emphasis>IN PRACTICE</emphasis> A concrete example"
msgstr "<emphasis>I PRAKSIS</emphasis> Et konkret eksempel"

msgid "Let's describe in some detail what happens when a complex command (a <emphasis>pipeline</emphasis>) is run from a shell. We assume we have a <command>bash</command> process (the standard user shell on Debian), with <emphasis>pid</emphasis> 4374; into this shell, we type the command: <command>ls | sort</command> ."
msgstr "La oss beskrive i detalj hva som skjer når en kompleks kommando (en <emphasis>pipeline (kanal)</emphasis>) kjøres fra et skall. Vi antar vi har en <command>bash</command>-prosess (standard brukerskallet på Debian), med <emphasis>pid</emphasis> 4374; I dette skallet skriver vi kommandoen:<command>ls | sort</command>."

msgid "The shell first interprets the command typed in. In our case, it understands there are two programs (<command>ls</command> and <command>sort</command>), with a data stream flowing from one to the other (denoted by the <userinput>|</userinput> character, known as <emphasis>pipe</emphasis>). <command>bash</command> first creates an unnamed pipe (which initially exists only within the <command>bash</command> process itself)."
msgstr "Skallet tolker første kommandoen skrevet inn. I vårt tilfelle forstår det at det er to programmer (<command>ls</command> og <command>sort</command>), med en datastrøm som flyter fra den ene til den andre (merket med <userinput>|</userinput>-tegnet, kjent som <emphasis>pipe</emphasis>). <command>bash</command> oppretter først en ikke navngitt kanal (som i utgangspunktet bare eksisterer i selve <command>bash</command>-prosessen)."

msgid "Then the shell clones itself; this leads to a new <command>bash</command> process, with <emphasis>pid</emphasis> #4521 (<emphasis>pids</emphasis> are abstract numbers, and generally have no particular meaning). Process #4521 inherits the pipe, which means it is able to write in its “input” side; <command>bash</command> redirects its standard output stream to this pipe's input. Then it executes (and replaces itself with) the <command>ls</command> program, which lists the contents of the current directory. Since <command>ls</command> writes on its standard output, and this output has previously been redirected, the results are effectively sent into the pipe."
msgstr "Deretter kloner skallet seg selv. Dette fører til en ny  <command>bash</command>-prosess, med <emphasis>pid</emphasis> #4521 (<emphasis>pids</emphasis> er abstrakte tall, og har generelt ikke noen bestemt mening). Process #4521 arver kanalen/røret, noe som betyr at den er i stand til å skrive på sin «input»-side; <command>bash</command> omdirigeringer sin standard utgående strøm til dette rørets/kanalens inngang. Så utfører den (og erstatter seg med) <command>ls</command>-programmet, som viser innholdet i den gjeldende katalogen. Ettersom <command>ls</command> skriver til sine standard utdata, og denne produksjonen tidligere er omdirigert, blir resultatene effektivt sendt inn i kanalen/røret."

msgid "A similar operation happens for the second command: <command>bash</command> clones itself again, leading to a new <command>bash</command> process with pid #4522. Since it is also a child process of #4374, it also inherits the pipe; <command>bash</command> then connects its standard input to the pipe output, then executes (and replaces itself with) the <command>sort</command> command, which sorts its input and displays the results."
msgstr "En lignende operasjon skjer for den andre kommandoen: <command>bash</command> kloner seg igjen, noe som fører til en ny <command>bash</command>-prosess med pid #4522. Siden den også er en barneprosess fra #4374, arver den også kanalen; <command>bash</command> kobler deretter sin standard inngang til kanalens utgang, deretter kjøres (og erstatter seg med) <command>sort</command>-kommandoen, som sorterer sine innspill, og viser resultatene."

msgid "All the pieces of the puzzle are now set up: <command>ls</command> reads the current directory and writes the list of files into the pipe; <command>sort</command> reads this list, sorts it alphabetically, and displays the results. Processes numbers #4521 and #4522 then terminate, and #4374 (which was waiting for them during the operation), resumes control and displays the prompt to allow the user to type in a new command."
msgstr "Alle bitene i puslespillet er nå satt sammen: <command>ls</command> leser den gjeldende katalogen og skriver en liste over filer inn i kanalen; <command>sort</command> leser denne listen, sorterer den alfabetisk, og viser resultatene. Så avsluttes prosessnummer #4521 og #4522, og #4374 (som ventet på dem under operasjonen), gjenopptar kontrollen, og viser meldingen for å tillate brukeren å skrive inn en ny kommando."

msgid "Not all inter-process communications are used to move data around, though. In many situations, the only information that needs to be transmitted are control messages such as “pause execution” or “resume execution”. Unix (and Linux) provides a mechanism known as <emphasis>signals</emphasis>, through which a process can simply send a specific signal (chosen from a predefined list of signals) to another process. The only requirement is to know the <emphasis>pid</emphasis> of the target."
msgstr "Ikke all inter-prosesskommunikasjon brukes til å flytte data rundt. I mange situasjoner er den eneste informasjonen som må overføres, kontrollmeldinger som «pause utførelse» eller «gjenoppta kjøring». Unix (og Linux) gir en mekanisme som kalles <emphasis>signaler</emphasis>, gjennom hvilken en prosess bare kan sende et bestemt signal (valgt fra en forhåndsdefinert liste av signaler) til en annen prosess. Det eneste kravet er å kjenne til målets <emphasis>pid</emphasis>."

msgid "For more complex communications, there are also mechanisms allowing a process to open access, or share, part of its allocated memory to other processes. Memory now shared between them can be used to move data between the processes."
msgstr "For mer komplekse kommunikasjoner er det også mekanismer som tillater at en prosess åpner tilgang, eller deler, en del av sitt tildelte minne til andre prosesser. Minnet, som nå er delt mellom dem, kan brukes til å flytte data mellom prosessene."

msgid "Finally, network connections can also help processes communicate; these processes can even be running on different computers, possibly thousands of kilometers apart."
msgstr "Endelig, nettverkstilkoblinger kan også hjelpe prosesser å kommunisere; disse prosessene kan også kjøres på forskjellige datamaskiner, muligens tusenvis av kilometer fra hverandre."

msgid "It is quite standard for a typical Unix-like system to make use of all these mechanisms to various degrees."
msgstr "Det er ganske standard for et typisk Unix-lignende system i ulik grad å gjøre bruk av alle disse mekanismene."

msgid "Libraries"
msgstr "Biblioteker"

msgid "<primary>library (of functions)</primary>"
msgstr "<primary>bibliotek (funksjoner))</primary>"

msgid "Function libraries play a crucial role in a Unix-like operating system. They are not proper programs, since they cannot be executed on their own, but collections of code fragments that can be used by standard programs. Among the common libraries, you can find:"
msgstr "Funksjonsbibliotekene spiller en avgjørende rolle i et Unix-lignende operativsystem. De er ikke egentlig programmer, da de ikke kan kjøres på egen hånd, men er samlinger av kodefragmenter som kan brukes av standardprogrammer. Blant de vanligste biblioteker, kan du finne:"

msgid "the standard C library (<emphasis>glibc</emphasis>), which contains basic functions such as ones to open files or network connections, and others facilitating interactions with the kernel;"
msgstr "standard C biblioteket (<emphasis>glibc</emphasis>), som inneholder grunnleggende funksjoner som det å åpne filer eller nettverkstilkoblinger - og andre som legger til rette for interaksjoner med kjernen;"

msgid "graphical toolkits, such as Gtk+ and Qt, allowing many programs to reuse the graphical objects they provide;"
msgstr "grafiske verktøysett, for eksempel Gtk+ og Qt, som tillater at mange programmer gjenbruker de grafiske objektene de leverer;"

msgid "the <emphasis>libpng</emphasis> library, that allows loading, interpreting and saving images in the PNG format."
msgstr "<emphasis>libpng</emphasis>-biblioteket som tillater lasting, tolking og lagring av bilder i PNG-format."

msgid "Thanks to those libraries, applications can reuse existing code. Application development is simplified since many applications can reuse the same functions. With libraries often developed by different persons, the global development of the system is closer to Unix's historical philosophy."
msgstr "Takket være disse bibliotekene kan programmer gjenbruke eksisterende kode. Programutvikling forenkles fordi mange programmer kan bruke de samme funksjonene. Med bibliotekene, ofte utviklet av forskjellige personer, så er den globale utviklingen av systemet nærmere Unixs historiske filosofi."

msgid "<emphasis>CULTURE</emphasis> The Unix Way: one thing at a time"
msgstr "<emphasis>KULTUR</emphasis> Unix-måten: En ting om gangen"

msgid "One of the fundamental concepts that underlies the Unix family of operating systems is that each tool should only do one thing, and do it well; applications can then reuse these tools to build more advanced logic on top. This philosophy can be seen in many incarnations. Shell scripts may be the best example: they assemble complex sequences of very simple tools (such as <command>grep</command>, <command>wc</command>, <command>sort</command>, <command>uniq</command> and so on). Another implementation of this philosophy can be seen in code libraries: the <emphasis>libpng</emphasis> library allows reading and writing PNG images, with different options and in different ways, but it does only that; no question of including functions that display or edit images."
msgstr "Et av de grunnleggende begreper som ligger til grunn for Unix-familiens operativsystemer, er at hvert verktøy bare skal gjøre en ting, og gjøre det bra; programmer kan deretter bruke disse verktøyene for å bygge en mer avansert logikk på toppen. Denne filosofien kan gjenfinnes i mange utgaver. Skall-skript kan være det beste eksemplet: De kan sette sammen komplekse sekvenser av svært enkle verktøy (for eksempel <command>grep</command>, <command>wc</command>, <command>sort</command>, <command>uniq</command>, og så videre). En annen implementering av denne filosofien sees i kodebiblioteker: <emphasis>libpng</emphasis>-biblioteket gjør det mulig å lese og skrive PNG-bilder, med ulike alternativer og på ulike måter, men det gjør bare det; ikke noe spørsmål om å inkludere funksjoner som viser eller redigerer bilder."

msgid "Moreover, these libraries are often referred to as “shared libraries”, since the kernel is able to only load them into memory once, even if several processes use the same library at the same time. This allows saving memory, when compared with the opposite (hypothetical) situation where the code for a library would be loaded as many times as there are processes using it."
msgstr "Dessuten er disse bibliotekene ofte referert til som «felles biblioteker», ettersom kjernen bare er i stand til å laste dem inn i minnet én gang, selv om flere prosesser benytter samme bibliotek samtidig. Dette tillater å spare lagringsminne, sammenlignet med den motsatte (hypotetisk) situasjonen, hvor koden for et bibliotek ville være lastet like mange ganger som det er prosesser som benytter den."
