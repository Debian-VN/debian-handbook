#
# AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: 0\n"
"POT-Creation-Date: 2015-10-01 18:01+0200\n"
"PO-Revision-Date: 2016-11-17 02:54+0000\n"
"Last-Translator: Fred Maranhão <fred.maranhao@gmail.com>\n"
"Language-Team: Portuguese (Brazil) <https://hosted.weblate.org/projects/debian-handbook/92_short-remedial-course/pt_BR/>\n"
"Language: pt-BR\n"
"MIME-Version: 1.0\n"
"Content-Type: application/x-publican; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=n > 1;\n"
"X-Generator: Weblate 2.10-dev\n"

msgid "BIOS"
msgstr "BIOS"

msgid "Kernel"
msgstr "Núcleo"

msgid "Unix"
msgstr "Unix"

msgid "Process"
msgstr "Processo"

msgid "Hierarchy"
msgstr "Hierarquia"

msgid "Basic Commands"
msgstr "Comandos Básicos"

msgid "Short Remedial Course"
msgstr "Curso Rápido de Reparação"

msgid "Even though this book primarily targets administrators and “power-users”, we wouldn't like to exclude motivated beginners. This appendix will therefore be a crash-course describing the fundamental concepts involved in handling a Unix computer."
msgstr "Mesmo que este livro tenha como alvo principalmente administradores de sistemas e \"usuários experientes\", nós não gostaríamos de excluir os iniciantes motivados. Este apêndice será, portanto, um curso intensivo que descreve os conceitos fundamentais envolvidos na operação de um computador com Unix."

msgid "Shell and Basic Commands"
msgstr "Shell e Comandos Básicos"

msgid "In the Unix world, every administrator has to use the command line sooner or later; for example, when the system fails to start properly and only provides a command-line rescue mode. Being able to handle such an interface, therefore, is a basic survival skill for these circumstances."
msgstr "No mundo Unix, todo administrador de sistemas terá que usar linha de comandos mais cedo ou mais tarde; por exemplo, quando o sistema falha em iniciar corretamente e provê somente o modo de recuperação via linha de comando. Ser capaz de trabalhar com esta interface, portanto, é uma habilidade de sobrevivência básica para estas circunstâncias."

msgid "<emphasis>QUICK LOOK</emphasis> Starting the command interpreter"
msgstr "<emphasis>OLHAR RÁPIDO</emphasis> Iniciando o interpretador de comando"

msgid "A command-line environment can be run from the graphical desktop, by an application known as a “terminal”. In GNOME, you can start it from the “Activities” overview (that you get when you move the mouse in the top-left corner of the screen) by typing the first letters of the application name. In KDE, you will find it in the <menuchoice><guimenu>K</guimenu> <guisubmenu>Applications</guisubmenu> <guisubmenu>System</guisubmenu></menuchoice> menu."
msgstr "Um ambiente de linha de comando pode ser usado a partir do ambiente gráfico do computador, através de uma aplicação conhecida como \"terminal\". No GNOME, você pode iniciar ela a partir da visão geral dada em \"Atividades\" (que você tem quando move o mouse para o canto superior esquerdo da tela), digitando as primeiras letras do nome da aplicação. No KDE, você irá encontrar ela no menu  <menuchoice><guimenu>K</guimenu> <guisubmenu>Aplicações</guisubmenu> <guisubmenu>Sistema</guisubmenu></menuchoice>."

msgid "This section only gives a quick peek at the commands. They all have many options not described here, so please refer to the abundant documentation in their respective manual pages."
msgstr "Esta seção só dá uma olhada rápida nos comandos. Todos eles têm muitas opções não descritas aqui. Então, por favor, visite a vasta documentação das suas respectivas páginas de manual."

msgid "Browsing the Directory Tree and Managing Files"
msgstr "Navegando na Árvore de Diretórios e Gerenciando Arquivos"

msgid "Once a session is open, the <command>pwd</command> command (which stands for <emphasis>print working directory</emphasis>) displays the current location in the filesystem. The current directory is changed with the <command>cd <replaceable>directory</replaceable></command> command (<command>cd</command> is for <emphasis>change directory</emphasis>). The parent directory is always called <literal>..</literal> (two dots), whereas the current directory is also known as <literal>.</literal> (one dot). The <command>ls</command> command allows <emphasis>listing</emphasis> the contents of a directory. If no parameters are given, it operates on the current directory."
msgstr "Uma vez que uma sessão é aberta, o comando <command>pwd</command> (que significa <emphasis>print working directory</emphasis> - imprimir o diretório de trabalho) mostra a localização atual no sistema de arquivos. O diretório atual é alterado com o comando <command> cd <replaceable>diretório</replaceable></command> (<command>cd</command> serve para alterar o diretório - <emphasis>change directory</emphasis>). O diretório pai é sempre chamado <literal>..</literal> (dois pontos), enquanto o diretório atual também é conhecido como <literal>.</literal> (ponto). O <command>ls</command> permite <emphasis>listar</emphasis> o conteúdo de um diretório. Se nenhum parâmetro é dado, ele opera no diretório atual."

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog\n"
"$ </computeroutput><userinput>cd Desktop</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog/Desktop\n"
"$ </computeroutput><userinput>cd .</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog/Desktop\n"
"$ </computeroutput><userinput>cd ..</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog\n"
"$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates\n"
"Documents  Music      Public    Videos</computeroutput>\n"
"      "
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog\n"
"$ </computeroutput><userinput>cd Desktop</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog/Desktop\n"
"$ </computeroutput><userinput>cd .</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog/Desktop\n"
"$ </computeroutput><userinput>cd ..</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog\n"
"$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates\n"
"Documents  Music      Public    Videos</computeroutput>\n"
"      "

msgid "A new directory can be created with <command>mkdir <replaceable>directory</replaceable></command>, and an existing (empty) directory can be removed with <command>rmdir <replaceable>directory</replaceable></command>. The <command>mv</command> command allows <emphasis>moving</emphasis> and/or renaming files and directories; <emphasis>removing</emphasis> a file is achieved with <command>rm <replaceable>file</replaceable></command>."
msgstr "Um novo diretório pode ser criado com <command>mkdir <replaceable>diretório</replaceable></command>, e um diretório (vazio) existente pode ser removido com <command> rmdir <replaceable>diretório</replaceable></command >. O comando <command>mv</command> permite <emphasis>mover</emphasis> e/ou renomear arquivos e diretórios; para <emphasis>remover</emphasis> um arquivo use <command>rm <replaceable>arquivo</replaceable></command>."

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>mkdir test</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates  Videos\n"
"Documents  Music      Public    test\n"
"$ </computeroutput><userinput>mv test new</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  new       Public     Videos\n"
"Documents  Music      Pictures  Templates\n"
"$ </computeroutput><userinput>rmdir new</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates  Videos\n"
"Documents  Music      Public</computeroutput>\n"
"      "
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>mkdir teste</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates  Videos\n"
"Documents  Music      Public    teste\n"
"$ </computeroutput><userinput>mv teste novo</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  novo       Public     Videos\n"
"Documents  Music      Pictures  Templates\n"
"$ </computeroutput><userinput>rmdir novo</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates  Videos\n"
"Documents  Music      Public</computeroutput>\n"
"      "

msgid "Displaying and Modifying Text Files"
msgstr "Mostrando e Modificando Arquivos Texto"

msgid "The <command>cat <replaceable>file</replaceable></command> command (intended to <emphasis>concatenate</emphasis> files to the standard output device) reads a file and displays its contents on the terminal. If the file is too big to fit on a screen, use a pager such as <command>less</command> (or <command>more</command>) to display it page by page."
msgstr "O comando <command> cat <replaceable>arquivo</replaceable></command> (destinado a <emphasis>concatenar</emphasis> arquivos para o dispositivo de saída padrão) lê um arquivo e exibe seu conteúdo no terminal. Se o arquivo é muito grande para caber na tela, use um paginador como o <command>less</command> (ou <command>more</command>) para exibir o conteúdo página a página."

msgid "The <command>editor</command> command starts a text editor (such as <command>vi</command> or <command>nano</command>) and allows creating, modifying and reading text files. The simplest files can sometimes be created directly from the command interpreter thanks to redirection: <command>echo \"<replaceable>text</replaceable>\" &gt;<replaceable>file</replaceable></command> creates a file named <replaceable>file</replaceable> with “<replaceable>text</replaceable>” as its contents. Adding a line at the end of this file is possible too, with a command such as <command>echo \"<replaceable>moretext</replaceable>\" &gt;&gt;<replaceable>file</replaceable></command>. Note the <literal>&gt;&gt;</literal> in this example."
msgstr "O comando <command>editor</command> inicia um editor de texto (como o <command>vi</command> ou o <command>nano</command>) e permite criar, modificar e ler arquivos de texto. Os arquivos mais simples às vezes podem ser criados diretamente a partir do interpretador de comandos graças ao redirecionamento:  <command>echo \"<replaceable>texto</replaceable>\"&gt;<replaceable>arquivo</replaceable></command> cria um arquivo chamado <replaceable>arquivo</replaceable> com \"<replaceable>texto</replaceable>\" como o seu conteúdo. Também é possível adicionar uma linha no final deste arquivo com um comando como <command>echo \"<replaceable>maistexto</replaceable>\"&gt;&gt;<replaceable>arquivo</replaceable></command>. Note o <literal>&gt;&gt;</literal> deste exemplo."

msgid "Searching for Files and within Files"
msgstr "Procurando por e nos Arquivos"

msgid "The <command>find <replaceable>directory</replaceable> <replaceable>criteria</replaceable></command> command looks for files in the hierarchy under <replaceable>directory</replaceable> according to several criteria. The most commonly used criterion is <literal>-name <replaceable>name</replaceable></literal>: that allows looking for a file by its name."
msgstr "O comando <command>find <replaceable>diretório</replaceable> <replaceable>critérios</replaceable></command> procura por arquivos na hierarquia sob o <replaceable>diretório</replaceable> de acordo com vários critérios. O critério mais comum é <literal>-name <replaceable>name</replaceable></literal>: que permite procurar um arquivo pelo nome."

msgid "The <command>grep <replaceable>expression</replaceable> <replaceable>files</replaceable></command> command searches the contents of the files and extracts the lines matching the regular expression (see sidebar <xref linkend=\"sidebar.regexp\" />). Adding the <literal>-r</literal> option enables a recursive search on all files contained in the directory passed as a parameter. This allows looking for a file when only a part of the contents are known."
msgstr "O comando <command>grep <replaceable>expressão</replaceable> <replaceable>arquivos</replaceable></command> procura o conteúdo nos arquivos e extrai as linhas correspondentes na expressão regular (veja na barra lateral <xref linkend=\"sidebar.regexp\"/>). Adicionando a opção <literal>-r</literal> habilita a procura recursiva em todos os arquivos contidos no diretório passado como um parâmetro. Isto permite procurar por um arquivo quando somente uma parte do conteúdo é conhecido."

msgid "Managing Processes"
msgstr "Gerenciamento de Processos"

msgid "The <command>ps aux</command> command lists the processes currently running and helps identifying them by showing their <emphasis>pid</emphasis> (process id). Once the <emphasis>pid</emphasis> of a process is known, the <command>kill -<replaceable>signal</replaceable> <replaceable>pid</replaceable></command> command allows sending it a signal (if the process belongs to the current user). Several signals exist; most commonly used are <literal>TERM</literal> (a request to terminate gracefully) and <literal>KILL</literal> (a forced kill)."
msgstr "O comando <command> ps aux </command> lista os processos rodando atualmente e ajuda a identificá-los exibindo seus <emphasis>pid</emphasis> (identificador do processo). Uma vez que o <emphasis>pid</emphasis> de um processo é conhecido, o comando <command>kill -<replaceable>signal</replaceable> <replaceable>pid</replaceable></command> permite enviar um sinal para ele (se o processo pertence ao usuário atual). Existem muitos sinais; os mais usados comumente são <literal>TERM</literal> (uma requisição para terminar suavemente) e <literal>KILL</literal> (matar o processo à força)."

msgid "The command interpreter can also run programs in the background if the command is followed by a “&amp;”. By using the ampersand, the user resumes control of the shell immediately even though the command is still running (hidden from the user; as a background process). The <command>jobs</command> command lists the processes running in the background; running <command>fg %<replaceable>job-number</replaceable></command> (for <emphasis>foreground</emphasis>) restores a job to the foreground. When a command is running in the foreground (either because it was started normally, or brought back to the foreground with <command>fg</command>), the <keycombo action=\"simul\"><keycap>Control</keycap><keycap>Z</keycap></keycombo> key combination pauses the process and resumes control of the command-line. The process can then be restarted in the background with <command>bg %<replaceable>job-number</replaceable></command> (for <foreignphrase>background</foreignphrase>)."
msgstr "O interpretador de comando também pode rodar programas em segundo plano se o comando é seguido de um “&amp;”. Ao utilizar o  \"e comercial\", o usuário retorna o controle para o shell imediatamente mesmo que o comando ainda esteja rodando (oculto para o usuário; como um processo em segundo plano). O comando <command>jobs</command> lista os processos rodando em segundo plano; executar <command>fg %<replaceable>número-do-processo</replaceable></command> (para <emphasis>foreground</emphasis> - primeiro plano) restaura o trabalho para o primeiro plano. Quando um comando está rodando em primeiro plano (ou porque ele foi iniciado normalmente, ou trazido de volta para o primeiro plano com <command>fg</command>), a combinação de teclas <keycombo action=\"simul\"><keycap>Control</keycap><keycap>Z</keycap></keycombo> pausa os processos e retorna o controle para a linha de comando. O processo pode então ser reiniciado em segundo plano com o comando <command>bg %<replaceable>número-do-processo</replaceable></command> (para <foreignphrase>background</foreignphrase> - segundo plano)."

msgid "System Information: Memory, Disk Space, Identity"
msgstr "Informações do Sistema: Memória, Espaço em Disco, Identidade"

msgid "The <command>free</command> command displays information on memory; <command>df</command> (<emphasis>disk free</emphasis>) reports on the available disk space on each of the disks mounted in the filesystem. Its <literal>-h</literal> option (for <emphasis>human readable</emphasis>) converts the sizes into a more legible unit (usually mebibytes or gibibytes). In a similar fashion, the <command>free</command> command supports the <literal>-m</literal> and <literal>-g</literal> options, and displays its data either in mebibytes or in gibibytes, respectively."
msgstr "O comando <command>free</command> exibe informações sobre a memória; o <command>df</command>(<emphasis>disk free</emphasis>) exibe relatórios sobre o espaço disponível no disco em cada um dos discos montados no sistema de arquivo. A opção <literal>-h</literal> (para <emphasis>legível por humanos</emphasis> converte os tamanhos para uma unidade mais legível (normalmente gigabytes ou megabytes). De um modo semelhante, o comando <command>free</command> suporta as opções <literal>-m</literal> e <literal>-g</literal>, e mostra estes dados tanto em megabytes ou em gigabytes, respectivamente."

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>free</userinput>\n"
"<computeroutput>             total       used       free     shared    buffers     cached\n"
"Mem:       1028420    1009624      18796          0      47404     391804\n"
"-/+ buffers/cache:     570416     458004\n"
"Swap:      2771172     404588    2366584\n"
"$ </computeroutput><userinput>df</userinput>\n"
"<computeroutput>Filesystem           1K-blocks      Used Available Use% Mounted on\n"
"/dev/sda2              9614084   4737916   4387796  52% /\n"
"tmpfs                   514208         0    514208   0% /lib/init/rw\n"
"udev                     10240       100     10140   1% /dev\n"
"tmpfs                   514208    269136    245072  53% /dev/shm\n"
"/dev/sda5             44552904  36315896   7784380  83% /home\n"
"</computeroutput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>free</userinput>\n"
"<computeroutput>             total       used       free     shared    buffers     cached\n"
"Mem:       1028420    1009624      18796          0      47404     391804\n"
"-/+ buffers/cache:     570416     458004\n"
"Swap:      2771172     404588    2366584\n"
"$ </computeroutput><userinput>df</userinput>\n"
"<computeroutput>Filesystem           1K-blocks      Used Available Use% Mounted on\n"
"/dev/sda2              9614084   4737916   4387796  52% /\n"
"tmpfs                   514208         0    514208   0% /lib/init/rw\n"
"udev                     10240       100     10140   1% /dev\n"
"tmpfs                   514208    269136    245072  53% /dev/shm\n"
"/dev/sda5             44552904  36315896   7784380  83% /home\n"
"</computeroutput>"

msgid "The <command>id</command> command displays the identity of the user running the session, along with the list of groups they belong to. Since access to some files or devices may be limited to group members, checking available group membership may be useful."
msgstr "O comando <command>id</command> exibe a identidade do usuário em execução na seção, juntamente com a lista de grupos a que pertence. Uma vez que o acesso a alguns arquivos ou dispositivos pode ser limitado aos membros de algum grupo, verificar a que grupos pertence pode ser útil."

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>id</userinput>\n"
"<computeroutput>uid=1000(rhertzog) gid=1000(rhertzog) groups=1000(rhertzog),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(netdev),109(bluetooth),115(scanner)</computeroutput>\n"
"      "
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>id</userinput>\n"
"<computeroutput>uid=1000(rhertzog) gid=1000(rhertzog) groups=1000(rhertzog),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(netdev),109(bluetooth),115(scanner)</computeroutput>\n"
"      "

msgid "Organization of the Filesystem Hierarchy"
msgstr "Organização da Hierarquia de Sistema de Arquivos"

msgid "<primary>Filesystem Hierarchy</primary>"
msgstr "<primary>Hierarquia do Sistema de Arquivos</primary>"

msgid "The Root Directory"
msgstr "O Diretório Raiz"

msgid "A Debian system is organized along the <emphasis>Filesystem Hierarchy Standard</emphasis> (FHS). This standard defines the purpose of each directory. For instance, the top-level directories are described as follows:"
msgstr "Um sistema Debian é organizado de acordo com o <emphasis>Filesystem Hierarchy Standard</emphasis> (FHS). Esta norma define a finalidade de cada diretório. Por exemplo, os diretórios de nível superior são descritos como se segue:"

msgid "<filename>/bin/</filename>: basic programs;"
msgstr "<filename>/bin/</filename>: programas básicos;"

msgid "<filename>/boot/</filename>: Linux kernel and other files required for its early boot process;"
msgstr "<filename>/boot/</filename>: núcleo Linux e outros arquivos necessários para os primeiros passos de seu processo de inicialização;"

msgid "<filename>/dev/</filename>: device files;"
msgstr "<filename>/dev/</filename>: arquivos de dispositivo;"

msgid "<filename>/etc/</filename>: configuration files;"
msgstr "<filename>/etc/</filename>: Arquivos de configuração;"

msgid "<filename>/home/</filename>: user's personal files;"
msgstr "<filename>/home/</filename>: arquivos pessoais dos usuários;"

msgid "<filename>/lib/</filename>: basic libraries;"
msgstr "<filename>/lib/</filename>: bibliotecas básicas;"

msgid "<filename>/media/*</filename>: mount points for removable devices (CD-ROM, USB keys and so on);"
msgstr "<filename>/media/*</filename>: pontos de montagem para dispositivos removíveis (CD-ROM, pendrivers e assim por diante);"

msgid "<filename>/mnt/</filename>: temporary mount point;"
msgstr "<filename>/mnt/</filename>: ponto de montagem temporário;"

msgid "<filename>/opt/</filename>: extra applications provided by third parties;"
msgstr "<filename>/opt/</filename>: aplicações extras fornecidas por terceiros;"

msgid "<filename>/root/</filename>: administrator's (root's) personal files;"
msgstr "<filename>/root/</filename>: arquivos pessoais do administrador (root);"

msgid "<filename>/run/</filename>: volatile runtime data that does not persist across reboots (not yet included in the FHS);"
msgstr "<filename>/run/</filename>: dados de execução volátil (volatile runtime data) que não persistem entre re-inicializações (ainda não incluído no FHS);"

msgid "<filename>/sbin/</filename>: system programs;"
msgstr "<filename>/sbin/</filename>: programas do sistema;"

msgid "<filename>/srv/</filename>: data used by servers hosted on this system;"
msgstr "<filename>/srv/</filename>: dados utilizados por servidores hospedados neste sistema;"

msgid "<filename>/tmp/</filename>: temporary files; this directory is often emptied at boot;"
msgstr "<filename>/tmp/</filename>: arquivos temporários, este diretório é comumente limpo na inicialização;"

msgid "<filename>/usr/</filename>: applications; this directory is further subdivided into <filename>bin</filename>, <filename>sbin</filename>, <filename>lib</filename> (according to the same logic as in the root directory). Furthermore, <filename>/usr/share/</filename> contains architecture-independent data. <filename>/usr/local/</filename> is meant to be used by the administrator for installing applications manually without overwriting files handled by the packaging system (<command>dpkg</command>)."
msgstr "<filename>/usr/</filename>: aplicações; este diretório é subdividido em <filename>bin</filename>, <filename>sbin</filename>, <filename>lib</filename> (de acordo com a mesma lógica do diretório raiz). Além disso, <filename>/usr/share/</filename> contém dados independentes de arquitetura. <filename>/usr/local/</filename> é feito para ser usado pelo administrador para instalar aplicativos manualmente, sem sobrescrever arquivos administrados pelo sistema de empacotamento (<command>dpkg</command>)."

msgid "<filename>/var/</filename>: variable data handled by daemons. This includes log files, queues, spools, caches and so on."
msgstr "<filename>/var/</filename>: dados variáveis manipulados por daemons. Isto inclui arquivos de log, filas, spools, caches e por aí vai."

msgid "<filename>/proc/</filename> and <filename>/sys/</filename> are specific to the Linux kernel (and not part of the FHS). They are used by the kernel for exporting data to user space (see <xref linkend=\"sect.userspace-presentation\" /> and <xref linkend=\"sect.user-space\" /> for explanations about this concept)."
msgstr "<filename>/proc/</filename> e <filename>/sys/</filename> são específicos do núcleo Linux ( e não fazem parte do FHS). Eles são usados pelo núcleo para exportar dados para o espaço de usuário  (veja <xref linkend=\"sect.userspace-presentation\" /> e <xref linkend=\"sect.user-space\" /> para explicações sobre esse conceito)."

msgid "The User's Home Directory"
msgstr "O Diretório Origem (home) do Usuário"

msgid "The contents of a user's home directory is not standardized, but there are still a few noteworthy conventions. One is that a user's home directory is often referred to by a tilde (“~”). That is useful to know because command interpreters automatically replace a tilde with the correct directory (usually <filename>/home/<replaceable>user</replaceable>/</filename>)."
msgstr "O conteúdo do diretório home do usuário não é padronizado, mas ainda existem algumas convenções relevantes. Uma delas é que o diretório home do usuário é muitas vezes referenciado por um til (\"~\"). É bom saber disto porque os interpretadores de comando substituem automaticamente um til pelo diretório correto (geralmente <filename>/home/<replaceable>user</replaceable>/</filename>)."

msgid "Traditionally, application configuration files are often stored directly under the user's home directory, but their names usually start with a dot (for instance, the <command>mutt</command> email client stores its configuration in <filename>~/.muttrc</filename>). Note that filenames that start with a dot are hidden by default; and <command>ls</command> only lists them when the <literal>-a</literal> option is used, and graphical file managers need to be told to display hidden files."
msgstr "Tradicionalmente, os arquivos de configuração de aplicativos são frequentemente armazenados diretamente sob o diretório home do usuário, mas seus nomes geralmente começam com um ponto (por exemplo, o cliente de email <command>mutt</command> armazena sua configuração em <filename>~/.muttrc</filename>). Note que nomes de arquivos que começam com um ponto são ocultos por padrão; e <command>ls</command> os lista apenas quando a opção <literal>-a</literal> for usada, e gerenciadores de arquivos gráficos precisa ser ordenados para exibir arquivos ocultos."

msgid "Some programs also use multiple configuration files organized in one directory (for instance, <filename>~/.ssh/</filename>). Some applications (such as the Iceweasel web browser) also use their directory to store a cache of downloaded data. This means that those directories can end up using a lot of disk space."
msgstr "Alguns programas também utilizam vários arquivos de configuração organizados em um diretório (por exemplo, <filename>~/.ssh/</filename>). Alguns aplicativos (como o navegador web Iceweasel) também usam seu diretório para armazenar um cache de dados baixados. Isto significa que os diretórios podem acabar usando muito espaço em disco."

msgid "These configuration files stored directly in a user's home directory, often collectively referred to as <emphasis>dotfiles</emphasis>, have long proliferated to the point that these directories can be quite cluttered with them. Fortunately, an effort led collectively under the FreeDesktop.org umbrella has resulted in the “XDG Base Directory Specification”, a convention that aims at cleaning up these files and directory. This specification states that configuration files should be stored under <filename>~/.config</filename>, cache files under <filename>~/.cache</filename>, and application data files under <filename>~/.local</filename> (or subdirectories thereof). This convention is slowly gaining traction, and several applications (especially graphical ones) have started following it."
msgstr "Esses arquivos de configuração armazenados diretamente no diretório home do usuário, muitas vezes chamados coletivamente como <emphasis>dotfiles</emphasis>, há tempos se proliferam a tal ponto que estes diretórios podem ficar abarrotados com eles. Felizmente, um esforço liderado coletivamente sob a orientação da FreeDesktop.org resultou na \"Especificação de Diretórios Base da XDG\", uma convenção que visa limpar esses arquivos e diretórios. Esta especificação estabelece que os arquivos de configuração devem ser armazenados sob <filename>~/.config</filename>, arquivos de cache sob <filename>~/.cache</filename>, e arquivos de dados de aplicativos sob <filename>~/.local</filename> (ou subdiretórios nos mesmos). Esta convenção está lentamente ganhando força e vários aplicativos (especialmente os gráficos) começaram a segui-la."

msgid "Graphical desktops usually display the contents of the <filename>~/Desktop/</filename> directory (or whatever the appropriate translation is for systems not configured in English) on the desktop (ie, what is visible on screen once all applications are closed or iconized)."
msgstr "Ambientes gráficos geralmente exibem o conteúdo do diretório <filename>~/Desktop</filename> (ou qualquer que seja a tradução apropriada para sistemas não configurados em inglês) na área de trabalho (ou seja, o que é visível na tela uma vez que todas as aplicações estão fechadas ou minimizadas)."

msgid "Finally, the email system sometimes stores incoming emails into a <filename>~/Mail/</filename> directory."
msgstr "Finalmente, o sistema de e-mail às vezes armazena e-mails recebidos no diretório <filename>~/Mail/</filename>."

msgid "Inner Workings of a Computer: the Different Layers Involved"
msgstr "Funcionamento Interno de um Computador: As Diferentes Camadas Envolvidas"

msgid "A computer is often considered as something rather abstract, and the externally visible interface is much simpler than its internal complexity. Such complexity comes in part from the number of pieces involved. However, these pieces can be viewed in layers, where a layer only interacts with those immediately above or below."
msgstr "Um computador é muitas vezes considerado como algo bastante abstrato, e a interface visível externamente é muito mais simples do que a sua complexidade interna. Tal complexidade vem, em parte, do número de peças envolvidas. No entanto, estas peças podem ser vistas em camadas, em que uma camada apenas interage com aquelas imediatamente acima ou abaixo."

msgid "An end-user can get by without knowing these details… as long as everything works. When confronting a problem such as, “The internet doesn't work!”, the first thing to do is to identify in which layer the problem originates. Is the network card (hardware) working? Is it recognized by the computer? Does the Linux kernel see it? Are the network parameters properly configured? All these questions isolate an appropriate layer and focus on a potential source of the problem."
msgstr "Um usuário final pode viver sem saber esses detalhes... enquanto tudo funciona. Ao encontrar um problema como: \"A internet não funciona!\", A primeira coisa a fazer é identificar em qual camada o problema se origina. A placa de rede (hardware) está funcionando? É reconhecida pelo computador? Será que o kernel do Linux vê a placa? Os parâmetros de rede estão configurados corretamente? Todas estas questões isolam uma camada apropriada e focam numa possível fonte do problema."

msgid "The Deepest Layer: the Hardware"
msgstr "A Camada mais Profunda: o Hardware"

msgid "<primary>IDE</primary>"
msgstr "<primary>IDE</primary>"

msgid "<primary>SCSI</primary>"
msgstr "<primary>SCSI</primary>"

msgid "<primary>Serial ATA</primary>"
msgstr "<primary>Serial ATA</primary>"

msgid "<primary>Parallel ATA</primary>"
msgstr "<primary>Parallel ATA</primary>"

msgid "<primary>ATA</primary>"
msgstr "<primary>ATA</primary>"

msgid "<primary>IEEE 1394</primary>"
msgstr "<primary>IEEE 1394</primary>"

msgid "<primary>Firewire</primary>"
msgstr "<primary>Firewire</primary>"

msgid "<primary>USB</primary>"
msgstr "<primary>USB</primary>"

msgid "Let us start with a basic reminder that a computer is, first and foremost, a set of hardware elements. There is generally a main board (known as the <emphasis>motherboard</emphasis>), with one (or more) processor(s), some RAM, device controllers, and extension slots for option boards (for other device controllers). Most noteworthy among these controllers are IDE (Parallel ATA), SCSI and Serial ATA, for connecting to storage devices such as hard disks. Other controllers include USB, which is able to host a great variety of devices (ranging from webcams to thermometers, from keyboards to home automation systems) and IEEE 1394 (Firewire). These controllers often allow connecting several devices so the complete subsystem handled by a controller is therefore usually known as a “bus”. Option boards include graphics cards (into which monitor screens will be plugged), sound cards, network interface cards, and so on. Some main boards are pre-built with these features, and don't need option boards."
msgstr "Vamos começar com um lembrete básico de que um computador é, em primeiro lugar, um conjunto de elementos de hardware. Há geralmente uma placa principal (conhecida como a <emphasis>placa-mãe</emphasis>), com um (ou mais) processador(es), memória RAM, controladores de dispositivos e encaixes (slots) de extensão para placas opcionais (para outros controladores de dispositivos). O mais importante entre esses controladores são as IDE (Parallel ATA), SCSI e Serial ATA, para conexão com dispositivos de armazenamento, como discos rígidos. Outros controladores incluem USB, que é capaz de hospedar uma grande variedade de dispositivos (variando de webcams até termômetros, de teclados até sistemas de automação residencial) e IEEE 1394 (Firewire). Esses controladores muitas vezes permitem conectar vários dispositivos. O subsistema completo gerenciado por tal controlador é, por este motivo, normalmente conhecido como \"barramento\". Placas opcionais incluem placas gráficas (onde telas de monitores serão conectadas), placas de som, placas de rede, e assim por diante. Algumas placas principais são pré-fabricadas com esses recursos, e não precisam de placas opcionais."

msgid "<emphasis>IN PRACTICE</emphasis> Checking that the hardware works"
msgstr "<emphasis>NA PRÄTICA</emphasis> Verificando se o hardware funciona"

msgid "Checking that a piece of hardware works can be tricky. On the other hand, proving that it doesn't work is sometimes quite simple."
msgstr "Verificar se um hardware está funcionando pode ser complicado. Entretanto, provar que o mesmo não funciona às vezes é bem simples."

msgid "A hard disk drive is made of spinning platters and moving magnetic heads. When a hard disk is powered up, the platter motor makes a characteristic whir. It also dissipates energy as heat. Consequently, a hard disk drive that stays cold and silent when powered up is broken."
msgstr "Um disco rígido é feito de pratos giratórios e cabeças magnéticas móveis. Quando um disco rígido é ligado, o motor faz um zumbido característico. Também dissipa a energia na forma de calor. Consequentemente, um disco rígido que permanece frio e silencioso quando ligado está quebrado."

msgid "Network cards often include LEDs displaying the state of the link. If a cable is plugged in and leads to a working network hub or switch, at least one LED will be on. If no LED lights up, either the card itself, the network device, or the cable between them, is faulty. The next step is therefore testing each component individually."
msgstr "Placas de rede muitas vezes incluem LEDs que indicam o estado da conexão. Se um cabo estiver conectado e leva a um hub ou switch de rede em funcionamento, pelo menos um LED será ligado. Se nenhum LED acende, ou o próprio cartão, ou o dispositivo de rede ou o cabo entre eles está com defeito. O passo seguinte é, por conseguinte, o teste de cada componente individualmente."

msgid "Some option boards — especially 3D video cards — include cooling devices, such as heat sinks and/or fans. If the fan does not spin even though the card is powered up, a plausible explanation is the card overheated. This also applies to the main processor(s) located on the main board."
msgstr "Algumas placas opcionais - especialmente as placas de vídeo 3D - incluem dispositivos de refrigeração, tais como dissipadores de calor e/ou ventoinhas. Se a ventoinha não gira, mesmo que o cartão esteja ligado, uma explicação plausível é o cartão superaquecido. Isso vale também para o(s) processador(es) principal(is) localizado(s) na placa principal."

msgid "The Starter: the BIOS or UEFI"
msgstr "O Inicializador: a BIOS ou UEFI"

msgid "<primary>BIOS</primary>"
msgstr "<primary>BIOS</primary>"

msgid "<primary>UEFI</primary>"
msgstr "<primary>UEFI</primary>"

msgid "<primary>Master Boot Record (MBR)</primary>"
msgstr "<primary>Master Boot Record (MBR)</primary>"

msgid "Hardware, on its own, is unable to perform useful tasks without a corresponding piece of software driving it. Controlling and interacting with the hardware is the purpose of the operating system and applications. These, in turn, require functional hardware to run."
msgstr "O hardware, por si só, é incapaz de realizar tarefas úteis sem um software que o gerencie. Controlar e interagir com o hardware é o objetivo do sistema operacional e dos aplicativos. Estes, por sua vez, requerem hardware funcional para executar."

msgid "This symbiosis between hardware and software does not happen on its own. When the computer is first powered up, some initial setup is required. This role is assumed by the BIOS or UEFI, a piece of software embedded into the main board that runs automatically upon power-up. Its primary task is searching for software it can hand over control to. Usually, in the BIOS case, this involves looking for the first hard disk with a boot sector (also known as the <emphasis>master boot record</emphasis> or <acronym>MBR</acronym>), loading that boot sector, and running it. From then on, the BIOS is usually not involved (until the next boot). In the case of UEFI, the process involves scanning disks to find a dedicated EFI partition containing further EFI applications to execute."
msgstr "Esta simbiose entre hardware e software não acontece por si só. Quando o computador é ligado pela primeira vez, algumas configurações iniciais são necessárias. Esse papel é assumido pela BIOS ou UEFI, um software embarcado na placa principal que é executado automaticamente após a energização. Sua tarefa principal é a procura do software que receberá o controle. Normalmente, no caso da BIOS, isso envolve buscar no primeiro disco rígido com um setor de inicialização (também conhecido como o <emphasis>master boot record</emphasis> - registro mestre de inicialização - ou <acronym>MBR</acronym>), carregar esse setor de inicialização e executá-lo. A partir deste ponto, a BIOS geralmente não é mais utilizada (até a próxima inicialização). No caso da UEFI, o processo envolve uma busca nos discos à procura de uma partição EFI contendo outras aplicações EFI para executar."

msgid "<emphasis>TOOL</emphasis> Setup, the BIOS/UEFI configuration tool"
msgstr "<emphasis>FERRAMENTA</emphasis> Setup, a ferramenta de configuração da BIOS/UEFI"

msgid "<primary><emphasis>Setup</emphasis></primary>"
msgstr "<primary><emphasis>Setup</emphasis></primary>"

msgid "The BIOS/UEFI also contains a piece of software called Setup, designed to allow configuring aspects of the computer. In particular, it allows choosing which boot device is preferred (for instance, the floppy disk or CD-ROM drive), setting the system clock, and so on. Starting Setup usually involves pressing a key very soon after the computer is powered on. This key is often <keycap>Del</keycap> or <keycap>Esc</keycap>, sometimes <keycap>F2</keycap> or <keycap>F10</keycap>. Most of the time, the choice is flashed on screen while booting."
msgstr "A BIOS/UEFI também contém um software chamado de Setup, projetado para permitir a configuração de aspectos do computador. Em particular, ele permite escolher qual é o dispositivo preferencial de inicialização (por exemplo, o disquete ou CD-ROM), configurar o relógio do sistema, e assim por diante. Iniciar o Setup geralmente envolve pressionar uma tecla logo que o computador é ligado. Esta tecla é muitas vezes o <keycap>Del</keycap> ou <keycap>Esc</keycap>, às vezes a <keycap>F2</keycap> ou <keycap>F10</keycap>. Na maioria das vezes, a escolha é exibida na tela durante a inicialização."

msgid "The boot sector (or the EFI partition), in turn, contains another piece of software, called the bootloader, whose purpose is to find and run an operating system. Since this bootloader is not embedded in the main board but loaded from disk, it can be smarter than the BIOS, which explains why the BIOS does not load the operating system by itself. For instance, the bootloader (often GRUB on Linux systems) can list the available operating systems and ask the user to choose one. Usually, a time-out and default choice is provided. Sometimes the user can also choose to add parameters to pass to the kernel, and so on. Eventually, a kernel is found, loaded into memory, and executed."
msgstr "O setor de inicialização (ou a partição EFI), por sua vez, contém outro pedaço de software, chamado bootloader, cujo propósito é encontrar e executar um sistema operacional. Uma vez que este bootloader não é incorporado na placa principal, mas carregado do disco, pode ser mais esperto do que a BIOS, o que explica por que o BIOS não carrega o sistema operacional por si só. Por exemplo, o carregador de inicialização (geralmente o GRUB em sistemas Linux) pode listar os sistemas operacionais disponíveis e pedir ao usuário para escolher um. Normalmente, fornece uma opção de tempo limite e escolha padrão. Às vezes, o usuário também pode optar por adicionar parâmetros para passar para o núcleo, e assim por diante. No final das contas, um núcleo é encontrado, carregado na memória e executado."

msgid "<emphasis>NOTE</emphasis> UEFI, a modern replacement to the BIOS"
msgstr "<emphasis>NOTA</emphasis> UEFI, um moderno substituto para a BIOS"

msgid "<primary>Secure Boot</primary>"
msgstr "<primary>Secure Boot</primary>"

msgid "UEFI is a relatively recent development. Most new computers will support UEFI booting, but usually they also support BIOS booting alongside for backwards compatibility with operating systems that are not ready to exploit UEFI."
msgstr "UEFI é um desenvolvimento relativamente recente. A maioria dos computadores novos irão suportar a inicialização por UEFI, mas geralmente eles também suportam a inicialização por BIOS por questões de compatibilidade com sistemas operacionais que ainda não estão prontos para explorar o UEFI."

msgid "This new system gets rid of some of the limitations of BIOS booting: with the usage of a dedicated partition, the bootloaders no longer need special tricks to fit in a tiny <emphasis>master boot record</emphasis> and then discover the kernel to boot. Even better, with a suitably built Linux kernel, UEFI can directly boot the kernel without any intermediary bootloader. UEFI is also the basic foundation used to deliver <emphasis>Secure Boot</emphasis>, a technology ensuring that you run only software validated by your operating system vendor."
msgstr "Esse novo sistema se livra de algumas das limitações da inicialização pela BIOS: com o uso de uma partição dedicada, os carregadores de inicialização não mais precisam de truques especiais para caber na pequena <emphasis>MBR - master boot record</emphasis>, e assim, descobrir qual núcleo iniciar. Ainda melhor, com um núcleo Linux adequadamente construído, a UEFI pode inicializar o kernel diretamente sem qualquer carregador de inicialização intermediário. O UEFI é também a fundação básica usada para entregar o <emphasis>Secure Boot</emphasis>, uma tecnologia que garante que você apenas irá rodar software validado pelo seu fabricante de sistema operacional."

msgid "The BIOS/UEFI is also in charge of detecting and initializing a number of devices. Obviously, this includes the IDE/SATA devices (usually hard disk(s) and CD/DVD-ROM drives), but also PCI devices. Detected devices are often listed on screen during the boot process. If this list goes by too fast, use the <keycap>Pause</keycap> key to freeze it for long enough to read. Installed PCI devices that don't appear are a bad omen. At worst, the device is faulty. At best, it is merely incompatible with the current version of the BIOS or main board. PCI specifications evolve, and old main boards are not guaranteed to handle newer PCI devices."
msgstr "A BIOS/UEFI também é responsável por detectar e iniciar uma série de dispositivos. Obviamente, isto inclui os dispositivos IDE/SATA (normalmente disco(s) rígido(s) e unidades de CD/DVD-ROM), mas também dispositivos PCI. Os dispositivos detectados são frequentemente listado na tela durante o processo de inicialização. Se esta lista passa muito rápido, use a tecla <keycap>Pause</keycap> para congelá-la por tempo suficiente para ler. Dispositivos PCI instalados que não aparecem são um mau presságio. Na pior das hipóteses, o dispositivo está com defeito. Na melhor das hipóteses, é apenas incompatível com a versão atual da BIOS ou com a placa-mãe. As especificações PCI evoluiem, e não há garantia de que as placas-mãe antigas entendam dispositivos PCI mais recentes."

msgid "The Kernel"
msgstr "O Núcleo"

msgid "Both the BIOS/UEFI and the bootloader only run for a few seconds each; now we are getting to the first piece of software that runs for a longer time, the operating system kernel. This kernel assumes the role of a conductor in an orchestra, and ensures coordination between hardware and software. This role involves several tasks including: driving hardware, managing processes, users and permissions, the filesystem, and so on. The kernel provides a common base to all other programs on the system."
msgstr "Tanto a BIOS/UEFI como o bootloader apenas são executados por alguns segundos cada; agora estamos chegando ao primeiro software que é executado por um longo tempo, o núcleo do sistema operacional. Este núcleo assume o papel de um maestro de uma orquestra e assegura a coordenação entre o hardware e o software. Este papel envolve várias tarefas, incluindo: administrar o hardware, gerenciar processos, usuários e permissões, o sistema de arquivos, e assim por diante. O núcleo fornece uma base comum a todos os outros programas no sistema."

msgid "The User Space"
msgstr "O Espaço de Usuário"

msgid "Although everything that happens outside of the kernel can be lumped together under “user space”, we can still separate it into software layers. However, their interactions are more complex than before, and the classifications may not be as simple. An application commonly uses libraries, which in turn involve the kernel, but the communications can also involve other programs, or even many libraries calling each other."
msgstr "Embora possamos agurpar tudo que acontece fora do núcleo como \"espaço do usuário\", ainda podemos separá-lo em camadas de software. No entanto, as suas interações estão cada vez mais complexas e as classificações podem não ser tão simples. Uma aplicação geralmente usa bibliotecas, que por sua vez envolvem o núcleo, mas as comunicações também podem envolver outros programas, ou até mesmo muitas bibliotecas que chamam umas às outras."

msgid "Some Tasks Handled by the Kernel"
msgstr "Algumas Tarefas realizadas pelo Núcleo"

msgid "Driving the Hardware"
msgstr "Controlando o Hardware"

msgid "The kernel is, first and foremost, tasked with controlling the hardware parts, detecting them, switching them on when the computer is powered on, and so on. It also makes them available to higher-level software with a simplified programming interface, so applications can take advantage of devices without having to worry about details such as which extension slot the option board is plugged into. The programming interface also provides an abstraction layer; this allows video-conferencing software, for example, to use a webcam independently of its make and model. The software can just use the <emphasis>Video for Linux</emphasis> (V4L) interface, and the kernel translates the function calls of this interface into the actual hardware commands needed by the specific webcam in use."
msgstr "O núcleo tem, em primeiro lugar, a tarefa de controlar as partes do hardware, detectando-os, ligando-os quando o computador é ligado, e assim por diante. Também os torna disponíveis para o software de alto nível com uma interface de programação simplificada, para que os aplicativos possam tirar proveito de dispositivos sem ter que se preocupar com detalhes como em qual slot de extensão a placa opcional está conectada. A interface de programação também fornece uma camada de abstração; isso permite que o software de videoconferência, por exemplo, use uma webcam independentemente da sua marca e modelo. O software pode apenas usar a interface <emphasis>Vídeo for Linux</emphasis> (V4L), e o núcleo traduz as chamadas de função desta interface para os comandos de hardware reais necessários pela webcam específica em uso."

msgid "<indexterm><primary><command>lspci</command></primary></indexterm> <indexterm><primary><command>lsusb</command></primary></indexterm> <indexterm><primary><command>lsdev</command></primary></indexterm> <indexterm><primary><command>lspcmcia</command></primary></indexterm> The kernel exports many details about detected hardware through the <filename>/proc/</filename> and <filename>/sys/</filename> virtual filesystems. Several tools summarize those details. Among them, <command>lspci</command> (in the <emphasis role=\"pkg\">pciutils</emphasis> package) lists PCI devices, <command>lsusb</command> (in the <emphasis role=\"pkg\">usbutils</emphasis> package) lists USB devices, and <command>lspcmcia</command> (in the <emphasis role=\"pkg\">pcmciautils</emphasis> package) lists PCMCIA cards. These tools are very useful for identifying the exact model of a device. This identification also allows more precise searches on the web, which in turn, lead to more relevant documents."
msgstr "<indexterm><primary><command>lspci</command></primary></indexterm> <indexterm><primary><command>lsusb</command></primary></indexterm> <indexterm><primary><command>lsdev</command></primary></indexterm> <indexterm><primary><command>lspcmcia</command></primary></indexterm> O núcleo exporta muitos detalhes sobre o hardware detectado através dos sistemas de arquivos virtuais <filename>/proc/</filename> e <filename>/sys/</filename>. Várias ferramentas resumem esses detalhes. Entre elas, o <command>lspci</command> (no pacote <emphasis role=\"pkg\">pciutils</emphasis>) lista os dispositivos PCI, <command>lsusb</command> (no pacote <emphasis role=\"pkg\">usbutils</emphasis>) lista os dispositivos USB e <command>lspcmcia</command> (no pacote <emphasis role=\"pkg\">pcmciautils</emphasis>) lista os cartões PCMCIA. Estas ferramentas são muito úteis para a identificação do modelo exato de um dispositivo. Esta identificação permite também pesquisas mais precisas na web, que por sua vez, levam a documentos mais relevantes."

msgid "Example of information provided by <command>lspci</command> and <command>lsusb</command>"
msgstr "Exemplo de informação provida pelo <command>lspci</command> e <command>lsusb</command>"

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>lspci</userinput>\n"
"<computeroutput>[...]\n"
"00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)\n"
"00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)\n"
"00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)\n"
"[...]\n"
"01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)\n"
"02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)\n"
"$ </computeroutput><userinput>lsusb</userinput>\n"
"<computeroutput>Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.\n"
"Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.\n"
"Bus 005 Device 007: ID 045e:00dd Microsoft Corp.\n"
"Bus 005 Device 006: ID 046d:c03d Logitech, Inc.\n"
"[...]\n"
"Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth\n"
"</computeroutput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>lspci</userinput>\n"
"<computeroutput>[...]\n"
"00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)\n"
"00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)\n"
"00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)\n"
"[...]\n"
"01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)\n"
"02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)\n"
"$ </computeroutput><userinput>lsusb</userinput>\n"
"<computeroutput>Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.\n"
"Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.\n"
"Bus 005 Device 007: ID 045e:00dd Microsoft Corp.\n"
"Bus 005 Device 006: ID 046d:c03d Logitech, Inc.\n"
"[...]\n"
"Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth\n"
"</computeroutput>"

msgid "These programs have a <literal>-v</literal> option, that lists much more detailed (but usually not necessary) information. Finally, the <command>lsdev</command> command (in the <emphasis role=\"pkg\">procinfo</emphasis> package) lists communication resources used by devices."
msgstr "Estes programas têm uma opção <literal>-v</literal>, que lista informações com muito mais detalhes (mas geralmente não é necessário). Finalmente, o comando <command>lsdev</command> (no pacote <emphasis role=\"pkg\">procinfo</emphasis>) lista os recursos de comunicação usados pelos dispositivos."

msgid "Applications often access devices by way of special files created within <filename>/dev/</filename> (see sidebar <xref linkend=\"sidebar.special-files\" />). These are special files that represent disk drives (for instance, <filename>/dev/hda</filename> and <filename>/dev/sdc</filename>), partitions (<filename>/dev/hda1</filename> or <filename>/dev/sdc3</filename>), mice (<filename>/dev/input/mouse0</filename>), keyboards (<filename>/dev/input/event0</filename>), soundcards (<filename>/dev/snd/*</filename>), serial ports (<filename>/dev/ttyS*</filename>), and so on."
msgstr "As aplicações acessam frequentemente os dispositivos por meio de arquivos especiais criados dentro de <filename>/dev/</filename> (veja a barra lateral <xref linkend=\"sidebar.special-files\"/>). Estes são arquivos especiais que representam as unidades de disco (por exemplo, <filename>/dev/hda</filename> e <filename>/dev/sdc</filename>), partições (<filename>/dev/hda1</filename> ou <filename>/dev/sdc3</filename>), mouses (<filename>/dev/input/mouse0</filename>), teclados (<filename>/dev/input/event0</filename>), placas de som (<filename>/dev/snd/*</filename>), portas seriais (<filename>/dev/ttyS*</filename>), e assim por diante."

msgid "Filesystems"
msgstr "Sistemas de Arquivos"

msgid "<primary>filesystem</primary>"
msgstr "<primary>sistema de arquivos</primary>"

msgid "<primary>system, filesystem</primary>"
msgstr "<primary>sistema, sistema de arquivos</primary>"

msgid "Filesystems are one of the most prominent aspects of the kernel. Unix systems merge all the file stores into a single hierarchy, which allows users (and applications) to access data simply by knowing its location within that hierarchy."
msgstr "Os sistemas de arquivos são um dos aspectos mais importantes do núcleo. Sistemas Unix agrupam todos os arquivos que armazenam em uma hierarquia única, que permite aos usuários (e aplicações) acessar os dados  sabendo apenas a sua localização dentro dessa hierarquia."

msgid "The starting point of this hierarchical tree is called the root, <filename>/</filename>. This directory can contain named subdirectories. For instance, the <literal>home</literal> subdirectory of <filename>/</filename> is called <filename>/home/</filename>. This subdirectory can, in turn, contain other subdirectories, and so on. Each directory can also contain files, where the actual data will be stored. Thus, the <filename>/home/rmas/Desktop/hello.txt</filename> name refers to a file named <literal>hello.txt</literal> stored in the <literal>Desktop</literal> subdirectory of the <literal>rmas</literal> subdirectory of the <literal>home</literal> directory present in the root. The kernel translates between this naming system and the actual, physical storage on a disk."
msgstr "O ponto de partida desta árvore hierárquica é chamado de raiz, <filename>/</filename>. Este diretório pode conter subdiretórios nomeados. Por exemplo, o subdiretório <literal>home</literal> do <filename>/</filename> é chamado <filename>/home/</filename>. Este subdiretório pode, por sua vez, conter outros subdiretórios, e assim por diante. Cada diretório também pode conter arquivos, onde os dados reais serão armazenados. Assim, o nome <filename>/home/rmas/Desktop/hello.txt</filename> refere-se a um arquivo chamado <literal>hello.txt</literal> armazenado em <literal>Desktop</literal>, que é subdiretório de <literal>rmas</literal>, que é subdiretório de <literal>home</literal>, que está na raiz. O núcleo traduz entre este sistema de nomenclatura e o real armazenamento físico que fica no disco."

msgid "Unlike other systems, there is only one such hierarchy, and it can integrate data from several disks. One of these disks is used as the root, and the others are “mounted” on directories in the hierarchy (the Unix command is called <command>mount</command>); these other disks are then available under these “mount points”. This allows storing users' home directories (traditionally stored within <filename>/home/</filename>) on a second hard disk, which will contain the <literal>rhertzog</literal> and <literal>rmas</literal> directories. Once the disk is mounted on <filename>/home/</filename>, these directories become accessible at their usual locations, and paths such as <filename>/home/rmas/Desktop/hello.txt</filename> keep working."
msgstr "Ao contrário de outros sistemas, só há uma hierarquia deste tipo, e pode integrar dados de vários discos. Um desses discos é usado como a raiz, e os outros são \"montados\" em diretórios na hierarquia (o comando Unix é chamado <command>mount</command>); esses outros discos estarão disponíveis sob estes \"pontos de montagem\". Isso permite o armazenamento do diretório home dos usuários (tradicionalmente armazenados dentro de <filename>/home/</filename>) em um segundo disco rígido, que irá conter os diretórios <literal>rhertzog</literal> e <literal>rmas</literal>. Depois que o disco é montado em <filename>/home/</filename>, esses diretórios estarão disponíveis em seus locais habituais e caminhos como <filename>/home/rmas/Desktop/hello.txt</filename> continuarão funcionando."

msgid "<primary><command>mkfs</command></primary>"
msgstr "<primary><command>mkfs</command></primary>"

msgid "There are many filesystem formats, corresponding to many ways of physically storing data on disks. The most widely known are <emphasis>ext2</emphasis>, <emphasis>ext3</emphasis> and <emphasis>ext4</emphasis>, but others exist. For instance, <emphasis>vfat</emphasis> is the system that was historically used by DOS and Windows operating systems, which allows using hard disks under Debian as well as under Windows. In any case, a filesystem must be prepared on a disk before it can be mounted and this operation is known as “formatting”. Commands such as <command>mkfs.ext3</command> (where <command>mkfs</command> stands for <emphasis>MaKe FileSystem</emphasis>) handle formatting. These commands require, as a parameter, a device file representing the partition to be formatted (for instance, <filename>/dev/sda1</filename>). This operation is destructive and should only be run once, except if one deliberately wishes to wipe a filesystem and start afresh."
msgstr "Existem muitos formatos de sistemas de arquivo que correspondem a muitas formas de armazenamento físico de dados nos discos. Os mais conhecidos são o <emphasis>ext2</emphasis>, <emphasis>ext3</emphasis> e o <emphasis>ext4</emphasis>, mas existem outros. Por exemplo, o <emphasis>vfat</emphasis> é o sistema que foi historicamente usado pelos sistemas operacionais DOS e Windows, que permite utilizar os discos rígidos tanto no Debian como no Windows. Em qualquer caso, um sistema de arquivos deve ser preparado em um disco antes que ele possa ser montado e esta operação é conhecida como \"formatação\". Comandos como <command>mkfs.ext3</command> (onde <command>mkfs</command> é <emphasis>MaKe FileSystem</emphasis> - criar sistema de arquivos) fazem a formatação. Estes comandos exigem, como um parâmetro, um arquivo de dispositivo que representa a partição a ser formatada (por exemplo, <filename>/dev/sda1</filename>). Esta operação é destrutiva e só deve ser executado uma vez, exceto quando se queira limpar deliberadamente um sistema de arquivos e começar de novo."

msgid "There are also network filesystems, such as <acronym>NFS</acronym>, where data is not stored on a local disk. Instead, data is transmitted through the network to a server that stores and retrieves them on demand. The filesystem abstraction shields users from having to care: files remain accessible in their usual hierarchical way."
msgstr "Há também sistemas de arquivos de rede, como o <acronym>NFS</acronym>, em que os dados não são armazenados em um disco local. Em vez disso, os dados são transmitidos através da rede para um servidor que os armazena e recupera sob demanda. A abstração de sistema de arquivos protege os usuários de se preocuparem com: arquivos permanecem acessíveis na sua forma hierárquica usual."

msgid "Shared Functions"
msgstr "Funções Compartilhadas"

msgid "Since a number of the same functions are used by all software, it makes sense to centralize them in the kernel. For instance, shared filesystem handling allows any application to simply open a file by name, without needing to worry where the file is stored physically. The file can be stored in several different slices on a hard disk, or split across several hard disks, or even stored on a remote file server. Shared communication functions are used by applications to exchange data independently of the way the data is transported. For instance, transport could be over any combination of local or wireless networks, or over a telephone landline."
msgstr "Uma vez que uma quantidade das mesmas funções são usadas por todos os softwares, não faz sentido centralizá-las no kernel. Por exemplo, a gestão de sistemas de arquivos compartilhados permite que qualquer aplicativo simplesmente abra um arquivo pelo nome, sem precisar se preocupar onde o arquivo está armazenado fisicamente. O arquivo pode ser armazenado em diferentes partes em um disco rígido, ou dividido em vários discos rígidos, ou mesmo armazenado em um servidor de arquivos remoto. As funções de comunicação compartilhadas são usadas por aplicativos para troca de dados de forma independente da forma como os dados são transportados. Por exemplo, o transporte poderia ser sobre qualquer combinação de redes locais sem fio ou através de uma linha telefônica."

msgid "<primary><emphasis>pid</emphasis></primary>"
msgstr "<primary><emphasis>pid</emphasis></primary>"

msgid "A process is a running instance of a program. This requires memory to store both the program itself and its operating data. The kernel is in charge of creating and tracking them. When a program runs, the kernel first sets aside some memory, then loads the executable code from the filesystem into it, and then starts the code running. It keeps information about this process, the most visible of which is an identification number known as <emphasis>pid</emphasis> (<emphasis>process identifier</emphasis>)."
msgstr "Um processo é uma instância em execução de um programa. Ele requer memória para armazenar tanto o próprio programa quanto seus dados operacionais. O núcleo é responsável por criar e acompanhá-los. Quando um programa é executado, o núcleo primeiro reserva alguma memória, em seguida carrega o código executável do sistema de arquivos para ele, e então começa a execução do código. Ele mantém informações sobre este processo, sendo a mais visível um número de identificação conhecido como <emphasis>pid</emphasis> (<emphasis>process identifier</emphasis> - identificador de processo)."

msgid "Unix-like kernels (including Linux), like most other modern operating systems, are capable of “multi-tasking”. In other words, they allow running many processes “at the same time”. There is actually only one running process at any one time, but the kernel cuts time into small slices and runs each process in turn. Since these time slices are very short (in the millisecond range), they create the illusion of processes running in parallel, although they are actually only active during some time intervals and idle the rest of the time. The kernel's job is to adjust its scheduling mechanisms to keep that illusion, while maximizing the global system performance. If the time slices are too long, the application may not appear as responsive as desired. Too short, and the system loses time switching tasks too frequently. These decisions can be tweaked with process priorities. High-priority processes will run for longer and with more frequent time slices than low-priority processes."
msgstr "Núcleos tipo Unix (incluindo o Linux), como a maioria dos outros sistemas operacionais modernos, são capazes de \"multitarefa\". Em outras palavras, eles permitem a execução de vários processos \"ao mesmo tempo\". Na verdade, há apenas um processo em execução em qualquer momento, mas o kernel divide o tempo em pequenas porções e executa um processo de cada vez. Uma vez que estas porções de tempo são muito curtas (com intervalo em milissegundos), cria-se a ilusão de processos em execução em paralelo, embora estejam, na verdade, somente ativo durante alguns intervalos de tempo e ociosos no resto do tempo. O trabalho do kernel é ajustar seus mecanismos de agendamento para manter essa ilusão, enquanto maximiza o desempenho do sistema global. Se as porções de tempo são muito longas, o aplicativo pode não parecer responsivo como desejado. Se são muito curtas, o sistema perde tempo trocando entre as tarefas com muita frequência. Estas decisões podem ser ajustadas pelas prioridades do processo. Os processos de alta prioridade serão executados por porções de tempo mais longas e mais frequentes do que os processos de baixa prioridade."

msgid "<emphasis>NOTE</emphasis> Multi-processor systems (and variants)"
msgstr "<emphasis>NOTA</emphasis> Sistemas multiprocessados (e suas variantes)"

msgid "The limitation described above of only one process being able to run at a time, doesn't always apply. The actual restriction is that there can only be one running process <emphasis>per processor core</emphasis> at a time. Multi-processor, multi-core or “hyper-threaded” systems allow several processes to run in parallel. The same time-slicing system is still used, though, so as to handle cases where there are more active processes than available processor cores. This is far from unusual: a basic system, even a mostly idle one, almost always has tens of running processes."
msgstr "A restrição descrita acima, de apenas um processo sendo capaz de rodar de cada vez, nem sempre é aplicável. A restrição real é que só pode haver um processo em execução <emphasis>por \"core\" de processador</emphasis> de cada vez. Sistemas multiprocessador, multi-core ou \"hiper-thread\" permitem que vários processos executem em paralelo. O mesmo sistema de divisão de tempo ainda é usado, no entanto, de forma a lidar com casos em que existem mais processos ativos do que núcleos de processador disponíveis. Isto está longe de ser incomum: um sistema básico, ainda que na maior parte inativo, quase sempre tem dezenas de processos em execução."

msgid "Of course, the kernel allows running several independent instances of the same program. But each can only access its own time slices and memory. Their data thus remain independent."
msgstr "Claro que, o núcleo permite a execução de várias instâncias independentes do mesmo programa. Mas cada uma só pode acessar os seus próprios intervalos de tempo e memória. Assim seus dados se mantém independentes."

msgid "Rights Management"
msgstr "Gerenciamento de Direitos"

msgid "Unix-like systems are also multi-user. They provide a rights management system that supports separate users and groups; it also allows control over actions based on permissions. The kernel manages data for each process, allowing it to control permissions. Most of the time, a process is identified by the user who started it. That process is only permitted to take those actions available to its owner. For instance, trying to open a file requires the kernel to check the process identity against access permissions (for more details on this particular example, see <xref linkend=\"sect.rights-management\" />)."
msgstr "Sistemas similares ao Unix também são multiusuário. Eles fornecem um sistema de gerenciamento de direitos que permite grupos e usuários separados; ele também permite controle sobre ações com base em permissões. O núcleo gerencia dados de cada processo, permitindo-lhe controlar as permissões. Na maioria das vezes, um processo é identificado pelo usuário que o iniciou. Esse processo só é capaz de agir de acordo com as permissões disponíveis para seu dono. Por exemplo, tentar abrir um arquivo requer que o núcleo verifique a identidade do processo em relação as permissões de acesso (para mais detalhes sobre este exemplo em particular, veja <xref linkend=\"sect.rights-management\"/>)."

msgid "<primary>user space</primary>"
msgstr "<primary>espaço de usuário</primary>"

msgid "<primary>kernel space</primary>"
msgstr "<primary>espaço de núcleo</primary>"

msgid "“User space” refers to the runtime environment of normal (as opposed to kernel) processes. This does not necessarily mean these processes are actually started by users because a standard system normally has several “daemon” (or background) processes running before the user even opens a session. Daemon processes are also considered user-space processes."
msgstr "\"Espaço de usuário\" refere-se ao ambiente de execução de processos normais (em oposição aos do núcleo). Isso não significa necessariamente que esses processos foram realmente iniciados por usuários, pois um sistema padrão normalmente tem vários processos \"daemon\" (serviços) (ou em segundo plano) em execução antes mesmo do usuário abrir uma sessão. Processos daemon também são considerados processos no espaço do usuário."

msgid "<primary><command>init</command></primary>"
msgstr "<primary><command>init</command></primary>"

msgid "When the kernel gets past its initialization phase, it starts the very first process, <command>init</command>. Process #1 alone is very rarely useful by itself, and Unix-like systems run with many additional processes."
msgstr "Quando o núcleo passa por sua fase de inicialização, ele inicia o primeiro de todos os processos, o <command>init</command>. O processo #1 sozinho, raramente é útil por si só, e em sistemas similares ao Unix rodam com muitos processos adicionais."

msgid "<primary><emphasis>fork</emphasis></primary>"
msgstr "<primary><emphasis>fork</emphasis></primary>"

msgid "First of all, a process can clone itself (this is known as a <emphasis>fork</emphasis>). The kernel allocates a new (but identical) process memory space, and another process to use it. At this time, the only difference between these two processes is their <emphasis>pid</emphasis>. The new process is usually called a child process, and the original process whose <emphasis>pid</emphasis> doesn't change, is called the parent process."
msgstr "Em primeiro lugar, um processo pode se clonar (isto é conhecido como <emphasis>fork</emphasis>). O núcleo aloca um novo (mas idêntico) espaço de memória do processo, e um outro processo para usá-lo. Neste momento, a única diferença entre esses dois processos é o <emphasis>pid</emphasis>. O novo processo é normalmente chamado de processo filho, e o processo original cujo <emphasis>pid</emphasis> não muda, é chamado de processo pai."

msgid "Sometimes, the child process continues to lead its own life independently from its parent, with its own data copied from the parent process. In many cases, though, this child process executes another program. With a few exceptions, its memory is simply replaced by that of the new program, and execution of this new program begins. This is the mechanism used by the init process (with process number 1) to start additional services and execute the whole startup sequence. At some point, one process among <command>init</command>'s offspring starts a graphical interface for users to log in to (the actual sequence of events is described in more details in <xref linkend=\"sect.system-boot\" />)."
msgstr "Às vezes, o processo filho continua a viver de forma independente de seu pai, com os seus próprios dados copiados do processo pai. Em muitos casos, porém, este processo filho executa outro programa. Com poucas exceções, sua memória é simplesmente substituída pela do novo programa, e a execução deste novo programa começa. Esse é o mecanismo usado pelo processo init (com processo número 1) para iniciar serviços adicionais e executar toda a sequência de inicialização. Em algum momento, um dos processos descendentes do <command>init</command> inicia uma interface gráfica para os usuários iniciarem sua sessão (a sequência dos eventos é descrita em mais detalhes no <xref linkend=\"sect.system-boot\"/>)."

msgid "When a process finishes the task for which it was started, it terminates. The kernel then recovers the memory assigned to this process, and stops giving it slices of running time. The parent process is told about its child process being terminated, which allows a process to wait for the completion of a task it delegated to a child process. This behavior is plainly visible in command-line interpreters (known as <emphasis>shells</emphasis>). When a command is typed into a shell, the prompt only comes back when the execution of the command is over. Most shells allow for running the command in the background, it is a simple matter of adding an <userinput>&amp;</userinput> to the end of the command. The prompt is displayed again right away, which can lead to problems if the command needs to display data of its own."
msgstr "Quando um processo termina a tarefa para a qual ele foi iniciado, ele termina. O núcleo então recupera a memória designada para este processo, e pára de dar porções de tempo de execução. O processo pai é avisado de que seu processo filho que está sendo encerrado, o que permite que um processo aguarde a conclusão de uma tarefa delegada a um processo filho. Este comportamento é claramente visível nos interpretadores de linha de comando (conhecidos como <emphasis>shells</emphasis>). Quando um comando é digitado em um shell, o prompt só volta quando a execução do comando é concluída. A maioria dos shells permite a execução do comando em segundo plano simplesmente adicionando um <userinput>&amp;</userinput> no final do comando. O prompt volta a ser exibido imediatamente, o que pode ser um problema se o comando deve exibir dados."

msgid "Daemons"
msgstr "Daemons"

msgid "<primary>daemon</primary>"
msgstr "<primary>daemon</primary>"

msgid "A “daemon” is a process started automatically by the boot sequence. It keeps running (in the background) to perform maintenance tasks or provide services to other processes. This “background task” is actually arbitrary, and does not match anything particular from the system's point of view. They are simply processes, quite similar to other processes, which run in turn when their time slice comes. The distinction is only in the human language: a process that runs with no interaction with a user (in particular, without any graphical interface) is said to be running “in the background” or “as a daemon”."
msgstr "Um \"daemon\" (serviço) é um processo iniciado automaticamente pela sequência de inicialização. Ele continua em execução (em segundo plano) para executar as tarefas de manutenção ou prover serviços a outros processos. Esta \"tarefa em segundo plano\" é realmente arbitrária e não tem uma importância especial do ponto de vista do sistema. Eles são simplesmente processos, bastante semelhantes a outros processos, que executam quando está em sua porção de tempo. A distinção é apenas na língua humana: dizemos que um processo que é executado sem interação com o usuário (em particular, sem qualquer interface gráfica) está em execução \"em segundo plano\" ou \"como um serviço\"."

msgid "<emphasis>VOCABULARY</emphasis> Daemon, demon, a derogatory term?"
msgstr "<emphasis>VOCABULÁRIO</emphasis> Daemon, demon, um termo depreciativo?"

msgid "Although <emphasis>daemon</emphasis> term shares its Greek etymology with <emphasis>demon</emphasis>, the former does not imply diabolical evil, instead, it should be understood as a kind of helper spirit. This distinction is subtle enough in English; it is even worse in other languages where the same word is used for both meanings."
msgstr "Em inglês, utiliza-se o termo <emphasis>daemon</emphasis> compartilhando sua etimologia grega com <emphasis>demônio</emphasis>, o que não implica formalmente mal diabólico, ao contrário, deve ser entendido como uma espécie de espírito ajudante. Esta distinção é sutil o suficiente em inglês; é ainda pior em outras línguas em que a mesma palavra é usada para ambos os significados."

msgid "Several such daemons are described in detail in <xref linkend=\"unix-services\" />."
msgstr "Vários desses daemons são descritos em detalhes em <xref linkend=\"unix-services\"/>."

msgid "Inter-Process Communications"
msgstr "Comunicação Inter Processos"

msgid "<primary>IPC</primary>"
msgstr "<primary>IPC</primary>"

msgid "<primary>Inter-Process Communications</primary>"
msgstr "<primary>Comunicação Inter Processos</primary>"

msgid "An isolated process, whether a daemon or an interactive application, is rarely useful on its own, which is why there are several methods allowing separate processes to communicate together, either to exchange data or to control one another. The generic term referring to this is <emphasis>inter-process communication</emphasis>, or IPC for short."
msgstr "Um processo isolado, seja um daemon ou um aplicativo interativo, raramente é útil por si só, e é por isso que existem vários métodos que permitem a comunicação entre os processos separados, seja para troca de dados ou para controlar um ao outro. O termo genérico que se refere a isso é <emphasis>comunicação entre processos</emphasis>, ou IPC (Inter-Process Communication) para abreviar."

msgid "The simplest IPC system is to use files. The process that wishes to send data writes it into a file (with a name known in advance), while the recipient only has to open the file and read its contents."
msgstr "O sistema IPC mais simples é utilizar arquivos. O processo que deseja enviar dados escreve-os em um arquivo (com um nome já conhecido), enquanto o destinatário só precisa abrir o arquivo e ler seu conteúdo."

msgid "<primary><emphasis>pipe</emphasis></primary>"
msgstr "<primary><emphasis>pipe</emphasis></primary>"

msgid "In the case where you do not wish to store data on disk, you can use a <emphasis>pipe</emphasis>, which is simply an object with two ends; bytes written in one end are readable at the other. If the ends are controlled by separate processes, this leads to a simple and convenient inter-process communication channel. Pipes can be classified into two categories: named pipes, and anonymous pipes. A named pipe is represented by an entry on the filesystem (although the transmitted data is not stored there), so both processes can open it independently if the location of the named pipe is known beforehand. In cases where the communicating processes are related (for instance, a parent and its child process), the parent process can also create an anonymous pipe before forking, and the child inherits it. Both processes will then be able to exchange data through the pipe without needing the filesystem."
msgstr "No caso de você não desejar armazenar dados em disco, você pode usar um <emphasis>pipe</emphasis> (conexão), que é simplesmente um objeto com duas extremidades; bytes escritos em uma extremidade são legíveis na outra. Se as extremidades são controladas por processos separados, ela se converte em um canal de comunicação entre processos simples e conveniente. Pipes podem ser classificados em duas categorias: pipes nomeados e pipes anônimos. Um pipe nomeado é representado por uma entrada no sistema de arquivos (embora os dados transmitidos não são armazenados lá), para que ambos os processos posam abri-lo de forma independente desde que a localização do pipe nomeado seja conhecida antecipadamente. Nos casos em que os processos se comunicando sejam relacionados (por exemplo, um pai e seu processo filho), o processo pai também pode criar um pipe anônimo antes da bifurcação (fork), e o filho o herda. Assim, ambos os processos serão capazes de trocar dados através do pipe sem a necessidade do sistema de arquivos."

msgid "<emphasis>IN PRACTICE</emphasis> A concrete example"
msgstr "<emphasis>NA PRÁTICA</emphasis> Um exemplo concreto"

msgid "Let's describe in some detail what happens when a complex command (a <emphasis>pipeline</emphasis>) is run from a shell. We assume we have a <command>bash</command> process (the standard user shell on Debian), with <emphasis>pid</emphasis> 4374; into this shell, we type the command: <command>ls | sort</command> ."
msgstr "Vamos descrever em detalhes o que acontece quando um comando complexo (um <emphasis>pipeline</emphasis>) é executado a partir de um shell. Vamos assumir que temos um processo <command>bash</command> (o shell do usuário padrão no Debian), com <emphasis>pid</emphasis> 4374; neste shell podemos digitar o comando: <command>ls | sort</command>."

msgid "The shell first interprets the command typed in. In our case, it understands there are two programs (<command>ls</command> and <command>sort</command>), with a data stream flowing from one to the other (denoted by the <userinput>|</userinput> character, known as <emphasis>pipe</emphasis>). <command>bash</command> first creates an unnamed pipe (which initially exists only within the <command>bash</command> process itself)."
msgstr "O shell primeiro interpreta o comando digitado nele. No nosso caso, ele entende que existem dois programas (<command>ls</command> e <command>sort</command>), com um fluxo de dados que flui de um para o outro (denotado pelo caractere <userinput>|</userinput>, conhecido como <emphasis>pipe</emphasis>). O <command>bash</command> primeiro cria um pipe sem nome (que inicialmente só existe dentro do processo <command>bash</command> em si)."

msgid "Then the shell clones itself; this leads to a new <command>bash</command> process, with <emphasis>pid</emphasis> #4521 (<emphasis>pids</emphasis> are abstract numbers, and generally have no particular meaning). Process #4521 inherits the pipe, which means it is able to write in its “input” side; <command>bash</command> redirects its standard output stream to this pipe's input. Then it executes (and replaces itself with) the <command>ls</command> program, which lists the contents of the current directory. Since <command>ls</command> writes on its standard output, and this output has previously been redirected, the results are effectively sent into the pipe."
msgstr "Então o shell se clona; isso leva a um novo processo <command>bash</command> com <emphasis>pid</emphasis> #4521 (<emphasis>pids</emphasis> são números abstratos e geralmente não têm significado particular). O processo #4521 herda o pipe, o que significa que é capaz de escrever em seu lado de \"entrada\"; o <command>bash</command> redireciona seu fluxo de saída padrão para a entrada deste pipe. Em seguida, ele executa (e substitui-se com) o <command>ls</command> do programa, que lista o conteúdo do diretório atual. Como o <command>ls</command> escreve em sua saída padrão, e anteriormente se direcionou esta saída, seus resultados são efetivamente enviados para o pipe."

msgid "A similar operation happens for the second command: <command>bash</command> clones itself again, leading to a new <command>bash</command> process with pid #4522. Since it is also a child process of #4374, it also inherits the pipe; <command>bash</command> then connects its standard input to the pipe output, then executes (and replaces itself with) the <command>sort</command> command, which sorts its input and displays the results."
msgstr "Uma operação similar acontece para o segundo comando: o<command>bash</command> se clona novamente, levando a um novo processo <command>bash</command> com pid #4522. Como também é um processo filho do #4374, também herda o pipe; em seguida o <command>bash</command> conecta sua entrada padrão com a saída do pipe, então executa (e substitui a si mesmo com) o comando <command>sort</command>, que classifica sua entrada e exibe os resultados."

msgid "All the pieces of the puzzle are now set up: <command>ls</command> reads the current directory and writes the list of files into the pipe; <command>sort</command> reads this list, sorts it alphabetically, and displays the results. Processes numbers #4521 and #4522 then terminate, and #4374 (which was waiting for them during the operation), resumes control and displays the prompt to allow the user to type in a new command."
msgstr "Todas as peças do quebra-cabeça agora estão definidas: o <command>ls</command> lê o diretório atual e escreve a lista de arquivos dentro do pipe; o <command>sort</command> lê esta lista, classifica-a em ordem alfabética e exibe os resultados. Os processos números #4521 e #4522 encerram, e o #4374 (que estava esperando por eles durante a operação), retoma o controle e exibe o prompt permitindo que o usuário digite um novo comando."

msgid "Not all inter-process communications are used to move data around, though. In many situations, the only information that needs to be transmitted are control messages such as “pause execution” or “resume execution”. Unix (and Linux) provides a mechanism known as <emphasis>signals</emphasis>, through which a process can simply send a specific signal (chosen from a predefined list of signals) to another process. The only requirement is to know the <emphasis>pid</emphasis> of the target."
msgstr "No entanto, nem todas as comunicações entre processos são usadas para mover dados. Em muitas situações, a única informação que deve ser transmitida são mensagens de controle tais como \"execução em pausa\" ou \"retomar execução\". O Unix (e Linux) fornece um mecanismo conhecido como <emphasis>sinais</emphasis>, através do qual um processo pode simplesmente enviar um sinal específico (escolhido dentro de uma lista pré-definida de sinais) para outro processo. O único requisito é saber o <emphasis>pid</emphasis> do alvo."

msgid "For more complex communications, there are also mechanisms allowing a process to open access, or share, part of its allocated memory to other processes. Memory now shared between them can be used to move data between the processes."
msgstr "Para comunicações mais complexas também existem mecanismos que permitem que um processo abra o acesso, ou compartilhe, parte da memória alocada para outros processos. A memória agora compartilhada entre eles pode ser usada para mover dados entre os processos."

msgid "Finally, network connections can also help processes communicate; these processes can even be running on different computers, possibly thousands of kilometers apart."
msgstr "Finalmente, as conexões de rede também podem ajudar a comunicação de processos; esses processos podem até ser executados em diferentes computadores, possivelmente a milhares de quilômetros de distância."

msgid "It is quite standard for a typical Unix-like system to make use of all these mechanisms to various degrees."
msgstr "É bastante normal para um típico sistema similar ao Unix fazer uso de todos esses mecanismos em vários graus."

msgid "Libraries"
msgstr "Bibliotecas"

msgid "<primary>library (of functions)</primary>"
msgstr "<primary>biblioteca (de funções)</primary>"

msgid "Function libraries play a crucial role in a Unix-like operating system. They are not proper programs, since they cannot be executed on their own, but collections of code fragments that can be used by standard programs. Among the common libraries, you can find:"
msgstr "Bibliotecas de funções desempenham um papel crucial em um sistema operacional similar ao Unix. Elas não são programas propriamente ditos, uma vez que não podem ser executadas por si próprias, mas coleções de fragmentos de código que podem ser utilizados pelos programas normais. Entre as bibliotecas comuns, você pode encontrar:"

msgid "the standard C library (<emphasis>glibc</emphasis>), which contains basic functions such as ones to open files or network connections, and others facilitating interactions with the kernel;"
msgstr "a biblioteca padrão C (<emphasis>glibc</emphasis>), que contém as funções básicas como aquelas para abrir arquivos ou conexões de rede, e outras que facilitam as interações com o kernel;"

msgid "graphical toolkits, such as Gtk+ and Qt, allowing many programs to reuse the graphical objects they provide;"
msgstr "toolkits gráficos, como Gtk+ e Qt, permitindo que muitos programas reutilizem os objetos gráficos que eles fornecem;"

msgid "the <emphasis>libpng</emphasis> library, that allows loading, interpreting and saving images in the PNG format."
msgstr "a biblioteca <emphasis>libpng</emphasis> que permite carregar, interpretar e salvar imagens no formato PNG."

msgid "Thanks to those libraries, applications can reuse existing code. Application development is simplified since many applications can reuse the same functions. With libraries often developed by different persons, the global development of the system is closer to Unix's historical philosophy."
msgstr "Graças a essas bibliotecas, as aplicações podem reutilizar o código existente. O desenvolvimento de aplicações é simplificado já que muitas aplicações podem reutilizar as mesmas funções. Como as bibliotecas são geralmente desenvolvidas por pessoas diferentes, o desenvolvimento global do sistema está mais perto da filosofia histórica do Unix."

msgid "<emphasis>CULTURE</emphasis> The Unix Way: one thing at a time"
msgstr "<emphasis>CULTURA</emphasis> O Estilo Unix: uma coisa de cada vez"

msgid "One of the fundamental concepts that underlies the Unix family of operating systems is that each tool should only do one thing, and do it well; applications can then reuse these tools to build more advanced logic on top. This philosophy can be seen in many incarnations. Shell scripts may be the best example: they assemble complex sequences of very simple tools (such as <command>grep</command>, <command>wc</command>, <command>sort</command>, <command>uniq</command> and so on). Another implementation of this philosophy can be seen in code libraries: the <emphasis>libpng</emphasis> library allows reading and writing PNG images, with different options and in different ways, but it does only that; no question of including functions that display or edit images."
msgstr "Um dos conceitos fundamentais da família de sistemas operacionais Unix é que cada ferramenta deve fazer uma coisa, e fazê-lo bem; aplicações podem reutilizar essas ferramentas para criar uma lógica mais avançada sobre elas. Essa filosofia pode ser vista em muitas encarnações. Shell scripts podem ser o melhor exemplo: eles montam sequências complexas de ferramentas muito simples (como <command>grep</command>, <command>wc</command>, <command>sort</command>, <command>uniq</command> e assim por diante). Outra implementação dessa filosofia pode ser vista em bibliotecas de código: a biblioteca <emphasis>libpng</emphasis> permite ler e escrever imagens PNG, com diferentes opções e de maneiras diferentes, mas ela faz só isso; nenhuma questão de incluir funções que exibem ou editam imagens."

msgid "Moreover, these libraries are often referred to as “shared libraries”, since the kernel is able to only load them into memory once, even if several processes use the same library at the same time. This allows saving memory, when compared with the opposite (hypothetical) situation where the code for a library would be loaded as many times as there are processes using it."
msgstr "Além disso, essas bibliotecas muitas vezes são chamadas de \"bibliotecas compartilhadas\", já que o núcleo pode carregá-las apenas uma vez para a memória, mesmo se vários processos utilizam a mesma biblioteca ao mesmo tempo. Isso permite economia de memória, quando comparado com a situação oposta (hipotética), onde o código para uma biblioteca seria carregado tantas vezes quantos os processos que a utilizam."
