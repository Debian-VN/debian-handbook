# AUTHOR <EMAIL@ADDRESS>, YEAR.
msgid ""
msgstr ""
"Project-Id-Version: 0\n"
"POT-Creation-Date: 2015-10-21 09:09+0200\n"
"PO-Revision-Date: 2015-11-17 15:04+0000\n"
"Last-Translator: Adrià García-Alzórriz <adria@fsfe.org>\n"
"Language-Team: Spanish <https://hosted.weblate.org/projects/debian-handbook/01_the-debian-project/es/>\n"
"Language: es-ES\n"
"MIME-Version: 1.0\n"
"Content-Type: application/x-publican; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=n != 1;\n"
"X-Generator: Weblate 2.5-dev\n"

msgid "BIOS"
msgstr "BIOS"

msgid "Kernel"
msgstr "Núcleo"

msgid "Unix"
msgstr "Unix"

msgid "Process"
msgstr "Proceso"

msgid "Hierarchy"
msgstr "Jerarquía"

msgid "Basic Commands"
msgstr "Órdenes básicas"

msgid "Short Remedial Course"
msgstr "Curso breve de emergencia"

msgid "Even though this book primarily targets administrators and “power-users”, we wouldn't like to exclude motivated beginners. This appendix will therefore be a crash-course describing the fundamental concepts involved in handling a Unix computer."
msgstr "Si bien este libro está apuntado principalmente a administradores y «usuarios avanzados», no deseamos excluir a novatos motivados. Por lo tanto, este apéndice será un curso acelerado que describe los conceptos fundamentales involucrados en el manejo de un equipo Unix."

msgid "Shell and Basic Commands"
msgstr "Consola y órdenes básicas"

msgid "In the Unix world, every administrator has to use the command line sooner or later; for example, when the system fails to start properly and only provides a command-line rescue mode. Being able to handle such an interface, therefore, is a basic survival skill for these circumstances."
msgstr "En el mundo Unix, todo administrador debe utilizar la línea de órdenes tarde o temprano; por ejemplo, cuando el sistema no inicia adecuadamente y sólo provee la consola de modo de rescate. Poder manejar tal interfaz es, por lo tanto, una habilidad de supervivencia básica para dichas circunstancias."

msgid "<emphasis>QUICK LOOK</emphasis> Starting the command interpreter"
msgstr "<emphasis>VISTA RÁPIDA</emphasis> Inicio del intérprete de órdenes"

msgid "A command-line environment can be run from the graphical desktop, by an application known as a “terminal”. In GNOME, you can start it from the “Activities” overview (that you get when you move the mouse in the top-left corner of the screen) by typing the first letters of the application name. In KDE, you will find it in the <menuchoice><guimenu>K</guimenu> <guisubmenu>Applications</guisubmenu> <guisubmenu>System</guisubmenu></menuchoice> menu."
msgstr "Puede ejecutar un entorno de línea de órdenes desde el escritorio gráficos, con una aplicación conocida como «terminal»,  como las que encontrará en la vista «Actividades» de Gnome (es la que verá cuando mueva el ratón a la esquina superior izaquierda tecleando las primeras letras del nombre de la aplicación). En KDE lo encontrará en <menuchoice><guimenu>K</guimenu> <guisubmenu>Aplicaciones</guisubmenu> <guisubmenu>Sistema</guisubmenu></menuchoice>."

msgid "This section only gives a quick peek at the commands. They all have many options not described here, so please refer to the abundant documentation in their respective manual pages."
msgstr "Esta sección sólo provee una mirada rápida de las órdenes. Todas tienen muchas opciones que no describimos, así que le remitimos a la abundante documentación de las que dispone en sus respectivas páginas de manual."

msgid "Browsing the Directory Tree and Managing Files"
msgstr "Navegación del árbol de directorios y gestión de archivos"

msgid "Once a session is open, the <command>pwd</command> command (which stands for <emphasis>print working directory</emphasis>) displays the current location in the filesystem. The current directory is changed with the <command>cd <replaceable>directory</replaceable></command> command (<command>cd</command> is for <emphasis>change directory</emphasis>). The parent directory is always called <literal>..</literal> (two dots), whereas the current directory is also known as <literal>.</literal> (one dot). The <command>ls</command> command allows <emphasis>listing</emphasis> the contents of a directory. If no parameters are given, it operates on the current directory."
msgstr "Una vez que abrió una sesión, el programa <command>pwd</command> (que significa <emphasis>imprimir directorio de trabajo</emphasis>: «print working directory») mostrará la ubicación actual en el sistema de archivos. Puede cambiar el directorio actual ejecutando <command>cd <replaceable>directorio</replaceable></command> (<command>cd</command> significa <emphasis>cambiar directorio</emphasis>: «change directory»). El directorio padre siempre se llama <literal>..</literal> (dos puntos), mientras que también se conoce al directorio actual como <literal>.</literal> (un punto). El programa <command>ls</command> permite <emphasis>enumerar</emphasis> («listing») el contenido de un directorio. Si no le provee ningún parámetro, operará en el directorio actual."

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog\n"
"$ </computeroutput><userinput>cd Desktop</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog/Desktop\n"
"$ </computeroutput><userinput>cd .</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog/Desktop\n"
"$ </computeroutput><userinput>cd ..</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog\n"
"$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates\n"
"Documents  Music      Public    Videos</computeroutput>\n"
"      "
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog\n"
"$ </computeroutput><userinput>cd Desktop</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog/Desktop\n"
"$ </computeroutput><userinput>cd .</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog/Desktop\n"
"$ </computeroutput><userinput>cd ..</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog\n"
"$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates\n"
"Documents  Music      Public    Videos</computeroutput>\n"
"      "

msgid "A new directory can be created with <command>mkdir <replaceable>directory</replaceable></command>, and an existing (empty) directory can be removed with <command>rmdir <replaceable>directory</replaceable></command>. The <command>mv</command> command allows <emphasis>moving</emphasis> and/or renaming files and directories; <emphasis>removing</emphasis> a file is achieved with <command>rm <replaceable>file</replaceable></command>."
msgstr "Puede crear un directorio nuevo con <command>mkdir <replaceable>directorio</replaceable></command> y puede eliminar un directorio existente (y vacío) con <command>rmdir <replaceable>directorio</replaceable></command>. El programa <command>mv</command> permite <emphasis>mover</emphasis> («move») y/o cambiar el nombre de archivos y directorios; <emphasis>eliminará</emphasis> («remove») un archivo con <command>rm <replaceable>archivo</replaceable></command>."

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>mkdir test</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates  Videos\n"
"Documents  Music      Public    test\n"
"$ </computeroutput><userinput>mv test new</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  new       Public     Videos\n"
"Documents  Music      Pictures  Templates\n"
"$ </computeroutput><userinput>rmdir new</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates  Videos\n"
"Documents  Music      Public</computeroutput>\n"
"      "
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>mkdir test</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates  Videos\n"
"Documents  Music      Public    test\n"
"$ </computeroutput><userinput>mv test new</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  new       Public     Videos\n"
"Documents  Music      Pictures  Templates\n"
"$ </computeroutput><userinput>rmdir new</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates  Videos\n"
"Documents  Music      Public</computeroutput>\n"
"      "

msgid "Displaying and Modifying Text Files"
msgstr "Visualización y modificación de archivos de texto"

msgid "The <command>cat <replaceable>file</replaceable></command> command (intended to <emphasis>concatenate</emphasis> files to the standard output device) reads a file and displays its contents on the terminal. If the file is too big to fit on a screen, use a pager such as <command>less</command> (or <command>more</command>) to display it page by page."
msgstr "Si ejecuta <command>cat <replaceable>archivo</replaceable></command> (<emphasis>concatena</emphasis> — «concatenate» — archivos a su salida estándar del dispositivo) éste leerá el archivo y mostrará sus contenidos en la terminal. Si el archivo es demasiado grande para entrar en una pantalla, utilice un paginador como <command>less</command> (o <command>more</command>) para mostrarlo página por página."

msgid "The <command>editor</command> command starts a text editor (such as <command>vi</command> or <command>nano</command>) and allows creating, modifying and reading text files. The simplest files can sometimes be created directly from the command interpreter thanks to redirection: <command>echo \"<replaceable>text</replaceable>\" &gt;<replaceable>file</replaceable></command> creates a file named <replaceable>file</replaceable> with “<replaceable>text</replaceable>” as its contents. Adding a line at the end of this file is possible too, with a command such as <command>echo \"<replaceable>moretext</replaceable>\" &gt;&gt;<replaceable>file</replaceable></command>. Note the <literal>&gt;&gt;</literal> in this example."
msgstr "El programa <command>editor</command> inicia un editor de texto (como <command>vi</command> o <command>nano</command>) y permite crear, modificar y leer archivos de texto. A veces puede crear los archivos más simples directamente desde el intérprete utilizando redirección: <command>echo \"<replaceable>texto</replaceable>\" &gt;<replaceable>archivo</replaceable></command> creará un archivo llamado <replaceable>archivo</replaceable> con «<replaceable>texto</replaceable>» como su contenido. También es posible agregar una línea al final de este archivo si ejecuta algo como <command>echo \"<replaceable>moretext</replaceable>\" &gt;&gt; <replaceable>archivo</replaceable></command>. Note el <literal>&gt;&gt;</literal> en este ejemplo."

msgid "Searching for Files and within Files"
msgstr "Búsqueda de y en archivos"

msgid "The <command>find <replaceable>directory</replaceable> <replaceable>criteria</replaceable></command> command looks for files in the hierarchy under <replaceable>directory</replaceable> according to several criteria. The most commonly used criterion is <literal>-name <replaceable>name</replaceable></literal>: that allows looking for a file by its name."
msgstr "Si ejecuta <command>find <replaceable>directorio</replaceable> <replaceable>criterio</replaceable></command>, buscará archivos en la jerarquía dentro de <replaceable>directorio</replaceable> según varios criterios. El criterio utilizado más frecuentemente es <literal>-name <replaceable>nombre</replaceable></literal>: permite buscar un archivo según su nombre."

msgid "The <command>grep <replaceable>expression</replaceable> <replaceable>files</replaceable></command> command searches the contents of the files and extracts the lines matching the regular expression (see sidebar <xref linkend=\"sidebar.regexp\" />). Adding the <literal>-r</literal> option enables a recursive search on all files contained in the directory passed as a parameter. This allows looking for a file when only a part of the contents are known."
msgstr "Si ejecuta <command>grep <replaceable>expresión</replaceable> <replaceable>archivos</replaceable></command> busca en el contenido de los archivos y extrae las líneas que coinciden con la expresión regular (revise el recuadro <xref linkend=\"sidebar.regexp\" />). Agregar la opción <literal>-r</literal> activa una búsqueda recursiva en todos los archivos que contenga el directorio que pasó como parámetro. Esto permite buscar en un archivo del que sólo conoce parte de su contenido."

msgid "Managing Processes"
msgstr "Gestión de proceso"

msgid "The <command>ps aux</command> command lists the processes currently running and helps identifying them by showing their <emphasis>pid</emphasis> (process id). Once the <emphasis>pid</emphasis> of a process is known, the <command>kill -<replaceable>signal</replaceable> <replaceable>pid</replaceable></command> command allows sending it a signal (if the process belongs to the current user). Several signals exist; most commonly used are <literal>TERM</literal> (a request to terminate gracefully) and <literal>KILL</literal> (a forced kill)."
msgstr "Si ejecuta <command>ps aux</command>, obtendrá una enumeración de los procesos actualmente en ejecución y le ayudará a identificarlos mostrando su <emphasis>pid</emphasis> (id de proceso: «process id»). Una vez que sabe el <emphasis>pid</emphasis> de un proceso, puede ejecutar <command>kill -<replaceable>señal</replaceable> <replaceable>pid</replaceable></command> para enviarle una señal (siempre que sea el dueño del proceso). Existen varias señales, las más utilizadas son <literal>TERM</literal> (pedido de terminación de forma ordenada) y <literal>KILL</literal> (finalización forzada)."

msgid "The command interpreter can also run programs in the background if the command is followed by a “&amp;”. By using the ampersand, the user resumes control of the shell immediately even though the command is still running (hidden from the user; as a background process). The <command>jobs</command> command lists the processes running in the background; running <command>fg %<replaceable>job-number</replaceable></command> (for <emphasis>foreground</emphasis>) restores a job to the foreground. When a command is running in the foreground (either because it was started normally, or brought back to the foreground with <command>fg</command>), the <keycombo action=\"simul\"><keycap>Control</keycap><keycap>Z</keycap></keycombo> key combination pauses the process and resumes control of the command-line. The process can then be restarted in the background with <command>bg %<replaceable>job-number</replaceable></command> (for <foreignphrase>background</foreignphrase>)."
msgstr "El intérprete de órdenes también puede ejecutar programas en segundo plano si la orden finaliza con «&amp;». Cuando utiliza el símbolo «et», el usuario recupera el control de la consola inmediatamente aún cuando la orden continúa en ejecución (escondido del usuario como un proceso en segundo plano). El programa <command>jobs</command> («trabajos») enumerará los procesos ejecutándose en segundo plano; si ejecuta <command>fg %<replaceable>número-de-trabajo</replaceable></command> (por <emphasis>primer plano</emphasis>: «foreground») recuperará en primer plano una orden. Cuando un programa esté ejecutándose en primer plano (ya sea porque se lo inició de esa forma o porque se lo recuperó desde segundo plano con <command>fg</command>) puede pausar el proceso y obtener el control de la línea de órdenes con la combinación de teclas <keycombo action=\"simul\"><keycap>Control</keycap><keycap>Z</keycap></keycombo>. Luego puede continuar el proceso en segundo plano con <command>bg %<replaceable>número-de-trabajo</replaceable></command> (por «segundo plano»: «<foreignphrase>background</foreignphrase>»)."

msgid "System Information: Memory, Disk Space, Identity"
msgstr "Información de sistema: memoria, espacio en disco, identidad"

msgid "The <command>free</command> command displays information on memory; <command>df</command> (<emphasis>disk free</emphasis>) reports on the available disk space on each of the disks mounted in the filesystem. Its <literal>-h</literal> option (for <emphasis>human readable</emphasis>) converts the sizes into a more legible unit (usually mebibytes or gibibytes). In a similar fashion, the <command>free</command> command supports the <literal>-m</literal> and <literal>-g</literal> options, and displays its data either in mebibytes or in gibibytes, respectively."
msgstr "El programa <command>free</command> («libre») muestra información sobre la memoria; <command>df</command> (<emphasis>libre en disco</emphasis>: «disk free») reporta el espacio en disco disponible para cada uno de los discos montados en el sistema de archivos. Ambos poseen la opción <literal>-h</literal> (<emphasis>legible por humanos</emphasis>: «human readable») convierte los tamaños en unidades más legibles (frecuentemente mebibytes o gibibytes). De forma similar, el programa <command>free</command> soporta las opciones <literal>-m</literal> y <literal>-g</literal> con las que mostrará, respectivamente, los datos en mebibytes o gibibytes."

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>free</userinput>\n"
"<computeroutput>             total       used       free     shared    buffers     cached\n"
"Mem:       1028420    1009624      18796          0      47404     391804\n"
"-/+ buffers/cache:     570416     458004\n"
"Swap:      2771172     404588    2366584\n"
"$ </computeroutput><userinput>df</userinput>\n"
"<computeroutput>Filesystem           1K-blocks      Used Available Use% Mounted on\n"
"/dev/sda2              9614084   4737916   4387796  52% /\n"
"tmpfs                   514208         0    514208   0% /lib/init/rw\n"
"udev                     10240       100     10140   1% /dev\n"
"tmpfs                   514208    269136    245072  53% /dev/shm\n"
"/dev/sda5             44552904  36315896   7784380  83% /home\n"
"</computeroutput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>free</userinput>\n"
"<computeroutput>             total       used       free     shared    buffers     cached\n"
"Mem:       1028420    1009624      18796          0      47404     391804\n"
"-/+ buffers/cache:     570416     458004\n"
"Swap:      2771172     404588    2366584\n"
"$ </computeroutput><userinput>df</userinput>\n"
"<computeroutput>Filesystem           1K-blocks      Used Available Use% Mounted on\n"
"/dev/sda2              9614084   4737916   4387796  52% /\n"
"tmpfs                   514208         0    514208   0% /lib/init/rw\n"
"udev                     10240       100     10140   1% /dev\n"
"tmpfs                   514208    269136    245072  53% /dev/shm\n"
"/dev/sda5             44552904  36315896   7784380  83% /home\n"
"</computeroutput>"

msgid "The <command>id</command> command displays the identity of the user running the session, along with the list of groups they belong to. Since access to some files or devices may be limited to group members, checking available group membership may be useful."
msgstr "El programa <command>id</command> muestra la identidad del usuario ejecutando la sesión junto con la lista de grupos a los que pertenece. Debido a que el acceso a algunos archivos o dispositivos puede estar limitados a miembros de ciertos grupos, puede ser útil verificar a qué grupos se pertenece."

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>id</userinput>\n"
"<computeroutput>uid=1000(rhertzog) gid=1000(rhertzog) groups=1000(rhertzog),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(netdev),109(bluetooth),115(scanner)</computeroutput>\n"
"      "
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>id</userinput>\n"
"<computeroutput>uid=1000(rhertzog) gid=1000(rhertzog) groups=1000(rhertzog),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(netdev),109(bluetooth),115(scanner)</computeroutput>\n"
"      "

msgid "Organization of the Filesystem Hierarchy"
msgstr "Organización de la jerarquía del sistema de archivos"

msgid "<primary>Filesystem Hierarchy</primary>"
msgstr "<primary>jerarquía del sistema de archivos</primary>"

msgid "The Root Directory"
msgstr "El directorio raíz"

msgid "A Debian system is organized along the <emphasis>Filesystem Hierarchy Standard</emphasis> (FHS). This standard defines the purpose of each directory. For instance, the top-level directories are described as follows:"
msgstr "Un sistema Debian está organizado según el <emphasis>estándar de jerarquía de archivos</emphasis> (FHS: «File System Hierarchy Standard»). Este estándar define el propósito de cada directorio. Por ejemplo, se describen los directorios de primer nivel como sigue:"

msgid "<filename>/bin/</filename>: basic programs;"
msgstr "<filename>/bin/</filename>: programas básicos;"

msgid "<filename>/boot/</filename>: Linux kernel and other files required for its early boot process;"
msgstr "<filename>/boot/</filename>: núcleo Linux y otros archivos necesarios para las primeras etapas del proceso de arranque;"

msgid "<filename>/dev/</filename>: device files;"
msgstr "<filename>/dev/</filename>: archivos de dispositivo;"

msgid "<filename>/etc/</filename>: configuration files;"
msgstr "<filename>/etc/</filename>: archivos de configuración;"

msgid "<filename>/home/</filename>: user's personal files;"
msgstr "<filename>/home/</filename>: archivos personales de los usuarios;"

msgid "<filename>/lib/</filename>: basic libraries;"
msgstr "<filename>/lib/</filename>: bibliotecas básicas;"

msgid "<filename>/media/*</filename>: mount points for removable devices (CD-ROM, USB keys and so on);"
msgstr "<filename>/media/*</filename>: puntos de montaje para dispositivos removibles (CD-ROM, llaves USB, etc.);"

msgid "<filename>/mnt/</filename>: temporary mount point;"
msgstr "<filename>/mnt/</filename>: punto de montaje temporal;"

msgid "<filename>/opt/</filename>: extra applications provided by third parties;"
msgstr "<filename>/opt/</filename>: aplicaciones adicionales provistas por terceros;"

msgid "<filename>/root/</filename>: administrator's (root's) personal files;"
msgstr "<filename>/root/</filename>: archivos personales del administrador (root);"

msgid "<filename>/run/</filename>: volatile runtime data that does not persist across reboots (not yet included in the FHS);"
msgstr "<filename>/run/</filename>: datos volátiles en tiempo de ejecución que no persisten entre reinicios (todavía no incluído en el FHS);"

msgid "<filename>/sbin/</filename>: system programs;"
msgstr "<filename>/sbin/</filename>: programas de sistema;"

msgid "<filename>/srv/</filename>: data used by servers hosted on this system;"
msgstr "<filename>/srv/</filename>: datos utilizados por los servidores en este sistema;"

msgid "<filename>/tmp/</filename>: temporary files; this directory is often emptied at boot;"
msgstr "<filename>/tmp/</filename>; archivos temporales; generalmente se vacía este directorio durante el arranque;"

msgid "<filename>/usr/</filename>: applications; this directory is further subdivided into <filename>bin</filename>, <filename>sbin</filename>, <filename>lib</filename> (according to the same logic as in the root directory). Furthermore, <filename>/usr/share/</filename> contains architecture-independent data. <filename>/usr/local/</filename> is meant to be used by the administrator for installing applications manually without overwriting files handled by the packaging system (<command>dpkg</command>)."
msgstr "<filename>/usr/</filename>: aplicaciones; este directorio está subdividido en <filename>bin</filename>, <filename>sbin</filename>, <filename>lib</filename> (según la misma lógica que el directorio raíz). Lo que es más, <filename>/usr/share/</filename> contiene datos independientes de la arquitectura. El objetivo de <filename>/usr/local/</filename> es para que el administrador instale aplicaciones manualmente sin sobreescribir archivos administrados por el sistema de paquetes (<command>dpkg</command>)."

msgid "<filename>/var/</filename>: variable data handled by daemons. This includes log files, queues, spools, caches and so on."
msgstr "<filename>/var/</filename>: datos variables administrados por demonios. Esto incluye archivos de registro, colas, cachés, etc."

msgid "<filename>/proc/</filename> and <filename>/sys/</filename> are specific to the Linux kernel (and not part of the FHS). They are used by the kernel for exporting data to user space (see <xref linkend=\"sect.userspace-presentation\" /> and <xref linkend=\"sect.user-space\" /> for explanations about this concept)."
msgstr "<filename>/proc/</filename> y <filename>/sys/</filename> son específicos del núcleo Linux (y no son parte del FHS). El núcleo los utiliza para exportar datos a espacio de usuario.  (vea <xref linkend=\"sect.userspace-presentation\" /> y <xref linkend=\"sect.user-space\" /> para explicaciones acerca de este concepto)."

msgid "The User's Home Directory"
msgstr "El directorio personal de los usuarios"

msgid "The contents of a user's home directory is not standardized, but there are still a few noteworthy conventions. One is that a user's home directory is often referred to by a tilde (“~”). That is useful to know because command interpreters automatically replace a tilde with the correct directory (usually <filename>/home/<replaceable>user</replaceable>/</filename>)."
msgstr "El contenido del directorio personal de un usuario no está estandarizado, pero sí existen algunas convenciones notables. Una de ellas es que usualmente se refiere al directorio personal de un usuario con una virgulilla («~»). Es útil saberlo ya que los intérpretes de órdenes reemplazan una virgulilla automáticamente con el directorio correcto (generalmente <filename>/home/<replaceable>usuario</replaceable>/</filename>)."

msgid "Traditionally, application configuration files are often stored directly under the user's home directory, but their names usually start with a dot (for instance, the <command>mutt</command> email client stores its configuration in <filename>~/.muttrc</filename>). Note that filenames that start with a dot are hidden by default; and <command>ls</command> only lists them when the <literal>-a</literal> option is used, and graphical file managers need to be told to display hidden files."
msgstr "Tradicionalmente, las aplicaciones almacenan sus archivos de configuración en el directorio personal del usuario, pero sus nombres generalmente comienzan con un punto (por ejemplo, el cliente de correo <command>mutt</command> almacena su configuración el <filename>~/.muttrc</filename>). Tenga en cuenta que los nombres de archivos que comienzan con un punto están escondidos de forma predeterminada; sólo serán enumerados por <command>ls</command> cuando utilice la opción <literal>-a</literal> y por los gestores gráficos de archivos cuando les indique que muestren archivos ocultos."

msgid "Some programs also use multiple configuration files organized in one directory (for instance, <filename>~/.ssh/</filename>). Some applications (such as the Iceweasel web browser) also use their directory to store a cache of downloaded data. This means that those directories can end up using a lot of disk space."
msgstr "Algunos programas también utilizan múltiples archivos de configuración organizados en un directorio (por ejemplo: <filename>~/.ssh/</filename>). Algunas aplicaciones (como el navegador web Iceweasel) también utlizarán su directorio para almacenar un caché de datos descargados. Esto significa que estos directorios pueden llegar a utilizar mucho espacio en disco."

msgid "These configuration files stored directly in a user's home directory, often collectively referred to as <emphasis>dotfiles</emphasis>, have long proliferated to the point that these directories can be quite cluttered with them. Fortunately, an effort led collectively under the FreeDesktop.org umbrella has resulted in the “XDG Base Directory Specification”, a convention that aims at cleaning up these files and directory. This specification states that configuration files should be stored under <filename>~/.config</filename>, cache files under <filename>~/.cache</filename>, and application data files under <filename>~/.local</filename> (or subdirectories thereof). This convention is slowly gaining traction, and several applications (especially graphical ones) have started following it."
msgstr "Estos archivos de configuración almacenados directamente en el directorio personal de los usuarios, a los que se refieren colectivamente como «<emphasis>dotfiles</emphasis>» («archivos punto»), son tan populares al punto que estos directorios pueden estar atiborrados de ellos. Afortunadamente, se desarrolló la «Especificación de directorio base XDG» («XDG Base Directory Specification») gracias a un esfuerzo colectivo bajo la tutela de FreeDesktop.org, una convención que intenta limpiar estos archivos y directorios. Esta especificación indica que se debe almacenar los archivos de configuración bajo <filename>~/.config</filename>, archivos de caché bajo <filename>~/.cache</filename> y archivos de dato de aplicaciones bajo <filename>~/.local</filename> (o subdirectorios de los mismos). Esta convención está ganando popularidad lentamente y varias aplicaciones (especialmente las gráficas) ya comenzaron a seguirla."

msgid "Graphical desktops usually display the contents of the <filename>~/Desktop/</filename> directory (or whatever the appropriate translation is for systems not configured in English) on the desktop (ie, what is visible on screen once all applications are closed or iconized)."
msgstr "Los escritorios gráficos generalmente muestran en el escritorio (es decir, lo que se ve cuando se cierran o minimizan todas las aplicaciones) el contenido del directorio <filename>~/Desktop/</filename> (o el término apropiado si el sistema está configurado en otro idioma distinto al inglés)."

msgid "Finally, the email system sometimes stores incoming emails into a <filename>~/Mail/</filename> directory."
msgstr "Finalmente, el sistema de correo a veces almacena sus correos entrantes en un directorio <filename>~/Mail/</filename>."

msgid "Inner Workings of a Computer: the Different Layers Involved"
msgstr "Funcionamiento interno de un equipo: las diferentes capas involucradas"

msgid "A computer is often considered as something rather abstract, and the externally visible interface is much simpler than its internal complexity. Such complexity comes in part from the number of pieces involved. However, these pieces can be viewed in layers, where a layer only interacts with those immediately above or below."
msgstr "Generalmente se considera a un equipo como algo bastante abstracto, y la interfaz visible al exterior es mucho más simple que su complejidad interna. Esta complejidad proviene, en parte, de la cantidad de partes involucradas. Sin embargo, podemos visualizar estas piezas en capas, donde cada capa sólo interactúa con aquellas inmediatamente sobre y bajo ella."

msgid "An end-user can get by without knowing these details… as long as everything works. When confronting a problem such as, “The internet doesn't work!”, the first thing to do is to identify in which layer the problem originates. Is the network card (hardware) working? Is it recognized by the computer? Does the Linux kernel see it? Are the network parameters properly configured? All these questions isolate an appropriate layer and focus on a potential source of the problem."
msgstr "Un usuario final puede vivir sin saber estos detalles… siempre que todo funcione. Cuando nos enfrentamos con un problema como «¡Internet no anda!», lo primero que debemos hacer es identificar en qué capa se origina el problema. ¿Está funcionando la tarjeta de red (hardware)? ¿Es reconocida por el equipo? ¿El núcleo Linux la ve? ¿Los parámetros de red configurados son correctos? Todas estas preguntas aíslan una capa apropiada y se enfocan en una fuente potencial del problema."

msgid "The Deepest Layer: the Hardware"
msgstr "La capa más profunda: el hardware"

msgid "<primary>IDE</primary>"
msgstr "<primary>IDE</primary>"

msgid "<primary>SCSI</primary>"
msgstr "<primary>SCSI</primary>"

msgid "<primary>Serial ATA</primary>"
msgstr "<primary>Serial ATA</primary>"

msgid "<primary>Parallel ATA</primary>"
msgstr "<primary>Parallel ATA</primary>"

msgid "<primary>ATA</primary>"
msgstr "<primary>ATA</primary>"

msgid "<primary>IEEE 1394</primary>"
msgstr "<primary>IEEE 1394</primary>"

msgid "<primary>Firewire</primary>"
msgstr "<primary>Firewire</primary>"

msgid "<primary>USB</primary>"
msgstr "<primary>USB</primary>"

msgid "Let us start with a basic reminder that a computer is, first and foremost, a set of hardware elements. There is generally a main board (known as the <emphasis>motherboard</emphasis>), with one (or more) processor(s), some RAM, device controllers, and extension slots for option boards (for other device controllers). Most noteworthy among these controllers are IDE (Parallel ATA), SCSI and Serial ATA, for connecting to storage devices such as hard disks. Other controllers include USB, which is able to host a great variety of devices (ranging from webcams to thermometers, from keyboards to home automation systems) and IEEE 1394 (Firewire). These controllers often allow connecting several devices so the complete subsystem handled by a controller is therefore usually known as a “bus”. Option boards include graphics cards (into which monitor screens will be plugged), sound cards, network interface cards, and so on. Some main boards are pre-built with these features, and don't need option boards."
msgstr "Comencemos recordando básicamente que una máquina es, primero y principal, un conjunto de elementos de hardware. Generalmente tendrá una placa principal (conocida como <emphasis>placa base</emphasis>: «motherboard») con uno (o más) procesadores, algo de RAM, controladores de dispositivos y puertos de extensión para placas opcionales (para otros controladores de dispositivos). Los más notables entre estos controladores son IDE (ATA paralelo), SCSI y ATA Serial para conectar dispositivos de almacenamiento como discos duros. Entre otros controladores encontraremos a USB, que es capaz de albergar una gran variedad de dispositivos (desde cámaras web a termómetros, desde teclados a sistemas de automatización hogareña) y IEEE 1394 (Firewire). Estos controladores frecuentemente permiten conectar varios dispositivos por lo que se conoce al subsistema completo gestionado por un controlador como «canal» («bus»). Las placas opcionales incluyen tarjetas gráficas (en las que conectará pantallas y monitores), tarjetas de sonido, tarjetas de interfaz de red, etc. Algunas placas principales son prefabricadas con estas funcionalidades y no necesitan placas opcionales."

msgid "<emphasis>IN PRACTICE</emphasis> Checking that the hardware works"
msgstr "<emphasis>EN LA PRÁCTICA</emphasis> Revisión del funcionamiento del hardware"

msgid "Checking that a piece of hardware works can be tricky. On the other hand, proving that it doesn't work is sometimes quite simple."
msgstr "Puede ser complicado revisar que una porción de hardware funciona. Por el otro lado, probar que no funciona a veces es muy simple."

msgid "A hard disk drive is made of spinning platters and moving magnetic heads. When a hard disk is powered up, the platter motor makes a characteristic whir. It also dissipates energy as heat. Consequently, a hard disk drive that stays cold and silent when powered up is broken."
msgstr "Un disco duro está hecho de platos giratorios y cabezas magnéticas móviles. Cuando se enciende un disco duro, el motor de las placas genera un zumbido característico. También disipa energía en forma de calor. Por lo tanto, un disco duro que se mantiene frío y silencioso al encender está roto."

msgid "Network cards often include LEDs displaying the state of the link. If a cable is plugged in and leads to a working network hub or switch, at least one LED will be on. If no LED lights up, either the card itself, the network device, or the cable between them, is faulty. The next step is therefore testing each component individually."
msgstr "Las tarjetas de red frecuentemente incluyen LEDs que muestran el estado del enlace. Si tiene un cable conectado que lleva a un switch o hub de red funcional, al menos un LED estará encendido. Si ningún LED enciende, la tarjeta en sí, el dispositivo de red o el cable entre ellos tiene una falla. El siguiente paso, obviamente, es probar cada componente de forma individual."

msgid "Some option boards — especially 3D video cards — include cooling devices, such as heat sinks and/or fans. If the fan does not spin even though the card is powered up, a plausible explanation is the card overheated. This also applies to the main processor(s) located on the main board."
msgstr "Algunas placas opcionales — especialmente las tarjetas de video 3D — incluyen dispositivos de enfriamiento como disipadores de calor y/o ventiladores. Si el ventilador no gira aún cuando se enciende la tarjeta, una explicación posible es el sobrecalentamiento de la tarjeta. Esto también es aplicable a el o los procesadores principales ubicados en la placa principal."

msgid "The Starter: the BIOS or UEFI"
msgstr "El iniciador: el BIOS o UEFI"

msgid "<primary>BIOS</primary>"
msgstr "<primary>BIOS</primary>"

msgid "<primary>UEFI</primary>"
msgstr "<primary>UEFI</primary>"

msgid "<primary>Master Boot Record (MBR)</primary>"
msgstr "<primary>Registro principal de arranque, Master Boot Record (MBR)</primary>"

msgid "Hardware, on its own, is unable to perform useful tasks without a corresponding piece of software driving it. Controlling and interacting with the hardware is the purpose of the operating system and applications. These, in turn, require functional hardware to run."
msgstr "El hardware, por sí mismo, no es capaz de realizar tareas útiles sin un software asociado que lo maneje. El propósito de los sistemas operativos y las aplicaciones es controlar e interactuar con el hardware. Éstos, sin embargo, necesitan hardware funcional para ejecutar."

msgid "This symbiosis between hardware and software does not happen on its own. When the computer is first powered up, some initial setup is required. This role is assumed by the BIOS or UEFI, a piece of software embedded into the main board that runs automatically upon power-up. Its primary task is searching for software it can hand over control to. Usually, in the BIOS case, this involves looking for the first hard disk with a boot sector (also known as the <emphasis>master boot record</emphasis> or <acronym>MBR</acronym>), loading that boot sector, and running it. From then on, the BIOS is usually not involved (until the next boot). In the case of UEFI, the process involves scanning disks to find a dedicated EFI partition containing further EFI applications to execute."
msgstr "Esta simbiosis entre el hardware y el software no ocurre por sí sola. Cuando recién se enciende el equipo es necesario cierta configuración inicial. Este rol es asumido por la BIOS o UEFI, una parte de software embebido en la placa base que se ejecuta automáticamente cuando se enciende. Su tarea principal es buscar el software y cederle el control. Normalmente en el caso de la BIOS,  esto involucra buscar el primer disco duro con un sector de arranque (también conocido como <emphasis>registro maestro de arranque</emphasis> o <acronym>MBR</acronym>: «Master Boot Record»), cargar dicho sector y ejecutarlo. De allí en adelante, usualmente no se utiliza la BIOS (hasta el próximo arranque). En el caso de UEFI, el proceso conlleva buscar en los discos para encontrar la partición dedicada a EFI que contiene las aplicaciones que EFI ejecutará más adelante."

msgid "<emphasis>TOOL</emphasis> Setup, the BIOS/UEFI configuration tool"
msgstr "<emphasis>HERRAMIENTA</emphasis> «Setup», la herramienta de configuración del BIOS/UEFI"

msgid "<primary><emphasis>Setup</emphasis></primary>"
msgstr "<primary><emphasis>Setup</emphasis></primary>"

msgid "The BIOS/UEFI also contains a piece of software called Setup, designed to allow configuring aspects of the computer. In particular, it allows choosing which boot device is preferred (for instance, the floppy disk or CD-ROM drive), setting the system clock, and so on. Starting Setup usually involves pressing a key very soon after the computer is powered on. This key is often <keycap>Del</keycap> or <keycap>Esc</keycap>, sometimes <keycap>F2</keycap> or <keycap>F10</keycap>. Most of the time, the choice is flashed on screen while booting."
msgstr "El BIOS/UEFI también contiene un software llamado «Setup», diseñado para permitir configurar aspectos del equipo. En particular, permite elegir el dispositivo de arranque preferido (por ejemplo, un disco flexible o dispositivo CD-ROM), configurar el reloj del sistema, etc. Iniciar «Setup» usualmente involucra presionar una tecla tan pronto como enciende el equipo. Generalmente esta tecla es <keycap>Del</keycap> o <keycap>Esc</keycap>, pero a veces también puede ser <keycap>F2</keycap> o <keycap>F10</keycap>. La mayoría de las veces, la tecla correcta aparece brevemente en la pantalla durante el arranque."

msgid "The boot sector (or the EFI partition), in turn, contains another piece of software, called the bootloader, whose purpose is to find and run an operating system. Since this bootloader is not embedded in the main board but loaded from disk, it can be smarter than the BIOS, which explains why the BIOS does not load the operating system by itself. For instance, the bootloader (often GRUB on Linux systems) can list the available operating systems and ask the user to choose one. Usually, a time-out and default choice is provided. Sometimes the user can also choose to add parameters to pass to the kernel, and so on. Eventually, a kernel is found, loaded into memory, and executed."
msgstr "El sector de arranque (o la partición EFI), por su parte, contiene otro software pequeño llamado el gestor de arranque, cuyo propósito es encontrar y ejecutar un sistema operativo. Debido a que dicho gestor de arranque no está embebido en la placa principal sino que se lo carga desde el disco, puede ser más inteligente que el BIOS, lo que explica porqué el BIOS no carga el sistema operativo por su cuenta. Por ejemplo, el gestor de arranque (frecuentemente GRUB en los sistemas Linux) puede enumerar los sistemas operativos disponibles y pedirle al usuario que elija uno. Usualmente, provee un tiempo de espera y una opción predeterminada. A veces el usuario también puede decidir agregar parámetros que pasarle al núcleo, etc. Eventualmente, se encuentra el núcleo, se lo carga en memoria y se lo ejecuta."

msgid "<emphasis>NOTE</emphasis> UEFI, a modern replacement to the BIOS"
msgstr "<emphasis>NOTE</emphasis> UEFI, un reemplazo moderno a la BIOS"

msgid "<primary>Secure Boot</primary>"
msgstr "<primary>Secure Boot</primary>"

msgid "UEFI is a relatively recent development. Most new computers will support UEFI booting, but usually they also support BIOS booting alongside for backwards compatibility with operating systems that are not ready to exploit UEFI."
msgstr "UEFI es un desarrollo relativamente reciente. La mayoría de los ordenadores nuevos soportarán UEFI, pero normalmente soportan tambien arranque por BIOS para asegurar compatibilidad hacia atrás con los sistemas operativos que todavía no están listos para sacar partido a UEFI."

msgid "This new system gets rid of some of the limitations of BIOS booting: with the usage of a dedicated partition, the bootloaders no longer need special tricks to fit in a tiny <emphasis>master boot record</emphasis> and then discover the kernel to boot. Even better, with a suitably built Linux kernel, UEFI can directly boot the kernel without any intermediary bootloader. UEFI is also the basic foundation used to deliver <emphasis>Secure Boot</emphasis>, a technology ensuring that you run only software validated by your operating system vendor."
msgstr "Este nuevo sistema se deshace de algunas de las limitaciones del arranque BIOS: con la parte útil de la partición dedicada, los gestores de arranque ya no necesitan trucos especiales para adaptarse en un pequeño <emphasis> master boot record</emphasis> y hallar el kernel para arrancar. Aún mejor, con una adecuada construcción de kernel de Linux, UEFI puede arrancar directamente el kernel sin ningún gestor de arranque como intermediario. UEFI también es la base principal usada para usar <emphasis>Secure Boot</emphasis>, una tecnología que te asegura ejecutar solo software validado por el vendedor de tu sistema operativo."

msgid "The BIOS/UEFI is also in charge of detecting and initializing a number of devices. Obviously, this includes the IDE/SATA devices (usually hard disk(s) and CD/DVD-ROM drives), but also PCI devices. Detected devices are often listed on screen during the boot process. If this list goes by too fast, use the <keycap>Pause</keycap> key to freeze it for long enough to read. Installed PCI devices that don't appear are a bad omen. At worst, the device is faulty. At best, it is merely incompatible with the current version of the BIOS or main board. PCI specifications evolve, and old main boards are not guaranteed to handle newer PCI devices."
msgstr "El BIOS/UEFI también está a cargo de detectar e inicializar algunos dispositivos. Obviamente, esto incluye los dispositivos IDE/SATA (generalmente discos duros y dispositivos CD-ROM), pero también dispositivos PCI. Normalmente, se enumeran en pantalla los dispositivos detectados durante el proceso de arranque. Si la lista pasa demasiado rápido, utilice la tecla <keycap>Pause</keycap> para congelarla el tiempo suficiente para leerla. Si faltan dispositivos PCI instalados, es un mal augurio. En el peor de los casos el dispositivo tiene una falla. En el mejor de los casos, simplemente es incompatible con la versión del BIOS o la placa principal. Las especificaciones PCI evolucionan y no se garantiza que las placas principales antiguas sean compatibles con dispositivos PCI más nuevos."

msgid "The Kernel"
msgstr "El núcleo"

msgid "Both the BIOS/UEFI and the bootloader only run for a few seconds each; now we are getting to the first piece of software that runs for a longer time, the operating system kernel. This kernel assumes the role of a conductor in an orchestra, and ensures coordination between hardware and software. This role involves several tasks including: driving hardware, managing processes, users and permissions, the filesystem, and so on. The kernel provides a common base to all other programs on the system."
msgstr "Tanto el BIOS/UEFI como el gestor de arranque sólo ejecutan por unos segundos cada uno; ahora llegamos al primer software que ejecuta por más tiempo: el núcleo del sistema operativo. Este núcleo asume el rol del director en una orquesta y asegura la coordinación entre el hardware y el software. Este papel involucra varias tareas que incluyen: administrar el hardware, gestionar procesos, usuarios y permisos, el sistema de archivos, etc. El núcleo provee una base común a todos los otros programas en el sistema."

msgid "The User Space"
msgstr "El espacio de usuario"

msgid "Although everything that happens outside of the kernel can be lumped together under “user space”, we can still separate it into software layers. However, their interactions are more complex than before, and the classifications may not be as simple. An application commonly uses libraries, which in turn involve the kernel, but the communications can also involve other programs, or even many libraries calling each other."
msgstr "Si bien todo lo que ocurre fuera del núcleo puede agruparse bajo el nombre «espacio de usuario», todavía podemos separarlo en capas de software. Sin embargo, sus interacciones son más complejas que antes y la clasificación puede no ser tan simple. Una aplicación normalmente utiliza bibliotecas, que a su vez involucran al núcleo, pero la comunicación también puede involucrar otros programas o inclusive bibliotecas que interactúan entre sí."

msgid "Some Tasks Handled by the Kernel"
msgstr "Algunas tareas administradas por el núcleo"

msgid "Driving the Hardware"
msgstr "Administración del hardware"

msgid "The kernel is, first and foremost, tasked with controlling the hardware parts, detecting them, switching them on when the computer is powered on, and so on. It also makes them available to higher-level software with a simplified programming interface, so applications can take advantage of devices without having to worry about details such as which extension slot the option board is plugged into. The programming interface also provides an abstraction layer; this allows video-conferencing software, for example, to use a webcam independently of its make and model. The software can just use the <emphasis>Video for Linux</emphasis> (V4L) interface, and the kernel translates the function calls of this interface into the actual hardware commands needed by the specific webcam in use."
msgstr "El núcleo tiene, antes que nada, la tarea de controlar las partes del hardware, detectarlas, encenderlas cuando se enciende el equipo, etc. También los pone a disposición del software de más alto nivel con una interfaz de programación simplificada para que las aplicaciones puedan aprovechar dispositivos sin tener que preocuparse por detalles como cuál puerto de extensión es aquél en el que está conectada una tarjeta. La interfaz de programación también provee una capa de abstracción; permite, por ejemplo, que el software de videoconferencias utilice una cámara web independientemente de su modelo y fabricante. El software puede utilizar simplemente la interfaz <emphasis>video para Linux</emphasis> (V4L: «Video for Linux») y el núcleo traduce las llamadas a las funciones de esta interfaz a las órdenes de hardware reales que necesita la cámara específica que está utilizando."

msgid "<indexterm><primary><command>lspci</command></primary></indexterm> <indexterm><primary><command>lsusb</command></primary></indexterm> <indexterm><primary><command>lsdev</command></primary></indexterm> <indexterm><primary><command>lspcmcia</command></primary></indexterm> The kernel exports many details about detected hardware through the <filename>/proc/</filename> and <filename>/sys/</filename> virtual filesystems. Several tools summarize those details. Among them, <command>lspci</command> (in the <emphasis role=\"pkg\">pciutils</emphasis> package) lists PCI devices, <command>lsusb</command> (in the <emphasis role=\"pkg\">usbutils</emphasis> package) lists USB devices, and <command>lspcmcia</command> (in the <emphasis role=\"pkg\">pcmciautils</emphasis> package) lists PCMCIA cards. These tools are very useful for identifying the exact model of a device. This identification also allows more precise searches on the web, which in turn, lead to more relevant documents."
msgstr "<indexterm><primary><command>lspci</command></primary></indexterm> <indexterm><primary><command>lsusb</command></primary></indexterm> <indexterm><primary><command>lsdev</command></primary></indexterm> <indexterm><primary><command>lspcmcia</command></primary></indexterm> El núcleo exporta muchos detalles sobre el hardware detectado a través de los sistemas de archivos virtuales <filename>/proc/</filename> y <filename>/sys/</filename>. Muchas herramientas resumen estos detalles. Entre ellas, <command>lspci</command> (en el paquete <emphasis role=\"pkg\">pciutils</emphasis>) enumera los dispositivos PCI, <command>lsusb</command> (en el paquete <emphasis role=\"pkg\">usbutils</emphasis>) enumera los dispositivos USB y <command>lspcmcia</command> (en el paquete <emphasis role=\"pkg\">pcmciautils</emphasis>) enumera las tarjetas PCMCIA. Estas herramientas son muy útiles para identificar el modelo exacto de un dispositivo. Esta identificación permite realizar búsquedas más precisas en la web lo que, a su vez, lleva a documentos más relevantes."

msgid "Example of information provided by <command>lspci</command> and <command>lsusb</command>"
msgstr "Ejemplo de información provista por <command>lspci</command> y <command>lsusb</command>"

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>lspci</userinput>\n"
"<computeroutput>[...]\n"
"00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)\n"
"00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)\n"
"00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)\n"
"[...]\n"
"01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)\n"
"02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)\n"
"$ </computeroutput><userinput>lsusb</userinput>\n"
"<computeroutput>Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.\n"
"Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.\n"
"Bus 005 Device 007: ID 045e:00dd Microsoft Corp.\n"
"Bus 005 Device 006: ID 046d:c03d Logitech, Inc.\n"
"[...]\n"
"Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth\n"
"</computeroutput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>lspci</userinput>\n"
"<computeroutput>[...]\n"
"00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)\n"
"00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)\n"
"00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)\n"
"[...]\n"
"01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)\n"
"02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)\n"
"$ </computeroutput><userinput>lsusb</userinput>\n"
"<computeroutput>Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.\n"
"Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.\n"
"Bus 005 Device 007: ID 045e:00dd Microsoft Corp.\n"
"Bus 005 Device 006: ID 046d:c03d Logitech, Inc.\n"
"[...]\n"
"Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth\n"
"</computeroutput>"

msgid "These programs have a <literal>-v</literal> option, that lists much more detailed (but usually not necessary) information. Finally, the <command>lsdev</command> command (in the <emphasis role=\"pkg\">procinfo</emphasis> package) lists communication resources used by devices."
msgstr "Estos programas tienen una opción <literal>-v</literal>, que mostrará información mucho más detallada (pero generalmente innecesaria). Finalmente, el programa <command>lsdev</command> (en el paquete <emphasis role=\"pkg\">procinfo</emphasis>) enumera los recuros de comunicación utilizados por los dispositivos."

msgid "Applications often access devices by way of special files created within <filename>/dev/</filename> (see sidebar <xref linkend=\"sidebar.special-files\" />). These are special files that represent disk drives (for instance, <filename>/dev/hda</filename> and <filename>/dev/sdc</filename>), partitions (<filename>/dev/hda1</filename> or <filename>/dev/sdc3</filename>), mice (<filename>/dev/input/mouse0</filename>), keyboards (<filename>/dev/input/event0</filename>), soundcards (<filename>/dev/snd/*</filename>), serial ports (<filename>/dev/ttyS*</filename>), and so on."
msgstr "Las aplicaciones frecuentemente acceden a los dispositivos a través de archivos especiales creados en <filename>/dev/</filename> (revise el recuadro <xref linkend=\"sidebar.special-files\" />). Éstos son archivos especiales que representan discos (por ejemplo: <filename>/dev/hda</filename> y <filename>/dev/sdc</filename>), particiones (<filename>/dev/hda1</filename> o <filename>/dev/sdc3</filename>, ratones (<filename>/dev/input/mouse0</filename>), teclados (<filename>/dev/input/event0</filename>), tarjetas de sonido (<filename>/dev/snd/*</filename>), puertos seriales (<filename>/dev/ttyS*</filename>), etc."

msgid "Filesystems"
msgstr "Sistemas de archivos"

msgid "<primary>filesystem</primary>"
msgstr "<primary>sistema de archivos</primary>"

msgid "<primary>system, filesystem</primary>"
msgstr "<primary>archivos, sistema de</primary>"

msgid "Filesystems are one of the most prominent aspects of the kernel. Unix systems merge all the file stores into a single hierarchy, which allows users (and applications) to access data simply by knowing its location within that hierarchy."
msgstr "Los sistemas de archivos son uno de los aspectos más destacados del núcleo. Los sistemas Unix agrupan todos los archivos que almacenan en una jerarquía única, lo que permite a los usuarios (y las aplicaciones) acceder a los datos simplemente conociendo su ubicación dentro de dicha jerarquía."

msgid "The starting point of this hierarchical tree is called the root, <filename>/</filename>. This directory can contain named subdirectories. For instance, the <literal>home</literal> subdirectory of <filename>/</filename> is called <filename>/home/</filename>. This subdirectory can, in turn, contain other subdirectories, and so on. Each directory can also contain files, where the actual data will be stored. Thus, the <filename>/home/rmas/Desktop/hello.txt</filename> name refers to a file named <literal>hello.txt</literal> stored in the <literal>Desktop</literal> subdirectory of the <literal>rmas</literal> subdirectory of the <literal>home</literal> directory present in the root. The kernel translates between this naming system and the actual, physical storage on a disk."
msgstr "El nombre del punto de partida de este árbol jerárquico es la raíz, <filename>/</filename>. Este directorio puede tener subdirectorios con nombres. Por ejemplo, el nombre del subdirectorio <literal>home</literal> de <filename>/</filename> es <filename>/home/</filename>. Este subdirectorio, a su vez, puede contener otros subdirectorios y así sucesivamente. Cada directorio también puede contener archivos, donde se almacenarán los datos en sí. Por lo tanto, el nombre <filename>/home/rmas/Desktop/hello.txt</filename> se refiere al archivo <literal>hello.txt</literal> almacenado en el subdirectorio <literal>Desktop</literal> del subdirectorio <literal>rmas</literal> del directorio <literal>home</literal> presente en la raíz. El núcleo traduce este sistema de nombres en el almacenamiento físico real en un disco."

msgid "Unlike other systems, there is only one such hierarchy, and it can integrate data from several disks. One of these disks is used as the root, and the others are “mounted” on directories in the hierarchy (the Unix command is called <command>mount</command>); these other disks are then available under these “mount points”. This allows storing users' home directories (traditionally stored within <filename>/home/</filename>) on a second hard disk, which will contain the <literal>rhertzog</literal> and <literal>rmas</literal> directories. Once the disk is mounted on <filename>/home/</filename>, these directories become accessible at their usual locations, and paths such as <filename>/home/rmas/Desktop/hello.txt</filename> keep working."
msgstr "A diferencia de otros sistemas, existe sólo una jerarquía de este tipo que puede integrar datos de varios discos. Se utiliza uno de estos discos como raíz y los demás son «montados» en directorios de la jerarquía (el programa Unix se llama <command>mount</command>); luego estos otros discos estarán disponibles bajo estos «puntos de montaje». Esto permite almacenar los directorios personales de los usuarios (tradicionalmente almacenados en <filename>/home/</filename>) en un disco secundario que contendrá directorios <literal>rhertzog</literal> y <literal>rmas</literal>. Una vez que se montó el disco en <filename>/home/</filename>, estos directorios estarán disponibles en su ubicación usual y continuarán funcionando las rutas como <filename>/home/rmas/Desktop/hello.txt</filename>."

msgid "<primary><command>mkfs</command></primary>"
msgstr "<primary><command>mkfs</command></primary>"

msgid "There are many filesystem formats, corresponding to many ways of physically storing data on disks. The most widely known are <emphasis>ext2</emphasis>, <emphasis>ext3</emphasis> and <emphasis>ext4</emphasis>, but others exist. For instance, <emphasis>vfat</emphasis> is the system that was historically used by DOS and Windows operating systems, which allows using hard disks under Debian as well as under Windows. In any case, a filesystem must be prepared on a disk before it can be mounted and this operation is known as “formatting”. Commands such as <command>mkfs.ext3</command> (where <command>mkfs</command> stands for <emphasis>MaKe FileSystem</emphasis>) handle formatting. These commands require, as a parameter, a device file representing the partition to be formatted (for instance, <filename>/dev/sda1</filename>). This operation is destructive and should only be run once, except if one deliberately wishes to wipe a filesystem and start afresh."
msgstr "Hay muchos sistemas de archivos que corresponden con muchas formas de almacenar físicamente los datos en discos. Los más conocidos son <emphasis>ext2</emphasis>, <emphasis>ext3</emphasis> y <emphasis>ext4</emphasis>, pero existen otros. Por ejemplo, <emphasis>vfat</emphasis> es el sistema de archivos utilizado históricamente por los sistemas operativos DOS y Windows, lo que permite utilizar discos duros tanto en Debian como en Windows. En cualquier caso, un sistema de archivos debe ser preparado en un disco antes que pueda ser montado, se conoce esta operación como «dar formato». Los programas como <command>mkfs.ext3</command> (donde <command>mkfs</command> significa <emphasis>crear sistema de archivos</emphasis>: «MaKe FileSystem») se encargan de esta operación. Estos programas necesitan, como parámetro, un archivo de dispositivo que representa la partición a la que dar formato (por ejemplo: <filename>/dev/sda1</filename>). Esta operación es destructiva y sólo debe ejecutarla una vez, excepto cuando uno desee eliminar deliberadamente un sistema de archivos y comenzar nuevamente desde cero."

msgid "There are also network filesystems, such as <acronym>NFS</acronym>, where data is not stored on a local disk. Instead, data is transmitted through the network to a server that stores and retrieves them on demand. The filesystem abstraction shields users from having to care: files remain accessible in their usual hierarchical way."
msgstr "Existen tambien sistemas de archivos de red, como <acronym>NFS</acronym>, en el que los datos no son almacenados en un disco local. En su lugar, se transmiten los datos a través de la red a un servidor que los almacena y obtiene a pedido. La abstracción del sistema de archivos evita que al usuario le importe: los archivos continúan disponibles en la forma jerárquica usual."

msgid "Shared Functions"
msgstr "Funciones compartidas"

msgid "Since a number of the same functions are used by all software, it makes sense to centralize them in the kernel. For instance, shared filesystem handling allows any application to simply open a file by name, without needing to worry where the file is stored physically. The file can be stored in several different slices on a hard disk, or split across several hard disks, or even stored on a remote file server. Shared communication functions are used by applications to exchange data independently of the way the data is transported. For instance, transport could be over any combination of local or wireless networks, or over a telephone landline."
msgstr "Debido a que una cantidad de funciones son utilizadas por todo software, tiene sentido centralizarlas en el núcleo. Por ejemplo, la gestión compartida de sistemas de archivos permite que cualquier aplicación simplemente abra un archivo, sin preocuparse dónde está almacenado físicamente dicho archivo. Éste puede estar almacenado en diferentes porciones de un disco duro, dividido entre varios discos duros o inclusive almacenado en un servidor remoto. Las funciones de comunicación compartidas son utilizadas por las aplicaciones para intercambiar datos independientemente de la forma en la que se transportan los mismos. Por ejemplo, el transporte puede ser a través de una combinación de redes locales o inalámbricas o a través de una línea telefónica terrestre."

msgid "<primary><emphasis>pid</emphasis></primary>"
msgstr "<primary><emphasis>pid</emphasis></primary>"

msgid "A process is a running instance of a program. This requires memory to store both the program itself and its operating data. The kernel is in charge of creating and tracking them. When a program runs, the kernel first sets aside some memory, then loads the executable code from the filesystem into it, and then starts the code running. It keeps information about this process, the most visible of which is an identification number known as <emphasis>pid</emphasis> (<emphasis>process identifier</emphasis>)."
msgstr "Un proceso es una instancia en ejecución de un programa. Esto necesita memoria para almacenar tanto el programa en sí como los datos con los que trabaja. El núcleo es el encargado de crearlos y seguirlos. Cuando se ejecuta un programa, primero el núcleo reserva memoria, carga en ella el código ejecutable desde el sistema de archivos y luego inicia la ejecución de este código. Mantiene información sobre este proceso, de las que la más visible es un número de identificación conocido como <emphasis>pid</emphasis> (<emphasis>identificador de proceso</emphasis>: «process identifier»)."

msgid "Unix-like kernels (including Linux), like most other modern operating systems, are capable of “multi-tasking”. In other words, they allow running many processes “at the same time”. There is actually only one running process at any one time, but the kernel cuts time into small slices and runs each process in turn. Since these time slices are very short (in the millisecond range), they create the illusion of processes running in parallel, although they are actually only active during some time intervals and idle the rest of the time. The kernel's job is to adjust its scheduling mechanisms to keep that illusion, while maximizing the global system performance. If the time slices are too long, the application may not appear as responsive as desired. Too short, and the system loses time switching tasks too frequently. These decisions can be tweaked with process priorities. High-priority processes will run for longer and with more frequent time slices than low-priority processes."
msgstr "Los núcleos similares a Unix (incluyendo a Linux), al igual que muchos otros sistemas operativos modernos, poseen la capacidad de ser «multitarea». En otras palabras, permite ejecutar muchos procesos «al mismo tiempo». En realidad sólo hay un proceso ejecutando en un momento dado, pero el núcleo divide el tiempo en pequeñas porciones y ejecuta en orden a cada proceso. Debido a que estas divisiones de tiempo son muy pequeñas (en el rango de los milisegundos), crean la ilusión de procesos ejecutando en paralelo, aún cuando sólo están activos durante algunos intervalos y en espera el resto del tiempo. La tarea del kernel es ajustar con mecanismos planeados para mantener esa ilusión, mientras se maximiza el rendimiento global del sistema. Si las divisiones de tiempo son muy extensas, la aplicación puede que no responda como se desea. Si son muy pequeñas, el sistema perderá tiempo cambiando tareas demasiado frecuentemente. Se pueden personalizar estas decisiones con las prioridades de procesos. Los procesos con prioridad alta ejecutarán por más tiempo y en intervalos más frecuentes que los procesos con prioridad baja."

msgid "<emphasis>NOTE</emphasis> Multi-processor systems (and variants)"
msgstr "<emphasis>NOTA</emphasis> Sistemas multiprocesador (y variaciones)"

msgid "The limitation described above of only one process being able to run at a time, doesn't always apply. The actual restriction is that there can only be one running process <emphasis>per processor core</emphasis> at a time. Multi-processor, multi-core or “hyper-threaded” systems allow several processes to run in parallel. The same time-slicing system is still used, though, so as to handle cases where there are more active processes than available processor cores. This is far from unusual: a basic system, even a mostly idle one, almost always has tens of running processes."
msgstr "La limitación aquí descripta sólo es un caso extremo. La restricción actual es que, en cada momento, sólo puede existir un proceso en ejecución <emphasis>por núcleo de procesador</emphasis>. Los sistemas multiprocesador, multinúcleo o con «hyper-threading» («multihilos») permite ejecutar varios procesos en paralelo. Sin embargo, se utiliza el mismo sistema de división de tiempo para administrar casos en los que existan más procesos activos que núcleos de procesador disponibles. Este caso no es extraño: un sistema básico, aún aquellos mayormente desocupados, casi siempre posee decenas de procesos en ejecución."

msgid "Of course, the kernel allows running several independent instances of the same program. But each can only access its own time slices and memory. Their data thus remain independent."
msgstr "Por supuesto, el núcleo permite ejecutar varias instancias independientes del mismo programa. Pero cada una de ellas sólo puede acceder sus propias divisiones de tiempo y su propia memoria. Sus datos, por lo tanto, se mantienen independientes."

msgid "Rights Management"
msgstr "Gestión de permisos"

msgid "Unix-like systems are also multi-user. They provide a rights management system that supports separate users and groups; it also allows control over actions based on permissions. The kernel manages data for each process, allowing it to control permissions. Most of the time, a process is identified by the user who started it. That process is only permitted to take those actions available to its owner. For instance, trying to open a file requires the kernel to check the process identity against access permissions (for more details on this particular example, see <xref linkend=\"sect.rights-management\" />)."
msgstr "Los sistemas similares a Unix también son multiusuario. Proveen un sistema que permite usuarios  separados y grupos; también permite la capacidad de decidir permitir o bloquear acciones según sus permisos. El núcleo gestiona, para cada proceso, permitiéndole controlar los permisos. La mayor parte del tiempo, cada proceso es identificado por el usuario que lo inició. Ese proceso sólo puede realizar las acciones que pueda realizar su dueño. Por ejemplo, intentar abrir un archivo requiere que el núcleo verifique la identidad del proceso según los permisos de acceso (para más detalles sobre este ejemplo particular, revise la <xref linkend=\"sect.rights-management\" />)."

msgid "<primary>user space</primary>"
msgstr "<primary>espacio de usuario</primary>"

msgid "<primary>kernel space</primary>"
msgstr "<primary>espacio de núcleo</primary>"

msgid "“User space” refers to the runtime environment of normal (as opposed to kernel) processes. This does not necessarily mean these processes are actually started by users because a standard system normally has several “daemon” (or background) processes running before the user even opens a session. Daemon processes are also considered user-space processes."
msgstr "El «espacio de usuario» se refiere al entorno de ejecución de procesos normales (en contraste con el núcleo). Esto no significa necesariamente que usuarios iniciaron realmente estos procesos debido a que un sistema estándar frecuentemente posee procesos «demonio» (o en segundo plano), procesos que se ejecutan antes que el usuario inicie una sesión. Los procesos demonio son procesos considerados en espacio de usuario."

msgid "<primary><command>init</command></primary>"
msgstr "<primary><command>init</command></primary>"

msgid "When the kernel gets past its initialization phase, it starts the very first process, <command>init</command>. Process #1 alone is very rarely useful by itself, and Unix-like systems run with many additional processes."
msgstr "Cuando el núcleo supera su fase de inicialización, ejecuta el primer proceso: <command>init</command>. El proceso #1 rara vez es útil por sí mismo, y los sistemas similares a Unix ejecutan con un ciclo de vida con muchos procesos adicionales."

msgid "<primary><emphasis>fork</emphasis></primary>"
msgstr "<primary><emphasis>bifurcación</emphasis></primary>"

msgid "First of all, a process can clone itself (this is known as a <emphasis>fork</emphasis>). The kernel allocates a new (but identical) process memory space, and another process to use it. At this time, the only difference between these two processes is their <emphasis>pid</emphasis>. The new process is usually called a child process, and the original process whose <emphasis>pid</emphasis> doesn't change, is called the parent process."
msgstr "Primero que nada, un proceso puede clonarse a sí mismo (esto es conocido como <emphasis>bifurcación</emphasis> — «fork»). El núcleo reserva un nuevo (pero idéntico) proceso de espacio en memoria, y otros procesos para usarlo. En este momento, la única diferencia entre estos dos procesos es su <emphasis>pid</emphasis>. Al nuevo proceso se le suele llamar proceso hijo al nuevo proceso y proceso padre al proceso cuyo <emphasis>pid</emphasis> no cambió."

msgid "Sometimes, the child process continues to lead its own life independently from its parent, with its own data copied from the parent process. In many cases, though, this child process executes another program. With a few exceptions, its memory is simply replaced by that of the new program, and execution of this new program begins. This is the mechanism used by the init process (with process number 1) to start additional services and execute the whole startup sequence. At some point, one process among <command>init</command>'s offspring starts a graphical interface for users to log in to (the actual sequence of events is described in more details in <xref linkend=\"sect.system-boot\" />)."
msgstr "A veces, el proceso hijo continúa su vida de forma independiente a su padre, con sus propios datos copiados del proceso padre. En muchos casos, sin embargo, el proceso hijo ejecuta otro programa. Con unas pocas excepciones, simplemente se reemplaza su memoria con aquella del nuevo programa y comienza la ejecución del mismo.Este es un mecanismo usado para el proceso de inicio (con el número 1 de proceso) para iniciar servicios adicionales y ejecutar toda la secuencia de arranque. En algún punto, uno de los proceso de la descendencia de <command>init</command> inicia una interfaz gráfica en la que los usuarios pueden iniciar sesión (describimos con más detalle la secuencia real de eventos en la <xref linkend=\"sect.system-boot\" />)."

msgid "When a process finishes the task for which it was started, it terminates. The kernel then recovers the memory assigned to this process, and stops giving it slices of running time. The parent process is told about its child process being terminated, which allows a process to wait for the completion of a task it delegated to a child process. This behavior is plainly visible in command-line interpreters (known as <emphasis>shells</emphasis>). When a command is typed into a shell, the prompt only comes back when the execution of the command is over. Most shells allow for running the command in the background, it is a simple matter of adding an <userinput>&amp;</userinput> to the end of the command. The prompt is displayed again right away, which can lead to problems if the command needs to display data of its own."
msgstr "Cuando un proceso finaliza la tarea para la que fue iniciado, termina. El núcleo recupera la memoria asignada a este proceso y no le asignará más divisiones de tiempo de ejecución. Se le informa al proceso padre sobre la finalización de su proceso hijo, lo que permite a un proceso esperar que se complete una tarea que delegó a un proceso hijo. Este comportamiento es obvio a simple vista en los intérpretes de línea de órdenes (conocidos como <emphasis>consolas</emphasis> — «shells»). Cuando se ingresa una orden en una consola, sólo vuelve el prompt cuando finaliza la ejecución de dicha orden. La mayoría de las consolas permiten ejecutar programas en segundo plano, sólo es cuestión de agregar un <userinput>&amp;</userinput> al final de la orden. Se mostrará el prompt inmediatamente, lo que puede llevar a problemas si la orden necesita mostrar datos por su cuenta."

msgid "Daemons"
msgstr "Demonios"

msgid "<primary>daemon</primary>"
msgstr "<primary>demonio</primary>"

msgid "A “daemon” is a process started automatically by the boot sequence. It keeps running (in the background) to perform maintenance tasks or provide services to other processes. This “background task” is actually arbitrary, and does not match anything particular from the system's point of view. They are simply processes, quite similar to other processes, which run in turn when their time slice comes. The distinction is only in the human language: a process that runs with no interaction with a user (in particular, without any graphical interface) is said to be running “in the background” or “as a daemon”."
msgstr "Un «demonio» es un proceso iniciado automáticamente por la secuencia de inicio. Continúa ejecutando (en segundo plano) para realizar tareas de mantenimiento o proveer servicios a otros procesos. Esta «tarea en segundo plano» es realmente arbitraria y no tiene un rol especial desde el punto de vista del sistema. Simplemente son procesos, muy similares a otros proceso, que se ejecutarán cuando le corresponda a su división de tiempo. Esta distinción es sólo para los humanos: se dice de un proceso que ejecuta sin interacción de un usuario (en particular, sin una interfaz gráfica) que ejecuta «en segundo plano» o «como un demonio»."

msgid "<emphasis>VOCABULARY</emphasis> Daemon, demon, a derogatory term?"
msgstr "<emphasis>VOCABULARIO</emphasis> Demonio, ¿un término despectivo?"

msgid "Although <emphasis>daemon</emphasis> term shares its Greek etymology with <emphasis>demon</emphasis>, the former does not imply diabolical evil, instead, it should be understood as a kind of helper spirit. This distinction is subtle enough in English; it is even worse in other languages where the same word is used for both meanings."
msgstr "En inglés, se utiliza el término «<emphasis>daemon</emphasis>» (en lugar de «<emphasis>demon</emphasis>») para hacer referencia a los demonios. Ambos comparten su etimología griega pero el primero no implica un mal diabólico; en cambio, debería entenderse como una especie de espíritu de ayuda. La distinción es suficientemente sutil en inglés; es aún peor en otros idiomas (como el español) en el que se utiliza la misma palabra para ambos significados."

msgid "Several such daemons are described in detail in <xref linkend=\"unix-services\" />."
msgstr "Describimos en detalle muchos demonios en el <xref linkend=\"unix-services\" />."

msgid "Inter-Process Communications"
msgstr "Comunicación entre procesos"

msgid "<primary>IPC</primary>"
msgstr "<primary>IPC</primary>"

msgid "<primary>Inter-Process Communications</primary>"
msgstr "<primary>comunicación entre procesos</primary>"

msgid "An isolated process, whether a daemon or an interactive application, is rarely useful on its own, which is why there are several methods allowing separate processes to communicate together, either to exchange data or to control one another. The generic term referring to this is <emphasis>inter-process communication</emphasis>, or IPC for short."
msgstr "Un proceso aislado, sea un demonio o una aplicación interactiva, rara vez es útil por sí misma, razón por la que existen varios métodos que permiten la comunicación entre dos procesos separados, ya sea para intercambiar datos o para que se controlen entre sí. El término genérico para referirse a esto es <emphasis>comunicación entre procesos</emphasis> (abreviado IPC: «Inter-Process Communication»)."

msgid "The simplest IPC system is to use files. The process that wishes to send data writes it into a file (with a name known in advance), while the recipient only has to open the file and read its contents."
msgstr "El sistema IPC más simple es utilizar archivos. El proceso que desea enviar datos, los escribe en un archivo (cuyo nombre ya conozca), mientras que el receptor sólo debe abrir este archivo y leer su contenido."

msgid "<primary><emphasis>pipe</emphasis></primary>"
msgstr "<primary><emphasis>tubería</emphasis></primary>"

msgid "In the case where you do not wish to store data on disk, you can use a <emphasis>pipe</emphasis>, which is simply an object with two ends; bytes written in one end are readable at the other. If the ends are controlled by separate processes, this leads to a simple and convenient inter-process communication channel. Pipes can be classified into two categories: named pipes, and anonymous pipes. A named pipe is represented by an entry on the filesystem (although the transmitted data is not stored there), so both processes can open it independently if the location of the named pipe is known beforehand. In cases where the communicating processes are related (for instance, a parent and its child process), the parent process can also create an anonymous pipe before forking, and the child inherits it. Both processes will then be able to exchange data through the pipe without needing the filesystem."
msgstr "En el caso en que no deseemos almacenar datos en el disco, podemos utiliza una <emphasis>tubería</emphasis> («pipe»), que simplemente es un objeto con dos extremos; los bytes escritos en uno de ellos son legibles en el otro. Si dos procesos separados controlan los extremos, esto se convierte en un canal de comunicación entre procesos simple y conveniente. Podemos clasificar las tuberías en dos: tuberías con nombre y tuberías anónimas. Se representa a una tubería con nombre como un elemento en el sistema de archivos (aunque los datos transmitidos no se almacenen en él), para que ambos procesos puedan abrirlo independientemente si ya conocen la ubicación de la misma. En los casos en los que los procesos que se comunican están relacionados (por ejemplo, un proceso padre y su hijo), el proceso padre también puede crear una tubería anónima antes de bifurcarse que será heredada por el hijo. Ambos procesos podrán intercambiar datos a través de la tubería sin necesitar el sistema de archivos."

msgid "<emphasis>IN PRACTICE</emphasis> A concrete example"
msgstr "<emphasis>EN LA PRÁCTICA</emphasis> Un ejemplo concreto"

msgid "Let's describe in some detail what happens when a complex command (a <emphasis>pipeline</emphasis>) is run from a shell. We assume we have a <command>bash</command> process (the standard user shell on Debian), with <emphasis>pid</emphasis> 4374; into this shell, we type the command: <command>ls | sort</command> ."
msgstr "Describiremos con algo de detalle lo que ocurre cuando se ejecuta en una consola una orden compleja (una <emphasis>cañería</emphasis>: «pipeline»). Asumiremos que tenemos un proceso <command>bash</command> (la consola de usuario estándar en Debian), con <emphasis>pid</emphasis> 4374; en esta consola ingresaremos la siguiente orden: <command>ls | sort</command>."

msgid "The shell first interprets the command typed in. In our case, it understands there are two programs (<command>ls</command> and <command>sort</command>), with a data stream flowing from one to the other (denoted by the <userinput>|</userinput> character, known as <emphasis>pipe</emphasis>). <command>bash</command> first creates an unnamed pipe (which initially exists only within the <command>bash</command> process itself)."
msgstr "La consola primero interpreta la orden que ingresamos. En nuestro caso, entiende que hay dos programas (<command>ls</command> y <command>sort</command>), con un flujo de datos de uno al otro (denotado por el carácter <userinput>|</userinput>, conocido como <emphasis>tubería</emphasis> — «pipe»). <command>bash</command> primero crea una tubería sin nombre (que existe sólo dentro del proceso <command>bash</command> en sí)."

msgid "Then the shell clones itself; this leads to a new <command>bash</command> process, with <emphasis>pid</emphasis> #4521 (<emphasis>pids</emphasis> are abstract numbers, and generally have no particular meaning). Process #4521 inherits the pipe, which means it is able to write in its “input” side; <command>bash</command> redirects its standard output stream to this pipe's input. Then it executes (and replaces itself with) the <command>ls</command> program, which lists the contents of the current directory. Since <command>ls</command> writes on its standard output, and this output has previously been redirected, the results are effectively sent into the pipe."
msgstr "Luego la consola se clona a sí misma; esto lleva a un nuevo proceso <command>bash</command>, con <emphasis>pid</emphasis> #4521 (los <emphasis>pid</emphasis> son números abstractos y generalmente no tienen un significado particular). El proceso #4521 hereda la tubería, lo que significa que puede escribir en su extremo de «entrada»; <command>bash</command> redirige su flujo de salida estándar a la entrada de esta tubería. Luego ejecuta (y se reemplaza a sí mismo) con el programa <command>ls</command>, que enumera el contenido del directorio actual. Debido a que <command>ls</command> escribe en su salida estándar, y anteriormente se redirigió esta salida, efectivamente se envía su resultado a la tubería."

msgid "A similar operation happens for the second command: <command>bash</command> clones itself again, leading to a new <command>bash</command> process with pid #4522. Since it is also a child process of #4374, it also inherits the pipe; <command>bash</command> then connects its standard input to the pipe output, then executes (and replaces itself with) the <command>sort</command> command, which sorts its input and displays the results."
msgstr "Ocurre una operación similar para el segundo programa: <command>bash</command> se clona a sí mismo nuevamente, lo que lleva a un nuevo proceso <command>bash</command> con pid #4522. Debido a que también es un proceso hijo de #4374, también hereda la tubería; luego <command>bash</command> conecta su entrada estándar a la salida de la tubería y luego ejecuta (y se reemplaza a sí mismo) con el programa <command>sort</command>, que ordena su entrada y muestra el resultado."

msgid "All the pieces of the puzzle are now set up: <command>ls</command> reads the current directory and writes the list of files into the pipe; <command>sort</command> reads this list, sorts it alphabetically, and displays the results. Processes numbers #4521 and #4522 then terminate, and #4374 (which was waiting for them during the operation), resumes control and displays the prompt to allow the user to type in a new command."
msgstr "Ahora están definidas todas las piezas del rompecabezas: <command>ls</command> lee el directorio actual y escribe la lista de archivos en la tubería; <command>sort</command> lee esta lista, la ordena alfabéticamente y muestra los resultados. Luego finalizan los procesos #4521 y #4522, y el proceso #4374 (que estaba esperando durante esta operación), recupera el control y muestra el prompt que permite al usuario ingresar una nueva orden."

msgid "Not all inter-process communications are used to move data around, though. In many situations, the only information that needs to be transmitted are control messages such as “pause execution” or “resume execution”. Unix (and Linux) provides a mechanism known as <emphasis>signals</emphasis>, through which a process can simply send a specific signal (chosen from a predefined list of signals) to another process. The only requirement is to know the <emphasis>pid</emphasis> of the target."
msgstr "Sin embargo, no toda la comunicación entre procesos es para mover datos. En muchas situaciones, la única información que se necesita transmitir son mensajes de control como «suspender la ejecución» o «continuar la ejecución». Unix (y Linux) provee un mecanismo llamado <emphasis>señales</emphasis>, a través de las que un proceso puede simplemente enviar una señal específica (elegida de una lista predefinida de señales) a otro proceso. El único requisito es saber el <emphasis>pid</emphasis> del objetivo."

msgid "For more complex communications, there are also mechanisms allowing a process to open access, or share, part of its allocated memory to other processes. Memory now shared between them can be used to move data between the processes."
msgstr "Para comunicaciones más complejas también existen mecanismos que le permiten a un proceso acceder, o compartir, parte de la memoria reservada para otros procesos. La memoria ahora compartida entre ellos puede ser usada para mover datos entre procesos."

msgid "Finally, network connections can also help processes communicate; these processes can even be running on different computers, possibly thousands of kilometers apart."
msgstr "Finalmente, las conexiones de red también pueden ayudar a comunicar un proceso; estos procesos inclusive puede estar ejecutando en diferentes equipos, posiblemente a miles de kilómetros de distancia."

msgid "It is quite standard for a typical Unix-like system to make use of all these mechanisms to various degrees."
msgstr "Es bastante estándar que un sistema similar a Unix típico, utilice en varios niveles estos mecanismos."

msgid "Libraries"
msgstr "Bibliotecas"

msgid "<primary>library (of functions)</primary>"
msgstr "<primary>biblioteca (de funciones)</primary>"

msgid "Function libraries play a crucial role in a Unix-like operating system. They are not proper programs, since they cannot be executed on their own, but collections of code fragments that can be used by standard programs. Among the common libraries, you can find:"
msgstr "Las bibliotecas de funciones tienen un rol crucial en un sistema operativo similar a Unix. No son programas completos ya que no se las puede ejecutar por su cuenta, sino colecciones de fragmentos de código que los programas estándar pueden utilizar. Entre las bibliotecas comunes podemos encontrar a:"

msgid "the standard C library (<emphasis>glibc</emphasis>), which contains basic functions such as ones to open files or network connections, and others facilitating interactions with the kernel;"
msgstr "la biblioteca estándar C (<emphasis>glibc</emphasis>), que contien funciones básicas como aquellas para abrir archivos o conexiones de red y otras que facilitan la interacción con el núcleo;"

msgid "graphical toolkits, such as Gtk+ and Qt, allowing many programs to reuse the graphical objects they provide;"
msgstr "herramientas gráficas, como Gtk+ y Qt, que permiten que muchos programas reutilicen los objetos gráficos que proveen;"

msgid "the <emphasis>libpng</emphasis> library, that allows loading, interpreting and saving images in the PNG format."
msgstr "la biblioteca <emphasis>libpng</emphasis>, que permite cargar, interpretar y guardar imágenes en el formato PNG."

msgid "Thanks to those libraries, applications can reuse existing code. Application development is simplified since many applications can reuse the same functions. With libraries often developed by different persons, the global development of the system is closer to Unix's historical philosophy."
msgstr "Gracias a estas bibliotecas, las aplicaciones puede reutilizar código existente. El desarrollo de la aplicación se simplifica cuando muchas aplicaciones reutilizan las mismas funciones. Debido a que diferentes personas desarrollan las bibliotecas, el desarrollo global del sistema es más cercano a la filosofía histórica de Unix."

msgid "<emphasis>CULTURE</emphasis> The Unix Way: one thing at a time"
msgstr "<emphasis>CULTURA</emphasis> La forma Unix: una cosa a la vez"

msgid "One of the fundamental concepts that underlies the Unix family of operating systems is that each tool should only do one thing, and do it well; applications can then reuse these tools to build more advanced logic on top. This philosophy can be seen in many incarnations. Shell scripts may be the best example: they assemble complex sequences of very simple tools (such as <command>grep</command>, <command>wc</command>, <command>sort</command>, <command>uniq</command> and so on). Another implementation of this philosophy can be seen in code libraries: the <emphasis>libpng</emphasis> library allows reading and writing PNG images, with different options and in different ways, but it does only that; no question of including functions that display or edit images."
msgstr "Uno de los conceptos fundamentales que subyace en la familia Unix de sistemas operativos es que cada herramienta debe hacer sólo una cosa, y hacerla bien; las aplicaciones luego pueden reutilizar estas herramientas para crear sobre ellas lógica más avanzada. Se puede ver esta filosofía en muchas encarnaciones. Los scripts de consola pueden ser el mejor ejemplo: ensamblan secuencias complejas de herramientas muy simples (como <command>grep</command>, <command>wc</command>, <command>sort</command>, <command>uniq</command>, etc.). Podemos ver otra implementación de esta filosofía en bibliotecas de código: la bilioteca <emphasis>libpng</emphasis> permite leer y escribir imágenes PNG, con diferentes opciones y en diferentes formas, pero sólo hace eso; ni considera incluir funciones que muestren o editen imágenes."

msgid "Moreover, these libraries are often referred to as “shared libraries”, since the kernel is able to only load them into memory once, even if several processes use the same library at the same time. This allows saving memory, when compared with the opposite (hypothetical) situation where the code for a library would be loaded as many times as there are processes using it."
msgstr "Lo que es más, estas bibliotecas generalmente son llamadas «bibliotecas compartidas» ya que el núcleo puede cargarlas en memoria sólo una vez, aún cuando varios procesos utilicen la misma biblioteca simultáneamente. Esto permite ahorrar memoria si lo comparamos con la situación opuesta (e hipotética) en la que se cargará el código de una biblioteca tantas veces como haya procesos que la utilizan."
