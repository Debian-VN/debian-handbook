# Dmitry Mikhirev <mikhirev@gmail.com>, 2014.
msgid ""
msgstr ""
"Project-Id-Version: 0\n"
"POT-Creation-Date: 2014-01-31T10:09:32\n"
"PO-Revision-Date: 2014-01-10T09:33:06\n"
"Last-Translator: Dmitry Mikhirev <mikhirev@gmail.com>\n"
"Language-Team: Russian <debian-handbook-ru@googlegroups.com>\n"
"Language: ru-RU\n"
"MIME-Version: 1.0\n"
"Content-Type: application/x-publican; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2;\n"
"X-Generator: Weblate 2.5-dev\n"

msgid "BIOS"
msgstr "BIOS"

msgid "Kernel"
msgstr "Ядро"

msgid "Unix"
msgstr "Unix"

msgid "Process"
msgstr "Процесс"

msgid "Hierarchy"
msgstr "Иерархия"

msgid "Basic Commands"
msgstr "Базовые команды"

msgid "Short Remedial Course"
msgstr "Короткий Коррективный Курс"

msgid "Even though this book primarily targets administrators and “power-users”, we wouldn't like to exclude motivated beginners. This appendix will therefore be a crash-course describing the fundamental concepts involved in handling a Unix computer."
msgstr "Несмотря на то, что эта книга ориентирована на администраторов и опытных пользователей, мы не хотели исключать заинтересовавшихся новичков. Это приложение - ускоренный курс,в котором описываются основные понятия, затрагивающие обращение с компьютером в Unix."

msgid "Shell and Basic Commands"
msgstr "Shell и Базовые команды"

msgid "In the Unix world, every administrator has to use the command line sooner or later; for example, when the system fails to start properly and only provides a command-line rescue mode. Being able to handle such an interface, therefore, is a basic survival skill for these circumstances."
msgstr "В мире Unix каждый администратор рано или поздно использует командную строку; например, когда система не запускается должным образом и имеется только командная строка режима восстановления. Умение управляться с командной строкой -  базовое для выживания в таких условиях."

msgid "<emphasis>QUICK LOOK</emphasis> Starting the command interpreter"
msgstr "<emphasis>КРАТКИЙ ЭКСКУРС</emphasis> Запуск командного интерпритатора"

msgid "A command-line environment can be run from the graphical desktop, by an application known as a “terminal”. In GNOME, you can start it from the “Activities” overview (that you get when you move the mouse in the top-left corner of the screen) by typing the first letters of the application name. In KDE, you will find it in the <menuchoice><guimenu>K</guimenu> <guisubmenu>Applications</guisubmenu> <guisubmenu>System</guisubmenu></menuchoice> menu."
msgstr "Окружение командной строки может быть запущено из графической среды, приложением, известным как \"Терминал\". В GNOME вы можете запустить его из обзора “Activities” (в русской локализации - \"Обзор\", который открывается когда вы перемещаете курсор мыши в левый верхний угол экрана) после ввода первых букв названия приложения. В KDE, вы найдете его в <menuchoice><guimenu>K</guimenu> <guisubmenu>Applications</guisubmenu> <guisubmenu>System</guisubmenu></menuchoice> меню."

msgid "This section only gives a quick peek at the commands. They all have many options not described here, so please refer to the abundant documentation in their respective manual pages."
msgstr "Эта секция дает только краткий обзор команд. Они все имеют много опций, не описанных здесь. Поэтому, пожалуйста, обратитесь к документации в соответствующих страницах руководства."

msgid "Browsing the Directory Tree and Managing Files"
msgstr "Обзор Дерева Каталогов и Управления Файлами"

msgid "Once a session is open, the <command>pwd</command> command (which stands for <emphasis>print working directory</emphasis>) displays the current location in the filesystem. The current directory is changed with the <command>cd <replaceable>directory</replaceable></command> command (<command>cd</command> is for <emphasis>change directory</emphasis>). The parent directory is always called <literal>..</literal> (two dots), whereas the current directory is also known as <literal>.</literal> (one dot). The <command>ls</command> command allows <emphasis>listing</emphasis> the contents of a directory. If no parameters are given, it operates on the current directory."
msgstr "После того, как сеанс открыт, команда <command>pwd</command>  (которая служит для <emphasis>вывода рабочего каталога</emphasis>) показывает текущее местоположение в файловой системе. Текущий каталог изменяется с помощью команды <command>cd <replaceable>каталог</replaceable></command> (<command>cd</command> для того, чтобы <emphasis>изменить каталог</emphasis>). Родительский каталог всегда называют <literal>..</literal> (две точки), тогда как текущий каталог - <literal>.</literal> (одна точка). Команда <command>ls</command> выводит <emphasis>список</emphasis> содержимого каталога. Если никаких параметров не задано, она работает в текущем каталоге."

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog\n"
"$ </computeroutput><userinput>cd Desktop</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog/Desktop\n"
"$ </computeroutput><userinput>cd .</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog/Desktop\n"
"$ </computeroutput><userinput>cd ..</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog\n"
"$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates\n"
"Documents  Music      Public    Videos</computeroutput>\n"
"      "
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog\n"
"$ </computeroutput><userinput>cd Desktop</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog/Desktop\n"
"$ </computeroutput><userinput>cd .</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog/Desktop\n"
"$ </computeroutput><userinput>cd ..</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog\n"
"$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates\n"
"Documents  Music      Public    Videos</computeroutput>\n"
"      "

msgid "A new directory can be created with <command>mkdir <replaceable>directory</replaceable></command>, and an existing (empty) directory can be removed with <command>rmdir <replaceable>directory</replaceable></command>. The <command>mv</command> command allows <emphasis>moving</emphasis> and/or renaming files and directories; <emphasis>removing</emphasis> a file is achieved with <command>rm <replaceable>file</replaceable></command>."
msgstr "Новый каталог может быть создан с помощью команды <command>mkdir <replaceable>каталог</replaceable></command>, а удален существующий (пустой) каталог может быть с помощью - <command>rmdir <replaceable>каталог</replaceable></command>. Команда <command>mv</command> позволяет <emphasis>переместить</emphasis> и/или переименовать файлы и каталоги; <emphasis>удаление</emphasis> файлов достигается с помощью команды <command>rm <replaceable>файл</replaceable></command>."

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>mkdir test</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates  Videos\n"
"Documents  Music      Public    test\n"
"$ </computeroutput><userinput>mv test new</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  new       Public     Videos\n"
"Documents  Music      Pictures  Templates\n"
"$ </computeroutput><userinput>rmdir new</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates  Videos\n"
"Documents  Music      Public</computeroutput>\n"
"      "
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>mkdir test</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates  Videos\n"
"Documents  Music      Public    test\n"
"$ </computeroutput><userinput>mv test new</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  new       Public     Videos\n"
"Documents  Music      Pictures  Templates\n"
"$ </computeroutput><userinput>rmdir new</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates  Videos\n"
"Documents  Music      Public</computeroutput>\n"
"      "

msgid "Displaying and Modifying Text Files"
msgstr "Отображение и Изменение Текстовых Файлов"

msgid "The <command>cat <replaceable>file</replaceable></command> command (intended to <emphasis>concatenate</emphasis> files to the standard output device) reads a file and displays its contents on the terminal. If the file is too big to fit on a screen, use a pager such as <command>less</command> (or <command>more</command>) to display it page by page."
msgstr "Команда <command>cat <replaceable>файл</replaceable></command> (предназначенная для <emphasis>связывания</emphasis> файла со стандартным устройством вывода) считывает файл и отображает его содержимое на терминале. Если файл слишком большой чтобы поместиться на экране, используйте пейджер (полоса прокрутки) например <command>меньше</command> (или <command>больше</command>) для прокрутки содержимого файла на странице."

msgid "The <command>editor</command> command starts a text editor (such as <command>vi</command> or <command>nano</command>) and allows creating, modifying and reading text files. The simplest files can sometimes be created directly from the command interpreter thanks to redirection: <command>echo \"<replaceable>text</replaceable>\" &gt;<replaceable>file</replaceable></command> creates a file named <replaceable>file</replaceable> with “<replaceable>text</replaceable>” as its contents. Adding a line at the end of this file is possible too, with a command such as <command>echo \"<replaceable>moretext</replaceable>\" &gt;&gt;<replaceable>file</replaceable></command>. Note the <literal>&gt;&gt;</literal> in this example."
msgstr "Команда <command>editor</command> запускает текстовый редактор (например <command>vi</command> или <command>nano</command>) и позволяет создавать, редактировать и читать текстовые файлы. Простейшие файлы иногда могут быть созданы непосредственно из интерпретатора команд с помощью перенаправления: <command>echo \"<replaceable>текст</replaceable>\" &gt;<replaceable>файл</replaceable></command>. Оно создает <replaceable>файл</replaceable> с “<replaceable>текстом</replaceable>” в качестве содержимого. Добавить строку в конце файла тоже возможно, с помощью такой команды как <command>echo \"<replaceable>еще текст</replaceable>\" &gt;&gt;<replaceable>файл</replaceable></command>. Запишите  <literal>&gt;&gt;</literal> в этот пример."

msgid "Searching for Files and within Files"
msgstr "Поиск Файлов и в пределах Файла"

msgid "The <command>find <replaceable>directory</replaceable> <replaceable>criteria</replaceable></command> command looks for files in the hierarchy under <replaceable>directory</replaceable> according to several criteria. The most commonly used criterion is <literal>-name <replaceable>name</replaceable></literal>: that allows looking for a file by its name."
msgstr "Команда <command>find <replaceable>каталог</replaceable> <replaceable>критерий</replaceable></command> ищет файлы внутри каталога <replaceable>каталог</replaceable> по особым критериям. Наиболее часто используемым критерием является <literal>-name <replaceable>имя</replaceable></literal>: что позволяет найти файл по его имени."

msgid "The <command>grep <replaceable>expression</replaceable> <replaceable>files</replaceable></command> command searches the contents of the files and extracts the lines matching the regular expression (see sidebar <xref linkend=\"sidebar.regexp\" />). Adding the <literal>-r</literal> option enables a recursive search on all files contained in the directory passed as a parameter. This allows looking for a file when only a part of the contents are known."
msgstr "Команда <command>grep <replaceable>выражение</replaceable> <replaceable>файл</replaceable></command> ищет содержимое файла и извлекает строки, совпадающие с выражением (смотри боковую панель <xref linkend=\"sidebar.regexp\" />). Добавление опции <literal>-r</literal> включает рекурсивный поиск всех файлов, содержащихся в каталоге, используемом в качестве параметра. Это позволяет найти файл когда известна лишь часть содержимого."

msgid "Managing Processes"
msgstr "Управление Процессами"

msgid "The <command>ps aux</command> command lists the processes currently running and helps identifying them by showing their <emphasis>pid</emphasis> (process id). Once the <emphasis>pid</emphasis> of a process is known, the <command>kill -<replaceable>signal</replaceable> <replaceable>pid</replaceable></command> command allows sending it a signal (if the process belongs to the current user). Several signals exist; most commonly used are <literal>TERM</literal> (a request to terminate gracefully) and <literal>KILL</literal> (a forced kill)."
msgstr "Команда <command>ps aux</command> выводит список запущенных процессов и помогает идентифицировать, показывая их <emphasis>pid</emphasis> (Идентификационный номер процесса). Когда <emphasis>pid</emphasis> процесса известен, команда <command>kill -<replaceable>сигнал</replaceable> <replaceable>pid</replaceable></command> позволяет отправить ему сигнал (если процесс принадлежит текущему пользователю). Существует несколько сигналов; наиболее часто используемые - это <literal>TERM</literal> (запрос завершиться корректно) и <literal>KILL</literal> (принудительно убить)."

msgid "The command interpreter can also run programs in the background if the command is followed by a “&amp;”. By using the ampersand, the user resumes control of the shell immediately even though the command is still running (hidden from the user; as a background process). The <command>jobs</command> command lists the processes running in the background; running <command>fg %<replaceable>job-number</replaceable></command> (for <emphasis>foreground</emphasis>) restores a job to the foreground. When a command is running in the foreground (either because it was started normally, or brought back to the foreground with <command>fg</command>), the <keycombo action=\"simul\"><keycap>Control</keycap><keycap>Z</keycap></keycombo> key combination pauses the process and resumes control of the command-line. The process can then be restarted in the background with <command>bg %<replaceable>job-number</replaceable></command> (for <foreignphrase>background</foreignphrase>)."
msgstr "Командный интерпретатор может запускать программы в фоновом режиме, если за командой следует “&amp;”. Используя амперсанд, пользователь немедленно возобновляет контроль над оболочкой, хотя команда все еще выполняется (как фоновый процесс). Команда <command>jobs</command> выводит список процессов, запущенных в фоновом режим; ввод <command>fg %<replaceable>номер фонового процесса</replaceable></command> (от  <emphasis>foreground</emphasis>) возвращает процесс на передний план. Когда команда выполняется на переднем плане (была запущена обычным образом или перенесена на передний план с помощью <command>fg</command>), комбинация клавиш <keycombo action=\"simul\"><keycap>Control</keycap><keycap>Z</keycap></keycombo>приостанавливает процесс и возвращает контроль над командной строкой. Процесс может быть возобновлен в фоновом режиме с помощью <command>bg %<replaceable>номер фонового процесса</replaceable></command> (от <foreignphrase>background</foreignphrase>)."

msgid "System Information: Memory, Disk Space, Identity"
msgstr "Информация о системе: Память, Дисковое пространство, Идентификатор"

msgid "The <command>free</command> command displays information on memory; <command>df</command> (<emphasis>disk free</emphasis>) reports on the available disk space on each of the disks mounted in the filesystem. Its <literal>-h</literal> option (for <emphasis>human readable</emphasis>) converts the sizes into a more legible unit (usually mebibytes or gibibytes). In a similar fashion, the <command>free</command> command supports the <literal>-m</literal> and <literal>-g</literal> options, and displays its data either in mebibytes or in gibibytes, respectively."
msgstr "Команда <command>free</command> отображает сведения о памяти; <command>df</command> (<emphasis>disk free</emphasis>) выводит отчет о доступном дисковом пространстве на каждом из дисков, смонтированных в файловой системе. Опция <literal>-h</literal> (для <emphasis>читаемости человеком</emphasis>) преобразует размеры в более разборчивый вид (обычно в мегабайты или гигабайты).Аналогичным образом, команда <command>free</command> поддерживает опции <literal>-m</literal> и <literal>-g</literal> для отображения данных в мегабайтах или гигабайтах, соответственно."

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>free</userinput>\n"
"<computeroutput>             total       used       free     shared    buffers     cached\n"
"Mem:       1028420    1009624      18796          0      47404     391804\n"
"-/+ buffers/cache:     570416     458004\n"
"Swap:      2771172     404588    2366584\n"
"$ </computeroutput><userinput>df</userinput>\n"
"<computeroutput>Filesystem           1K-blocks      Used Available Use% Mounted on\n"
"/dev/sda2              9614084   4737916   4387796  52% /\n"
"tmpfs                   514208         0    514208   0% /lib/init/rw\n"
"udev                     10240       100     10140   1% /dev\n"
"tmpfs                   514208    269136    245072  53% /dev/shm\n"
"/dev/sda5             44552904  36315896   7784380  83% /home\n"
"</computeroutput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>free</userinput>\n"
"<computeroutput>             total       used       free     shared    buffers     cached\n"
"Mem:       1028420    1009624      18796          0      47404     391804\n"
"-/+ buffers/cache:     570416     458004\n"
"Swap:      2771172     404588    2366584\n"
"$ </computeroutput><userinput>df</userinput>\n"
"<computeroutput>Filesystem           1K-blocks      Used Available Use% Mounted on\n"
"/dev/sda2              9614084   4737916   4387796  52% /\n"
"tmpfs                   514208         0    514208   0% /lib/init/rw\n"
"udev                     10240       100     10140   1% /dev\n"
"tmpfs                   514208    269136    245072  53% /dev/shm\n"
"/dev/sda5             44552904  36315896   7784380  83% /home\n"
"</computeroutput>"

msgid "The <command>id</command> command displays the identity of the user running the session, along with the list of groups they belong to. Since access to some files or devices may be limited to group members, checking available group membership may be useful."
msgstr "Команда <command>id</command> выводит идентификатор пользователя, запустившего сессию, а также список групп, в которые он входит. Поскольку доступ к некоторым файлам или устройствам может быть ограничен для членов некоторых групп, проверка групп (в которых состоит пользователь) может быть полезной."

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>id</userinput>\n"
"<computeroutput>uid=1000(rhertzog) gid=1000(rhertzog) groups=1000(rhertzog),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(netdev),109(bluetooth),115(scanner)</computeroutput>\n"
"      "
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>id</userinput>\n"
"<computeroutput>uid=1000(rhertzog) gid=1000(rhertzog) groups=1000(rhertzog),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(netdev),109(bluetooth),115(scanner)</computeroutput>\n"
"      "

msgid "Organization of the Filesystem Hierarchy"
msgstr "Организация Иерархии Файловой системы"

msgid "<primary>Filesystem Hierarchy</primary>"
msgstr "<primary>Иерархия Файловой системы</primary>"

msgid "The Root Directory"
msgstr "Корневой каталог"

msgid "A Debian system is organized along the <emphasis>Filesystem Hierarchy Standard</emphasis> (FHS). This standard defines the purpose of each directory. For instance, the top-level directories are described as follows:"
msgstr "Система Debian организована по <emphasis>Стандарту иерархии файловой системы</emphasis> (FHS от англ. Filesystem Hierarchy Standard). Этот стандарт определяет назначение каждого каталога. Например, каталоги верхнего уровня описываются следующим образом:"

msgid "<filename>/bin/</filename>: basic programs;"
msgstr "<filename>/bin/</filename>: основные программы;"

msgid "<filename>/boot/</filename>: Linux kernel and other files required for its early boot process;"
msgstr "<filename>/boot/</filename>: ядро Linux и другие файлы, необходимые для его своевременного процесса загрузки;"

msgid "<filename>/dev/</filename>: device files;"
msgstr "<filename>/dev/</filename>: файлы устройств;"

msgid "<filename>/etc/</filename>: configuration files;"
msgstr "<filename>/etc/</filename>: конфигурационные файлы;"

msgid "<filename>/home/</filename>: user's personal files;"
msgstr "<filename>/home/</filename>: личные файлы пользователей;"

msgid "<filename>/lib/</filename>: basic libraries;"
msgstr "<filename>/lib/</filename>: основные библиотеки;"

msgid "<filename>/media/*</filename>: mount points for removable devices (CD-ROM, USB keys and so on);"
msgstr "<filename>/media/*</filename>: точки монтирования съемных устройств (CD-ROM, USB ключей и так далее);"

msgid "<filename>/mnt/</filename>: temporary mount point;"
msgstr "<filename>/mnt/</filename>: временные точки монтирования;"

msgid "<filename>/opt/</filename>: extra applications provided by third parties;"
msgstr "<filename>/opt/</filename>: дополнительные приложения, поставляемые третьими сторонами;"

msgid "<filename>/root/</filename>: administrator's (root's) personal files;"
msgstr "<filename>/root/</filename>: личные файлы администратора (root);"

msgid "<filename>/run/</filename>: volatile runtime data that does not persist across reboots (not yet included in the FHS);"
msgstr "<filename>/run/</filename>: непостоянные данные среды выполнения, которые не сохраняются после перезагрузки (еще не включены в FHS)"

msgid "<filename>/sbin/</filename>: system programs;"
msgstr "<filename>/sbin/</filename>: системные программы;"

msgid "<filename>/srv/</filename>: data used by servers hosted on this system;"
msgstr "<filename>/srv/</filename>: данные, используемые серверами, размещенными в этой системе;"

msgid "<filename>/tmp/</filename>: temporary files; this directory is often emptied at boot;"
msgstr "<filename>/tmp/</filename>: временные файлы; часто этот каталог очищается при загрузке;"

msgid "<filename>/usr/</filename>: applications; this directory is further subdivided into <filename>bin</filename>, <filename>sbin</filename>, <filename>lib</filename> (according to the same logic as in the root directory). Furthermore, <filename>/usr/share/</filename> contains architecture-independent data. <filename>/usr/local/</filename> is meant to be used by the administrator for installing applications manually without overwriting files handled by the packaging system (<command>dpkg</command>)."
msgstr "<filename>/usr/</filename>: приложения; этот каталог далее подразделяется на <filename>bin</filename>, <filename>sbin</filename>, <filename>lib</filename> (согласно той же логике,что и в корневом каталоге). Кроме того, <filename>/usr/share/</filename> содержит архитектурно независимые данные. <filename>/usr/local/</filename> предназначен для использования администратором при установке приложения вручную без перезаписи файлов, обрабатываемых системой управления пакетами (<command>dpkg</command>)."

msgid "<filename>/var/</filename>: variable data handled by daemons. This includes log files, queues, spools, caches and so on."
msgstr "<filename>/var/</filename>: переменные данные, обрабатываемые демонами. Включает в себя файлы логов, очередей, буфера, кэша и так далее."

msgid "<filename>/proc/</filename> and <filename>/sys/</filename> are specific to the Linux kernel (and not part of the FHS). They are used by the kernel for exporting data to user space (see <xref linkend=\"sect.userspace-presentation\" /> and <xref linkend=\"sect.user-space\" /> for explanations about this concept)."
msgstr "<filename>/proc/</filename> и <filename>/sys/</filename> являются специфическими для ядра Linux (и не входят в FHS). Они используются ядром для экспорта данных в пространство пользователя (смотри <xref linkend=\"sect.userspace-presentation\" /> и <xref linkend=\"sect.user-space\" /> для разъяснения этой идеи)."

msgid "The User's Home Directory"
msgstr "Домашний Каталог Пользователя"

msgid "The contents of a user's home directory is not standardized, but there are still a few noteworthy conventions. One is that a user's home directory is often referred to by a tilde (“~”). That is useful to know because command interpreters automatically replace a tilde with the correct directory (usually <filename>/home/<replaceable>user</replaceable>/</filename>)."
msgstr "Содержимое домашнего каталога пользователя не стандартизировано, однако имеет несколько заслуживающих внимания соглашений. Одно из них: домашний каталог пользователя часто называют тильдой (“~”). Это полезно знать, потому что интерпретатор команд автоматически заменяет тильду в текущей директории (обычно на <filename>/home/<replaceable>имя пользователя</replaceable>/</filename>)."

msgid "Traditionally, application configuration files are often stored directly under the user's home directory, but their names usually start with a dot (for instance, the <command>mutt</command> email client stores its configuration in <filename>~/.muttrc</filename>). Note that filenames that start with a dot are hidden by default; and <command>ls</command> only lists them when the <literal>-a</literal> option is used, and graphical file managers need to be told to display hidden files."
msgstr "Традиционно, конфигурационные файлы приложения хранятся непосредственно в домашнем каталоге пользователя,но их имена обычно начинаются с точки (например, почтовый клиент <command>mutt</command> хранит свои настройки в <filename>~/.muttrc</filename>). Обратите внимание, что имена, начинающиеся с точки, скрыты по умолчанию; и <command>ls</command> показывает их только, когда используется с опцией <literal>-a</literal>, а графическому файловому менеджеру нужно включить в настройках \"показывать скрытые файлы\"."

msgid "Some programs also use multiple configuration files organized in one directory (for instance, <filename>~/.ssh/</filename>). Some applications (such as the Iceweasel web browser) also use their directory to store a cache of downloaded data. This means that those directories can end up using a lot of disk space."
msgstr "Некоторые программы используют несколько конфигурационных файлов, расположенных в одной директории (например, <filename>~/.ssh/</filename>). Некоторые приложения (такие как веб-браузер Iceweasel) также используют их каталоги для хранения кэша загруженных данных. Таким образом, эти каталоги могут занимать много дискового пространства.."

msgid "These configuration files stored directly in a user's home directory, often collectively referred to as <emphasis>dotfiles</emphasis>, have long proliferated to the point that these directories can be quite cluttered with them. Fortunately, an effort led collectively under the FreeDesktop.org umbrella has resulted in the “XDG Base Directory Specification”, a convention that aims at cleaning up these files and directory. This specification states that configuration files should be stored under <filename>~/.config</filename>, cache files under <filename>~/.cache</filename>, and application data files under <filename>~/.local</filename> (or subdirectories thereof). This convention is slowly gaining traction, and several applications (especially graphical ones) have started following it."
msgstr "Эти конфигурационные файлы хранятся непосредственно в домашнем каталоге пользователя, часто называемые <emphasis>dotfiles</emphasis>, быстро разрастаются, что приводит к беспорядку. К счастью, коллективные усилия под эгидой FreeDesktop.org привели к созданию “XDG базовой спецификации каталогов”, соглашения, направленного на наведение порядка среди этих файлов и каталогов. Эта спецификация устанавливает, что конфигурационные файлы должны храниться в каталоге <filename>~/.config</filename>, файлы кэша в <filename>~/.cache</filename>, а данные приложений в <filename>~/.local</filename> (или в его подкаталогах). Это соглашение постепенно набирает силу, и некоторые приложения (особенно графические) начали следовать ему."

msgid "Graphical desktops usually display the contents of the <filename>~/Desktop/</filename> directory (or whatever the appropriate translation is for systems not configured in English) on the desktop (ie, what is visible on screen once all applications are closed or iconized)."
msgstr "Рабочий стол графического окружения обычно отображает содержимое каталога <filename>~/Desktop/</filename> (или каталога, названного соответственно переводу в системах, сконфигурированных на языках отличных от английского)."

msgid "Finally, the email system sometimes stores incoming emails into a <filename>~/Mail/</filename> directory."
msgstr "Наконец, система электронной почты иногда сохраняет входящие сообщения в каталоге <filename>~/Mail/</filename>."

msgid "Inner Workings of a Computer: the Different Layers Involved"
msgstr "Внутренняя Работа Компьютера: Различные Уровни Сложности"

msgid "A computer is often considered as something rather abstract, and the externally visible interface is much simpler than its internal complexity. Such complexity comes in part from the number of pieces involved. However, these pieces can be viewed in layers, where a layer only interacts with those immediately above or below."
msgstr "Компьютер обычно рассматривается как нечто весьма абстрактное, и внешний видимый интерфейс намного проще, чем его внутренняя замысловатость. Такая запутанность вызвана отчасти количеством частей, из которых она состоит. Однако, эти части можно рассматривать слоями, где каждый уровень взаимодействует только с теми, что непосредственно выше или ниже его."

msgid "An end-user can get by without knowing these details… as long as everything works. When confronting a problem such as, “The internet doesn't work!”, the first thing to do is to identify in which layer the problem originates. Is the network card (hardware) working? Is it recognized by the computer? Does the Linux kernel see it? Are the network parameters properly configured? All these questions isolate an appropriate layer and focus on a potential source of the problem."
msgstr "Конечный пользователь может не знать этих деталей… до тех пор пока все работает. При решении таких проблем как “Интернет не работает!” первое, что нужно сделать - это определить на каком уровне проблема возникает. Сетевая карта (аппаратное обеспечение) работает? Она распознается компьютером? Ядро Linux видит ее? Параметры сети настроены правильно? Все эти вопросы позволяют выделить соответствующие уровни и сосредоточиться на потенциальном источнике проблемы."

msgid "The Deepest Layer: the Hardware"
msgstr "Нижний Уровень: Аппаратное Обеспечение"

msgid "<primary>IDE</primary>"
msgstr "<primary>IDE</primary>"

msgid "<primary>SCSI</primary>"
msgstr "<primary>SCSI</primary>"

msgid "<primary>Serial ATA</primary>"
msgstr "<primary>Serial ATA</primary>"

msgid "<primary>Parallel ATA</primary>"
msgstr "<primary>Parallel ATA</primary>"

msgid "<primary>ATA</primary>"
msgstr "<primary>ATA</primary>"

msgid "<primary>IEEE 1394</primary>"
msgstr "<primary>IEEE 1394</primary>"

msgid "<primary>Firewire</primary>"
msgstr "<primary>Firewire</primary>"

msgid "<primary>USB</primary>"
msgstr "<primary>USB</primary>"

msgid "Let us start with a basic reminder that a computer is, first and foremost, a set of hardware elements. There is generally a main board (known as the <emphasis>motherboard</emphasis>), with one (or more) processor(s), some RAM, device controllers, and extension slots for option boards (for other device controllers). Most noteworthy among these controllers are IDE (Parallel ATA), SCSI and Serial ATA, for connecting to storage devices such as hard disks. Other controllers include USB, which is able to host a great variety of devices (ranging from webcams to thermometers, from keyboards to home automation systems) and IEEE 1394 (Firewire). These controllers often allow connecting several devices so the complete subsystem handled by a controller is therefore usually known as a “bus”. Option boards include graphics cards (into which monitor screens will be plugged), sound cards, network interface cards, and so on. Some main boards are pre-built with these features, and don't need option boards."
msgstr "Давайте начнем с базового напоминания о том, что компьютер - это, прежде всего, набор аппаратных элементов. Обычно это основная плата (известная как <emphasis>материнская плата</emphasis>), с одним (или больше) процессором, некоторым ОЗУ, контроллерами устройств, и слотами расширения для дополнительных плат (для остальных контроллеров устройств). Наиболее примечательные из этих контроллеров: IDE (Parallel ATA), SCSI и Serial ATA, для подключения к устройствам хранения данных, таких как жёсткие диски. \"Другие контроллеры\" в себя включают USB, который способен подключить огромное количество разнообразных устройств (начиная от веб-камеры до термометров, от клавиатуры до системы домашней автоматизации) и IEEE 1394 (Firewire). Эти контроллеры часто позволяют подключить несколько устройств, так контроллер обрабатывает их как целую подсистему (из-за этого его обычно называют \"шиной\"). \"Дополнительные платы\" включают в себя видео карты (к ним подключается монитор), аудио карты, сетевые карты и так далее. В некоторых основных платах эти функции встроены, и нет нужды в дополнительных платах."

msgid "<emphasis>IN PRACTICE</emphasis> Checking that the hardware works"
msgstr "<emphasis>НА ПРАКТИКЕ</emphasis> Проверка работоспособности оборудования"

msgid "Checking that a piece of hardware works can be tricky. On the other hand, proving that it doesn't work is sometimes quite simple."
msgstr "Проверить работает ли какое-то оборудование может быть весьма сложно. С другой стороны, доказать, что оно не работает, иногда довольно легко."

msgid "A hard disk drive is made of spinning platters and moving magnetic heads. When a hard disk is powered up, the platter motor makes a characteristic whir. It also dissipates energy as heat. Consequently, a hard disk drive that stays cold and silent when powered up is broken."
msgstr "Жёсткий диск состоит из шпинделя с пластинками и движущихся магнитных головок. Когда жёсткий диск включается, мотор пластинок издает характерное жужжание. Он также рассеивает энергию в виде тепла. Следовательно, жёсткий диск, остающийся холодным и тихим, когда на него подается питание, сломан."

msgid "Network cards often include LEDs displaying the state of the link. If a cable is plugged in and leads to a working network hub or switch, at least one LED will be on. If no LED lights up, either the card itself, the network device, or the cable between them, is faulty. The next step is therefore testing each component individually."
msgstr "Сетевые карты обычно оснащены светодиодами, показывающими состояние соединения. Если кабель одним концом подключен к сетевой карте (а другим к концентратору или коммутатору), по крайней мере один светодиод будет гореть. Если ни один светодиод не светится, сама сетевая карта, сетевое оборудование или кабель между ними неисправны. Следовательно, следующий шаг - тестировать каждый компонент отдельно."

msgid "Some option boards — especially 3D video cards — include cooling devices, such as heat sinks and/or fans. If the fan does not spin even though the card is powered up, a plausible explanation is the card overheated. This also applies to the main processor(s) located on the main board."
msgstr "Некоторые дополнительные платы — особенно 3D видео карты — имеют системы охлаждения, такие как радиаторы и/или вентиляторы. Если вентилятор не вращается, несмотря на то, что карта включена, правдоподобное объяснение - перегрев карты. Это также относится к центральному процессору (процессорам), расположенным на основной карте."

msgid "The Starter: the BIOS or UEFI"
msgstr "Загрузчик: BIOS или UEFI"

msgid "<primary>BIOS</primary>"
msgstr "<primary>BIOS</primary>"

msgid "<primary>UEFI</primary>"
msgstr "<primary>UEFI</primary>"

msgid "<primary>Master Boot Record (MBR)</primary>"
msgstr "<primary>Master Boot Record (MBR)</primary>"

msgid "Hardware, on its own, is unable to perform useful tasks without a corresponding piece of software driving it. Controlling and interacting with the hardware is the purpose of the operating system and applications. These, in turn, require functional hardware to run."
msgstr "Оборудование, само по себе, не в состоянии выполнять задачи без соответствующей программной части, управляющей им. Управление и взаимодействие с оборудованием - задача операционной системы и приложений. Они, в свою очередь, требует   функционального оборудования для запуска."

msgid "This symbiosis between hardware and software does not happen on its own. When the computer is first powered up, some initial setup is required. This role is assumed by the BIOS or UEFI, a piece of software embedded into the main board that runs automatically upon power-up. Its primary task is searching for software it can hand over control to. Usually, in the BIOS case, this involves looking for the first hard disk with a boot sector (also known as the <emphasis>master boot record</emphasis> or <acronym>MBR</acronym>), loading that boot sector, and running it. From then on, the BIOS is usually not involved (until the next boot). In the case of UEFI, the process involves scanning disks to find a dedicated EFI partition containing further EFI applications to execute."
msgstr "Этот симбиоз между аппаратным обеспечением и программным обеспечением не возникает сам собой. Когда компьютер включается, требуется небольшая начальная настройка. Эту роль берёт на себя BIOS или UEFI (части программного обеспечения, встроенные в материнскую плату), запускающийся автоматически при включении питания. Его основная задача - поиск программного обеспечения, которому он может передать управление. Обычно, в случае с BIOS, это включает поиск первого жёсткого диска с загрузочным сектором (обычно известного как <emphasis>master boot record</emphasis> или <acronym>MBR</acronym>), загрузку этого загрузочного сектора, и его запуск. С этого момента, BIOS обычно не используется (до следующей загрузки). В случае с UEFI, процесс включает сканирование дисков с целью найти выделенные разделы EFI, содержащие дальнейшие для выполнения EFI приложения."

msgid "<emphasis>TOOL</emphasis> Setup, the BIOS/UEFI configuration tool"
msgstr "<emphasis>ИНСТРУМЕНТ</emphasis> Настройки, средства конфигурирования BIOS/UEFI"

msgid "<primary><emphasis>Setup</emphasis></primary>"
msgstr "<primary><emphasis>Настройки</emphasis></primary>"

msgid "The BIOS/UEFI also contains a piece of software called Setup, designed to allow configuring aspects of the computer. In particular, it allows choosing which boot device is preferred (for instance, the floppy disk or CD-ROM drive), setting the system clock, and so on. Starting Setup usually involves pressing a key very soon after the computer is powered on. This key is often <keycap>Del</keycap> or <keycap>Esc</keycap>, sometimes <keycap>F2</keycap> or <keycap>F10</keycap>. Most of the time, the choice is flashed on screen while booting."
msgstr "BIOS/UEFI также содержит часть программного обеспечения под названием \"Настройки\", позволяющую конфигурировать аспекты компьютера. В частности, она позволяет выбрать устройства, предпочтительные для загрузки (например, floppy-диск или CD-ROM), настроить системные часы и так далее. Запуск программы \"Настройки\" обычно осуществляется нажатием специальной клавиши сразу же после включения компьютера. Обычно, это клавиша <keycap>Del</keycap> или <keycap>Esc</keycap>, иногда это <keycap>F2</keycap> или <keycap>F10</keycap>. Большую часть времени выбор мигает на экране во время загрузки."

msgid "The boot sector (or the EFI partition), in turn, contains another piece of software, called the bootloader, whose purpose is to find and run an operating system. Since this bootloader is not embedded in the main board but loaded from disk, it can be smarter than the BIOS, which explains why the BIOS does not load the operating system by itself. For instance, the bootloader (often GRUB on Linux systems) can list the available operating systems and ask the user to choose one. Usually, a time-out and default choice is provided. Sometimes the user can also choose to add parameters to pass to the kernel, and so on. Eventually, a kernel is found, loaded into memory, and executed."
msgstr "Загрузочный сектор (или раздел EFI), в свою очередь, содержит другие части программного обеспечения, называемые загрузчиками, цель которых - найти и запустить операционную систему. Так как эти загрузчики не встроены в основную плату, а загружаются с диска, они могут быть умнее чем BIOS (это объясняет почему BIOS не загружает операционную систему самостоятельно). Например, загрузчик (обычно GRUB для Linux систем) может вывести список доступных операционных систем и попросить пользователя выбрать. Обычно, по истечению времени производится выбор по-умолчанию. Иногда пользователь может также выбрать параметры для запуска ядра, и так далее. В конце концов ядро найдено, загружено в память, и запущено."

msgid "<emphasis>NOTE</emphasis> UEFI, a modern replacement to the BIOS"
msgstr "<emphasis>ЗАМЕТКА</emphasis> UEFI - современная замена BIOS"

msgid "<primary>Secure Boot</primary>"
msgstr "<primary>Безопасная загрузка</primary>"

msgid "UEFI is a relatively recent development. Most new computers will support UEFI booting, but usually they also support BIOS booting alongside for backwards compatibility with operating systems that are not ready to exploit UEFI."
msgstr "UEFI - относительно современная разработка. Большинство новых компьютеров поддерживают загрузку UEFI, но обычно они также поддерживают загрузку BIOS для обратной совместимости с операционными системами, не готовыми использовать UEFI."

msgid "This new system gets rid of some of the limitations of BIOS booting: with the usage of a dedicated partition, the bootloaders no longer need special tricks to fit in a tiny <emphasis>master boot record</emphasis> and then discover the kernel to boot. Even better, with a suitably built Linux kernel, UEFI can directly boot the kernel without any intermediary bootloader. UEFI is also the basic foundation used to deliver <emphasis>Secure Boot</emphasis>, a technology ensuring that you run only software validated by your operating system vendor."
msgstr "Эта новая система свободна от некоторых ограничений загрузчика BIOS: с использованием выделенных разделов, загрузчикам больше не нужны специальные трюки, чтобы поместиться в крошечную <emphasis>главную загрузочную запись (MBR)</emphasis>, а затем искать ядро для загрузки. Даже лучше, с соответствующей сборкой ядра Linux UEFI может загрузить непосредственно ядро без каких-либо промежуточных загрузчиков. UEFI  также является основой для произведения <emphasis>Безопасной загрузки (Secure Boot)</emphasis> (технологии, обеспечивающей выполнение только программного обеспечения, подтвержденного производителем Вашей операционной системы)."

msgid "The BIOS/UEFI is also in charge of detecting and initializing a number of devices. Obviously, this includes the IDE/SATA devices (usually hard disk(s) and CD/DVD-ROM drives), but also PCI devices. Detected devices are often listed on screen during the boot process. If this list goes by too fast, use the <keycap>Pause</keycap> key to freeze it for long enough to read. Installed PCI devices that don't appear are a bad omen. At worst, the device is faulty. At best, it is merely incompatible with the current version of the BIOS or main board. PCI specifications evolve, and old main boards are not guaranteed to handle newer PCI devices."
msgstr "BIOS/UEFI  также отвечает за обнаружение и инициализацию ряда устройств. Очевидно, это IDE/SATA устройства (обычно это жесткие диски и CD/DVD-ROM приводы), а также еще и PCI устройства. Обнаруженные устройства часто перечислены на экране во время процесса загрузки. Если этот список выводится слишком быстро, используйте клавишу <keycap>Pause</keycap> для его остановки на время, достаточное для прочтения. Не появившиеся установленные PCI устройства являются плохим знаком. В худшем случае, прибор неисправен. В лучшем - он просто не совместим с текущей версией BIOS или материнской платой. Спецификация PCI  развивается, и старые основные платы не гарантируют поддержку более новых PCI устройств."

msgid "The Kernel"
msgstr "Ядро"

msgid "Both the BIOS/UEFI and the bootloader only run for a few seconds each; now we are getting to the first piece of software that runs for a longer time, the operating system kernel. This kernel assumes the role of a conductor in an orchestra, and ensures coordination between hardware and software. This role involves several tasks including: driving hardware, managing processes, users and permissions, the filesystem, and so on. The kernel provides a common base to all other programs on the system."
msgstr "BIOS/UEFI с загрузчиком работают всего по несколько секунд. Далее идет первая часть программного обеспечения, работающая длительное время - ядро операционной системы. Ядро берет на себя роль дирижера в оркестре и обеспечивает координацию между аппаратным обеспечением и программным обеспечением. Эта роль включает в себя несколько задач: управление оборудованием, процессами, пользователями и разрешениями, файловой системой и так далее. Ядро предоставляет общую базу для всех остальных программ в системе."

msgid "The User Space"
msgstr "Пространство пользователя"

msgid "Although everything that happens outside of the kernel can be lumped together under “user space”, we can still separate it into software layers. However, their interactions are more complex than before, and the classifications may not be as simple. An application commonly uses libraries, which in turn involve the kernel, but the communications can also involve other programs, or even many libraries calling each other."
msgstr "Хотя все что происходит за пределами ядра можно собрать в кучу \"пространство пользователя\", мы по-прежнему можем разделить это программное обеспечение на уровни. Однако, их взаимодействие намного сложнее прежних, и классифицировать их не так просто. Приложения обычно используют библиотеки, которые в свою очередь окутывают ядро, но взаимодействие может также происходить с другими программами, или множеством библиотек, вызывающих друг друга."

msgid "Some Tasks Handled by the Kernel"
msgstr "Некоторые Выполняемые Ядром Задачи"

msgid "Driving the Hardware"
msgstr "Управление Оборудованием"

msgid "The kernel is, first and foremost, tasked with controlling the hardware parts, detecting them, switching them on when the computer is powered on, and so on. It also makes them available to higher-level software with a simplified programming interface, so applications can take advantage of devices without having to worry about details such as which extension slot the option board is plugged into. The programming interface also provides an abstraction layer; this allows video-conferencing software, for example, to use a webcam independently of its make and model. The software can just use the <emphasis>Video for Linux</emphasis> (V4L) interface, and the kernel translates the function calls of this interface into the actual hardware commands needed by the specific webcam in use."
msgstr "Ядро, прежде всего, предназначено для контролирования оборудования, его обнаружения, его включения когда компьютер запускается и так далее. Это также делает оборудование доступным для программного обеспечения более высокого уровня с упрощенным интерфейсом программирования,  так что последнее может воспользоваться преимуществами устройств, не беспокоясь о деталях, таких как: в какой слот расширения вставлена дополнительная плата. Программный интерфейс также предоставляет уровень абстракции; это позволяет, например, программе для видео-конференции использовать веб-камеру независимо от ее производителя и модели. Программа может просто использовать интерфейс <emphasis>Video for Linux</emphasis> (V4L), а ядро транслирует функциональные вызовы этого интерфейса в фактические машинные команды, необходимые для использования веб-камеры."

msgid "<indexterm><primary><command>lspci</command></primary></indexterm> <indexterm><primary><command>lsusb</command></primary></indexterm> <indexterm><primary><command>lsdev</command></primary></indexterm> <indexterm><primary><command>lspcmcia</command></primary></indexterm> The kernel exports many details about detected hardware through the <filename>/proc/</filename> and <filename>/sys/</filename> virtual filesystems. Several tools summarize those details. Among them, <command>lspci</command> (in the <emphasis role=\"pkg\">pciutils</emphasis> package) lists PCI devices, <command>lsusb</command> (in the <emphasis role=\"pkg\">usbutils</emphasis> package) lists USB devices, and <command>lspcmcia</command> (in the <emphasis role=\"pkg\">pcmciautils</emphasis> package) lists PCMCIA cards. These tools are very useful for identifying the exact model of a device. This identification also allows more precise searches on the web, which in turn, lead to more relevant documents."
msgstr "<indexterm><primary><command>lspci</command></primary></indexterm> <indexterm><primary><command>lsusb</command></primary></indexterm> <indexterm><primary><command>lsdev</command></primary></indexterm> <indexterm><primary><command>lspcmcia</command></primary></indexterm> Ядро экспортирует информацию об обнаруженном аппаратном обеспечении в виртуальные файловые системы <filename>/proc/</filename> и <filename>/sys/</filename>. Некоторые инструменты суммируют эту информацию. Среди них, <command>lspci</command> (из пакета <emphasis role=\"pkg\">pciutils</emphasis>) выводит список PCI устройств, <command>lsusb</command> (из пакета <emphasis role=\"pkg\">usbutils</emphasis>) выводит список USB устройств, а <command>lspcmcia</command> (из пакета <emphasis role=\"pkg\">pcmciautils</emphasis>) выводит список PCMCIA плат. Эти инструменты очень полезны для определения точной модели какого-либо устройства. Эта идентификация также позволяет находить в интернете более точную информацию, которая в свою очередь, приводит к актуальной документации."

msgid "Example of information provided by <command>lspci</command> and <command>lsusb</command>"
msgstr "Пример информации, предоставляемой <command>lspci</command> и <command>lsusb</command>"

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>lspci</userinput>\n"
"<computeroutput>[...]\n"
"00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)\n"
"00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)\n"
"00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)\n"
"[...]\n"
"01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)\n"
"02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)\n"
"$ </computeroutput><userinput>lsusb</userinput>\n"
"<computeroutput>Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.\n"
"Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.\n"
"Bus 005 Device 007: ID 045e:00dd Microsoft Corp.\n"
"Bus 005 Device 006: ID 046d:c03d Logitech, Inc.\n"
"[...]\n"
"Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth\n"
"</computeroutput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>lspci</userinput>\n"
"<computeroutput>[...]\n"
"00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)\n"
"00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)\n"
"00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)\n"
"[...]\n"
"01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)\n"
"02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)\n"
"$ </computeroutput><userinput>lsusb</userinput>\n"
"<computeroutput>Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.\n"
"Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.\n"
"Bus 005 Device 007: ID 045e:00dd Microsoft Corp.\n"
"Bus 005 Device 006: ID 046d:c03d Logitech, Inc.\n"
"[...]\n"
"Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth\n"
"</computeroutput>"

msgid "These programs have a <literal>-v</literal> option, that lists much more detailed (but usually not necessary) information. Finally, the <command>lsdev</command> command (in the <emphasis role=\"pkg\">procinfo</emphasis> package) lists communication resources used by devices."
msgstr "Эти программы имеют опцию <literal>-v</literal>, с которой выводятся списки с более подробной (но зачастую ненужной) информацией. Наконец, команда <command>lsdev</command> (из пакета <emphasis role=\"pkg\">procinfo</emphasis>) выводит список коммуникационных ресурсов, используемых устройствами."

msgid "Applications often access devices by way of special files created within <filename>/dev/</filename> (see sidebar <xref linkend=\"sidebar.special-files\" />). These are special files that represent disk drives (for instance, <filename>/dev/hda</filename> and <filename>/dev/sdc</filename>), partitions (<filename>/dev/hda1</filename> or <filename>/dev/sdc3</filename>), mice (<filename>/dev/input/mouse0</filename>), keyboards (<filename>/dev/input/event0</filename>), soundcards (<filename>/dev/snd/*</filename>), serial ports (<filename>/dev/ttyS*</filename>), and so on."
msgstr "Приложения часто получают доступ к устройствам через специальные файлы, созданные в <filename>/dev/</filename> (см. на боковой панели <xref linkend=\"sidebar.special-files\" />). Это специальные файлы, представляющие дисковые устройства (например, <filename>/dev/hda</filename> и <filename>/dev/sdc</filename>), разделы (<filename>/dev/hda1</filename> или <filename>/dev/sdc3</filename>), мыши (<filename>/dev/input/mouse0</filename>), клавиатуры (<filename>/dev/input/event0</filename>), звуковые карты (<filename>/dev/snd/*</filename>), серийные порты (<filename>/dev/ttyS*</filename>) и так далее."

msgid "Filesystems"
msgstr "Файловые системы"

msgid "<primary>filesystem</primary>"
msgstr "<primary>файловая система</primary>"

msgid "<primary>system, filesystem</primary>"
msgstr "<primary>система, файловая система</primary>"

msgid "Filesystems are one of the most prominent aspects of the kernel. Unix systems merge all the file stores into a single hierarchy, which allows users (and applications) to access data simply by knowing its location within that hierarchy."
msgstr "Файловые системы - один из наиболее выдающихся аспектов ядра. Unix системы соединяют все хранилища файлов в одну  единственную иерархическую систему, которая позволяет пользователям (и приложениям) получать доступ к данным просто, зная их местоположение в этой иерархии."

msgid "The starting point of this hierarchical tree is called the root, <filename>/</filename>. This directory can contain named subdirectories. For instance, the <literal>home</literal> subdirectory of <filename>/</filename> is called <filename>/home/</filename>. This subdirectory can, in turn, contain other subdirectories, and so on. Each directory can also contain files, where the actual data will be stored. Thus, the <filename>/home/rmas/Desktop/hello.txt</filename> name refers to a file named <literal>hello.txt</literal> stored in the <literal>Desktop</literal> subdirectory of the <literal>rmas</literal> subdirectory of the <literal>home</literal> directory present in the root. The kernel translates between this naming system and the actual, physical storage on a disk."
msgstr "Начальная точка этого иерархического дерева называется корнем, <filename>/</filename>. Этот каталог может содержать именованные подкаталоги. Например, подкаталог <literal>home</literal> каталога <filename>/</filename> называется <filename>/home/</filename>. Эти подкаталоги могут, в свою очередь, содержать другие подкаталоги и так далее. Каждый каталог также может содержать файлы, в которых  фактически и хранятся данные. Таким образом, имя <filename>/home/rmas/Desktop/hello.txt</filename> ссылается на файл с именем <literal>hello.txt</literal>, хранящийся в подкаталоге <literal>Desktop</literal> подкаталога <literal>rmas</literal> подкаталога <literal>home</literal> корневого каталога. Ядро занимается преобразованием между этой системой именования и фактической, физической памятью на диске."

msgid "Unlike other systems, there is only one such hierarchy, and it can integrate data from several disks. One of these disks is used as the root, and the others are “mounted” on directories in the hierarchy (the Unix command is called <command>mount</command>); these other disks are then available under these “mount points”. This allows storing users' home directories (traditionally stored within <filename>/home/</filename>) on a second hard disk, which will contain the <literal>rhertzog</literal> and <literal>rmas</literal> directories. Once the disk is mounted on <filename>/home/</filename>, these directories become accessible at their usual locations, and paths such as <filename>/home/rmas/Desktop/hello.txt</filename> keep working."
msgstr "В отличии от других систем, есть только одна такая иерархия, и она может содержать данные с разных дисков. Один из этих дисков используется в качестве корня, а остальные - монтируются как каталоги в этой иерархии (в Unix команда называется <command>mount</command>); после чего, эти диски становятся доступны в этих \"точках монтирования\". Это позволяет хранить домашние каталоги пользователей (традиционно хранятся в <filename>/home/</filename>) на втором жёстком диске, который будет содержать каталоги <literal>rhertzog</literal> и <literal>rmas</literal>. После того как диск монтируется в <filename>/home/</filename>, эти каталоги становятся доступны в их обычных местах, и будут работать пути, такие как <filename>/home/rmas/Desktop/hello.txt</filename>."

msgid "<primary><command>mkfs</command></primary>"
msgstr "<primary><command>mkfs</command></primary>"

msgid "There are many filesystem formats, corresponding to many ways of physically storing data on disks. The most widely known are <emphasis>ext2</emphasis>, <emphasis>ext3</emphasis> and <emphasis>ext4</emphasis>, but others exist. For instance, <emphasis>vfat</emphasis> is the system that was historically used by DOS and Windows operating systems, which allows using hard disks under Debian as well as under Windows. In any case, a filesystem must be prepared on a disk before it can be mounted and this operation is known as “formatting”. Commands such as <command>mkfs.ext3</command> (where <command>mkfs</command> stands for <emphasis>MaKe FileSystem</emphasis>) handle formatting. These commands require, as a parameter, a device file representing the partition to be formatted (for instance, <filename>/dev/sda1</filename>). This operation is destructive and should only be run once, except if one deliberately wishes to wipe a filesystem and start afresh."
msgstr "Существует множество форматов файловых систем, соответствующих множеству способов физического хранения данных на диске. Наиболее широко известны: <emphasis>ext2</emphasis>, <emphasis>ext3</emphasis> и <emphasis>ext4</emphasis>, но есть и другие. Например, <emphasis>vfat</emphasis> исторически используется в операционных системах DOS и Windows, и позволяет использовать жёсткие диски как в Debian так и в Windows. В любом случае, файловая система должна быть подготовлена на диске перед тем, как он будет монтироваться (эта операция известна как “форматирование”). Команды, такие как <command>mkfs.ext3</command> (где <command>mkfs</command> от <emphasis>MaKe FileSystem</emphasis>) производят форматирование. Эти команды нуждаются, в качестве параметра, в представляющем раздел для форматирования файле устройства (например, <filename>/dev/sda1</filename>). Эта операция является разрушительной и должна выполняться только один раз, за исключением тех случаев, если нужно будет уничтожить файловую систему и начать все заново."

msgid "There are also network filesystems, such as <acronym>NFS</acronym>, where data is not stored on a local disk. Instead, data is transmitted through the network to a server that stores and retrieves them on demand. The filesystem abstraction shields users from having to care: files remain accessible in their usual hierarchical way."
msgstr "Также есть и сетевые файловые системы такие как <acronym>NFS</acronym>, в которых данные на хранятся на локальном диске. Вместо этого, данные передаются через сеть на сервер, который хранит и извлекает их по требованию. Абстракция файловой системы защищает пользователей от необходимости беспокоится о том, чтобы файлы оставались по их обычному иерархическому пути."

msgid "Shared Functions"
msgstr "Общие Функции"

msgid "Since a number of the same functions are used by all software, it makes sense to centralize them in the kernel. For instance, shared filesystem handling allows any application to simply open a file by name, without needing to worry where the file is stored physically. The file can be stored in several different slices on a hard disk, or split across several hard disks, or even stored on a remote file server. Shared communication functions are used by applications to exchange data independently of the way the data is transported. For instance, transport could be over any combination of local or wireless networks, or over a telephone landline."
msgstr "Поскольку некоторые функции используются всем программным обеспечением, имеет смысл их централизация в ядре. Например, общая файловая система позволяет любому приложению просто открыть файл по его имени, не заботясь о том, где физически находится файл. Файл может храниться, разделенным на множество частей, на одном или нескольких жёстких дисках или на уделенном сервере. Общие функции взаимодействия используются приложениями для обмена данными, независимо от способа их передачи. К примеру, пусть может проходить через комбинацию локальных или беспроводных сетей, или по телефонной линии."

msgid "<primary><emphasis>pid</emphasis></primary>"
msgstr "<primary><emphasis>pid</emphasis></primary>"

msgid "A process is a running instance of a program. This requires memory to store both the program itself and its operating data. The kernel is in charge of creating and tracking them. When a program runs, the kernel first sets aside some memory, then loads the executable code from the filesystem into it, and then starts the code running. It keeps information about this process, the most visible of which is an identification number known as <emphasis>pid</emphasis> (<emphasis>process identifier</emphasis>)."
msgstr "Процесс - запущенный экземпляр программы. Он требует памяти для хранения как самой программы, так и ее оперативных данных. Ядро отвечает за их создание и отслеживание. Когда программа запускается, ядро выделяет некоторый объем памяти, потом загружает исполняемый код из файловой системы в эту память, а затем начинает исполнение этого кода. Оно хранит сведения об этом процессе, наиболее просматриваемое из которых - идентификационный номер, известный как <emphasis>pid</emphasis> (от англ. <emphasis>process identifier</emphasis>)."

msgid "Unix-like kernels (including Linux), like most other modern operating systems, are capable of “multi-tasking”. In other words, they allow running many processes “at the same time”. There is actually only one running process at any one time, but the kernel cuts time into small slices and runs each process in turn. Since these time slices are very short (in the millisecond range), they create the illusion of processes running in parallel, although they are actually only active during some time intervals and idle the rest of the time. The kernel's job is to adjust its scheduling mechanisms to keep that illusion, while maximizing the global system performance. If the time slices are too long, the application may not appear as responsive as desired. Too short, and the system loses time switching tasks too frequently. These decisions can be tweaked with process priorities. High-priority processes will run for longer and with more frequent time slices than low-priority processes."
msgstr "Unix-подобные ядра (включая Linux), как и большинство других современных операционных систем, поддерживают “многозадачность”. Другими словами, они позволяют запускать много процессов \"одновременно\". Хотя на самом деле только один процесс выполняется в одну единицу времени, но ядро делит время на маленькие промежутки и исполняет каждый процесс пошагово. Так как эти временные интервалы очень короткие (в диапазоне миллисекунды), создается иллюзия параллельного выполнения процессов, хотя на самом деле они активны только в течение нескольких временных промежутков и простаивают остальную часть времени. Работа ядра заключается в регулировании его механизма планирования для поддержания этой иллюзии, увеличивая производительность системы в целом. Если временные интервалы слишком большие, приложение может показаться не таким отзывчивым как хотелось бы. Если слишком короткие, то система будет терять много времени на переключение между задачами. Эти решения могут изменяться с приоритетами процессов. Процессы с высоким приоритетом будут работать дольше и с большей частотой временных промежутков нежели процессы с низким приоритетом."

msgid "<emphasis>NOTE</emphasis> Multi-processor systems (and variants)"
msgstr "<emphasis>НА ЗАМЕТКУ</emphasis> Многопроцессорные системы (и их разновидности)"

msgid "The limitation described above of only one process being able to run at a time, doesn't always apply. The actual restriction is that there can only be one running process <emphasis>per processor core</emphasis> at a time. Multi-processor, multi-core or “hyper-threaded” systems allow several processes to run in parallel. The same time-slicing system is still used, though, so as to handle cases where there are more active processes than available processor cores. This is far from unusual: a basic system, even a mostly idle one, almost always has tens of running processes."
msgstr "Описанное выше ограничение одним процессом, запущенным в единицу времени, не всегда выполняется. На самом деле идет ограничение одним запущенным процессом <emphasis>на ядро процессора</emphasis> в единицу времени. Многопроцессорные, многоядерные или “гиперпоточные” системы позволяют запускать параллельно несколько процессов. В них также используется та же система временных интервалов, однако, она используется таким образом, чтобы обрабатывать случаи, когда активных процессов больше, чем доступных процессорных ядер. Это совсем не удивительно: базовые системы, по большей части простаивающие, почти всегда имеют десятки запущенных процессов."

msgid "Of course, the kernel allows running several independent instances of the same program. But each can only access its own time slices and memory. Their data thus remain independent."
msgstr "Конечно, ядро позволяет запускать несколько независимых экземпляров одной и той же программы. Но каждый из них имеет доступ только к собственным временным интервалам и памяти. Их данные, таким образом, остаются независимыми."

msgid "Rights Management"
msgstr "Управление Правами"

msgid "Unix-like systems are also multi-user. They provide a rights management system that supports separate users and groups; it also allows control over actions based on permissions. The kernel manages data for each process, allowing it to control permissions. Most of the time, a process is identified by the user who started it. That process is only permitted to take those actions available to its owner. For instance, trying to open a file requires the kernel to check the process identity against access permissions (for more details on this particular example, see <xref linkend=\"sect.rights-management\" />)."
msgstr "Также Unix-подобные системы являются многопользовательскими. Они предоставляют систему управления правами, которая поддерживает создание отдельных пользователей и групп; она также позволяет контролировать действия на основе разрешений. Ядро управляет данными для каждого процесса, что позволяет контролировать разрешения. Большую часть времени процесс идентифицируется пользователем, запустившем его. Этот процесс имеет право на действия, доступные его владельцу. Например, попытка открыть файл, требует от ядра проверить идентификатор процесса для предоставления доступа (для более подробной информации по данному примеру, см. <xref linkend=\"sect.rights-management\" />)."

msgid "<primary>user space</primary>"
msgstr "<primary>пространство пользователя</primary>"

msgid "<primary>kernel space</primary>"
msgstr "<primary>пространство ядра</primary>"

msgid "“User space” refers to the runtime environment of normal (as opposed to kernel) processes. This does not necessarily mean these processes are actually started by users because a standard system normally has several “daemon” (or background) processes running before the user even opens a session. Daemon processes are also considered user-space processes."
msgstr "“Пространство пользователя” относится к среде выполнения нормальных (в отличии от ядра) процессов. Это не обязательно означает, что процессы были запущены пользователем, потому что стандартная система обычно имеет несколько “демонов” (фоновых процессов), запускающихся до того как пользователь даже откроет сеанс. Демоны - также считаются процессами пользовательского пространства."

msgid "<primary><command>init</command></primary>"
msgstr "<primary><command>init</command></primary>"

msgid "When the kernel gets past its initialization phase, it starts the very first process, <command>init</command>. Process #1 alone is very rarely useful by itself, and Unix-like systems run with many additional processes."
msgstr "Когда ядро находится на последней фазе его инициализации, оно запускает первый процесс - <command>init</command>. Процесс #1 очень редко полезен сам по себе, и Unix-подобные системы работают с множеством дополнительных процессов."

msgid "<primary><emphasis>fork</emphasis></primary>"
msgstr "<primary><emphasis>fork</emphasis></primary>"

msgid "First of all, a process can clone itself (this is known as a <emphasis>fork</emphasis>). The kernel allocates a new (but identical) process memory space, and another process to use it. At this time, the only difference between these two processes is their <emphasis>pid</emphasis>. The new process is usually called a child process, and the original process whose <emphasis>pid</emphasis> doesn't change, is called the parent process."
msgstr "Прежде всего, процесс может клонировать себя (это действие называется <emphasis>fork</emphasis>). Ядро выделяет пространство в памяти (точно такое же как и для исходного процесса), и новый процесс его занимает. Единственная разница между этими двумя процессами - их <emphasis>pid</emphasis>. Новый процесс обычно зовется дочерним процессом, а оригинальный (<emphasis>pid</emphasis> которого не изменился) - родительским процессом."

msgid "Sometimes, the child process continues to lead its own life independently from its parent, with its own data copied from the parent process. In many cases, though, this child process executes another program. With a few exceptions, its memory is simply replaced by that of the new program, and execution of this new program begins. This is the mechanism used by the init process (with process number 1) to start additional services and execute the whole startup sequence. At some point, one process among <command>init</command>'s offspring starts a graphical interface for users to log in to (the actual sequence of events is described in more details in <xref linkend=\"sect.system-boot\" />)."
msgstr "Иногда, дочерний процесс продолжает жить своей собственной жизнью независимо от родителя, со своими собственными данными, скопированными у родительского процесса. Во многих случаях, однако, этот дочерний процесс выполняется другой программой. За некоторыми исключениями, его память просто замещается новой программой, и начинается выполнение новой программы. Это механизм, используемый init процессом (с процессом #1) для запуска дополнительных сервисов и выполнения последовательности всей загрузки. В определенный момент один процесс из потомства <command>init</command> запускает графический интерфейс для пользователей и входа в систему (подробно эта последовательность событий описана в <xref linkend=\"sect.system-boot\" />)."

msgid "When a process finishes the task for which it was started, it terminates. The kernel then recovers the memory assigned to this process, and stops giving it slices of running time. The parent process is told about its child process being terminated, which allows a process to wait for the completion of a task it delegated to a child process. This behavior is plainly visible in command-line interpreters (known as <emphasis>shells</emphasis>). When a command is typed into a shell, the prompt only comes back when the execution of the command is over. Most shells allow for running the command in the background, it is a simple matter of adding an <userinput>&amp;</userinput> to the end of the command. The prompt is displayed again right away, which can lead to problems if the command needs to display data of its own."
msgstr "Когда процесс выполняет задачу для которой он был запущен, он завершается. Затем ядро высвобождает память, выделенную для этого процесса и перестает предоставлять ему интервалы времени выполнения. Родительский процесс оповещается о том, что его дочерний процесс был завершен, что позволяет процессу ожидать выполнения задач, поставленных дочернему процессу. Это поведение ясно видно в интерпретаторе командной строки (известной как <emphasis>shells</emphasis>). При вводе команды в командной строке, запрос возвращается только после завершения выполнения этой команды. Большинство оболочек позволяют выполнять команды в фоновом режиме (на заднем плане), для этого надо просто добавить <userinput>&amp;</userinput> в конец команды. Запрос тут же выводится снова, что может вызвать проблемы если команде нужно выводить ее собственные данные."

msgid "Daemons"
msgstr "Демоны"

msgid "<primary>daemon</primary>"
msgstr "<primary>демон</primary>"

msgid "A “daemon” is a process started automatically by the boot sequence. It keeps running (in the background) to perform maintenance tasks or provide services to other processes. This “background task” is actually arbitrary, and does not match anything particular from the system's point of view. They are simply processes, quite similar to other processes, which run in turn when their time slice comes. The distinction is only in the human language: a process that runs with no interaction with a user (in particular, without any graphical interface) is said to be running “in the background” or “as a daemon”."
msgstr "“Демон” - это процесс, запускаемый автоматически в последовательности загрузки. Он продолжает работать (в фоновом режиме), выполняя задачи по обслуживанию или предоставлению сервисов другим процессам. Эти “фоновые задачи” на самом деле произвольны, и не соответствуют ничему конкретному, с точки зрения системы. Это просто процессы, очень похожие на другие процессы, которые выполняются в свои промежутки времени. Различие состоит только в человеческом языке: процесс, который выполняется без взаимодействия с пользователем (в частности, без графического интерфейса) называется “выполняющимся в фоновом режиме” или “демоном”."

msgid "<emphasis>VOCABULARY</emphasis> Daemon, demon, a derogatory term?"
msgstr "<emphasis>СЛОВАРЬ</emphasis> Daemon, demon, уничижительный термин?"

msgid "Although <emphasis>daemon</emphasis> term shares its Greek etymology with <emphasis>demon</emphasis>, the former does not imply diabolical evil, instead, it should be understood as a kind of helper spirit. This distinction is subtle enough in English; it is even worse in other languages where the same word is used for both meanings."
msgstr "Хотя термин <emphasis>daemon</emphasis> разделяет его Греческую этимологию с <emphasis>demon</emphasis>, первый не подразумевает дьявольское зло, вместо этого, следует воспринимать его как своего рода вспомогательного духа. Это различие достаточно тонко в английском языке; и еще хуже в других языках, где то же самое слово используется для обоих значений."

msgid "Several such daemons are described in detail in <xref linkend=\"unix-services\" />."
msgstr "Несколько таких демонов подробно описаны в <xref linkend=\"unix-services\" />."

msgid "Inter-Process Communications"
msgstr "Межпроцессное взаимодействие"

msgid "<primary>IPC</primary>"
msgstr "<primary>IPC</primary>"

msgid "<primary>Inter-Process Communications</primary>"
msgstr "<primary>Межпроцессное взаимодействие</primary>"

msgid "An isolated process, whether a daemon or an interactive application, is rarely useful on its own, which is why there are several methods allowing separate processes to communicate together, either to exchange data or to control one another. The generic term referring to this is <emphasis>inter-process communication</emphasis>, or IPC for short."
msgstr "Изолированный процесс, демон или интерактивное приложение, редко бывает полезным сам по себе, поэтому существует несколько методов, позволяющих отдельным процессам взаимодействовать друг с другом для обмена данными или управления друг другом. Общий термин обозначающий их - <emphasis>межпроцессное взаимодействие</emphasis>, или коротко IPC (от англ. Inter-Process Communication)."

msgid "The simplest IPC system is to use files. The process that wishes to send data writes it into a file (with a name known in advance), while the recipient only has to open the file and read its contents."
msgstr "Простейшая система IPC - использование файлов. Процесс, желающий передать данные, пишет их в файл (с заранее известным именем), при этом получатель только открывает файл и читает его содержимое."

msgid "<primary><emphasis>pipe</emphasis></primary>"
msgstr "<primary><emphasis>канал</emphasis></primary>"

msgid "In the case where you do not wish to store data on disk, you can use a <emphasis>pipe</emphasis>, which is simply an object with two ends; bytes written in one end are readable at the other. If the ends are controlled by separate processes, this leads to a simple and convenient inter-process communication channel. Pipes can be classified into two categories: named pipes, and anonymous pipes. A named pipe is represented by an entry on the filesystem (although the transmitted data is not stored there), so both processes can open it independently if the location of the named pipe is known beforehand. In cases where the communicating processes are related (for instance, a parent and its child process), the parent process can also create an anonymous pipe before forking, and the child inherits it. Both processes will then be able to exchange data through the pipe without needing the filesystem."
msgstr "В случае, когда вы не хотите сохранять данные на диск, вы можете использовать <emphasis>канал</emphasis>, который является простым объектом с двумя концами; байты, написанные в одном конце, доступны для чтения на другом. Это простой и удобный способ межпроцессного взаимодействия, т.к. концы управляются отдельными процессами. Каналы могут быть разделены на две категории: именованные и анонимные. Именованный канал представляет собой запись в файловой системе (хотя передаваемые данные не хранятся там), так оба процесса могут самостоятельно открыть его, если расположение именованного канала заранее известно. В тех случаях, когда взаимодействующие процессы связаны между собой (например, родительский и дочерний процессы), родительский процесс также может создать анонимный канал перед тем как \"форкнется\", а дочерний процесс наследует его. Таким образом оба процесса могут обмениваться данными через канал без необходимости задействовать файловую систему."

msgid "<emphasis>IN PRACTICE</emphasis> A concrete example"
msgstr "<emphasis>НА ПРАКТИКЕ</emphasis> Конкретный пример"

msgid "Let's describe in some detail what happens when a complex command (a <emphasis>pipeline</emphasis>) is run from a shell. We assume we have a <command>bash</command> process (the standard user shell on Debian), with <emphasis>pid</emphasis> 4374; into this shell, we type the command: <command>ls | sort</command> ."
msgstr "Давайте опишем подробнее, что происходит когда составная команда (<emphasis>конвейер</emphasis>) запускается в оболочке. Мы предполагаем, что у нас есть процесс <command>bash</command> (стандартная оболочка в Debian), с <emphasis>pid</emphasis> 4374; в этой оболочке мы вводим команду: <command>ls | sort</command>."

msgid "The shell first interprets the command typed in. In our case, it understands there are two programs (<command>ls</command> and <command>sort</command>), with a data stream flowing from one to the other (denoted by the <userinput>|</userinput> character, known as <emphasis>pipe</emphasis>). <command>bash</command> first creates an unnamed pipe (which initially exists only within the <command>bash</command> process itself)."
msgstr "Вначале оболочка интерпретирует введенную команду. В нашем случае, он понимает, что это две программы (<command>ls</command> и <command>sort</command>) с потоком данных, идущим из одного в другой (обозначается знаком <userinput>|</userinput>, известным как <emphasis>канал</emphasis>). Сначала <command>bash</command> создает анонимный канал (который изначально существует только в рамках самого процесса <command>bash</command>)."

msgid "Then the shell clones itself; this leads to a new <command>bash</command> process, with <emphasis>pid</emphasis> #4521 (<emphasis>pids</emphasis> are abstract numbers, and generally have no particular meaning). Process #4521 inherits the pipe, which means it is able to write in its “input” side; <command>bash</command> redirects its standard output stream to this pipe's input. Then it executes (and replaces itself with) the <command>ls</command> program, which lists the contents of the current directory. Since <command>ls</command> writes on its standard output, and this output has previously been redirected, the results are effectively sent into the pipe."
msgstr "Потом оболочка клонирует себя; это создает новый процесс <command>bash</command> с <emphasis>pid</emphasis> #4521 (<emphasis>идентификаторы процессов</emphasis> - абстрактные номера, обычно не имеющие конкретного смысла). Процесс #4521 наследует канал, что означает, что он может писать в его “входную” часть; <command>bash</command> перенаправляет его стандартный поток вывода во вход этого канала. Затем он выполняет программу <command>ls</command> (и заменяет себя на нее), которая выводит список содержимого текущего каталога. Так как <command>ls</command> пишет в свой стандартный вывод, а этот вывод был заранее перенаправлен, результат эффективно отправляется в канал."

msgid "A similar operation happens for the second command: <command>bash</command> clones itself again, leading to a new <command>bash</command> process with pid #4522. Since it is also a child process of #4374, it also inherits the pipe; <command>bash</command> then connects its standard input to the pipe output, then executes (and replaces itself with) the <command>sort</command> command, which sorts its input and displays the results."
msgstr "Похожая операция происходит и со второй командой: <command>bash</command> клонирует себя снова, что создает новый процесс <command>bash</command> с pid #4522. Так как это тоже дочерний процесс #4374, он также наследует канал; затем <command>bash</command> соединяет его стандартный ввод с выходом канала, выполняет команду <command>sort</command> (и заменяет себя на нее), которая сортирует ее входные данные и выводит результат."

msgid "All the pieces of the puzzle are now set up: <command>ls</command> reads the current directory and writes the list of files into the pipe; <command>sort</command> reads this list, sorts it alphabetically, and displays the results. Processes numbers #4521 and #4522 then terminate, and #4374 (which was waiting for them during the operation), resumes control and displays the prompt to allow the user to type in a new command."
msgstr "Теперь все кусочки головоломки собраны воедино: <command>ls</command> читает текущую директорию и пишет список файлов в канал; <command>sort</command> читает этот список, сортирует его в алфавитном порядке и выводит результат. Затем процессы с номерами #4521 и #4522 завершаются, а #4374 (который ждал их во время операции) возобновляет управление и выводит приглашение, позволяющее пользователю ввести новую команду."

msgid "Not all inter-process communications are used to move data around, though. In many situations, the only information that needs to be transmitted are control messages such as “pause execution” or “resume execution”. Unix (and Linux) provides a mechanism known as <emphasis>signals</emphasis>, through which a process can simply send a specific signal (chosen from a predefined list of signals) to another process. The only requirement is to know the <emphasis>pid</emphasis> of the target."
msgstr "Однако, межпроцессное взаимодействие используется не только для передачи данных. Во многих ситуациях, единственная информация, которую нужно передать:  это управляющие сообщения такие как “приостановить выполнения” или “возобновить выполнение”. Unix (и Linux) предоставляют механизм, известный как <emphasis>сигналы</emphasis>, через которые процесс может легко отправлять другому процессу специальные сигналы, выбранные из определенного списка. Необходимо лишь знать <emphasis>pid</emphasis> целевого процесса."

msgid "For more complex communications, there are also mechanisms allowing a process to open access, or share, part of its allocated memory to other processes. Memory now shared between them can be used to move data between the processes."
msgstr "Для более сложного взаимодействия существует механизм, предоставляющий процессу возможность открыть доступ (полностью или частично) к своей выделенной памяти другому процессу. Эта память может использоваться процессами для обмена данными между ними."

msgid "Finally, network connections can also help processes communicate; these processes can even be running on different computers, possibly thousands of kilometers apart."
msgstr "Наконец, сетевое подключение может также помогать процессам взаимодействовать друг с другом; причем, эти процессы могут быть запущенны на разных компьютерах и находиться в тысячах километров друг от друга."

msgid "It is quite standard for a typical Unix-like system to make use of all these mechanisms to various degrees."
msgstr "Это нормально для Unix-подобных систем: использовать все эти механизмы в разной степени."

msgid "Libraries"
msgstr "Библиотеки"

msgid "<primary>library (of functions)</primary>"
msgstr "<primary>библиотека (функций)</primary>"

msgid "Function libraries play a crucial role in a Unix-like operating system. They are not proper programs, since they cannot be executed on their own, but collections of code fragments that can be used by standard programs. Among the common libraries, you can find:"
msgstr "Библиотеки функций играют решающую роль в Unix-подобных операционных системах. Они не являются программами (они не могут быть выполнены самостоятельно), а представляют собой фрагменты кода, которые могут быть использованы обычными программами. Среди общих библиотек вы можете найти:"

msgid "the standard C library (<emphasis>glibc</emphasis>), which contains basic functions such as ones to open files or network connections, and others facilitating interactions with the kernel;"
msgstr "стандартная библиотека C (<emphasis>glibc</emphasis>), содержащая базовые функции, такие как функции открывания файлов, сетевого соединения, и другие облегчающие взаимодействие с ядром функции;"

msgid "graphical toolkits, such as Gtk+ and Qt, allowing many programs to reuse the graphical objects they provide;"
msgstr "графические инструментарии (такие как Gtk+ и Qt) позволяют множеству программ многократно использовать поддерживаемые ими графические объекты;"

msgid "the <emphasis>libpng</emphasis> library, that allows loading, interpreting and saving images in the PNG format."
msgstr "библиотека <emphasis>libpng</emphasis>, позволяющая загружать, интерпретировать и сохранять изображения в формате PNG."

msgid "Thanks to those libraries, applications can reuse existing code. Application development is simplified since many applications can reuse the same functions. With libraries often developed by different persons, the global development of the system is closer to Unix's historical philosophy."
msgstr "Благодаря этим библиотекам, приложения могут многократно использовать уже существующий код. Разработка приложений упрощается, т.к. множество приложений может использовать одни и те же функции. С библиотеками, часто разрабатываемыми разными людьми, глобальная разработка системы становится ближе к исторической философии Unix."

msgid "<emphasis>CULTURE</emphasis> The Unix Way: one thing at a time"
msgstr "<emphasis>КУЛЬТУРА</emphasis> Путь Unix: что-то одно"

msgid "One of the fundamental concepts that underlies the Unix family of operating systems is that each tool should only do one thing, and do it well; applications can then reuse these tools to build more advanced logic on top. This philosophy can be seen in many incarnations. Shell scripts may be the best example: they assemble complex sequences of very simple tools (such as <command>grep</command>, <command>wc</command>, <command>sort</command>, <command>uniq</command> and so on). Another implementation of this philosophy can be seen in code libraries: the <emphasis>libpng</emphasis> library allows reading and writing PNG images, with different options and in different ways, but it does only that; no question of including functions that display or edit images."
msgstr "Одна из фундаментальных концепций, лежащих в основе семейства операционных систем Unix гласит: \"каждый инструмент должен делать только одну вещь, и делать её хорошо; приложения могут впоследствии использовать эти инструменты для строительства в итоге более продвинутой логики\". Эта философия просматривается во множестве воплощений. Скрипты оболочки могут быть лучшим примером: они собирают сложные последовательности из очень простых инструментов (таких как <command>grep</command>, <command>wc</command>, <command>sort</command>, <command>uniq</command> и т.д.). Еще одной реализацией этой философии являются библиотеки кода: библиотека <emphasis>libpng</emphasis> позволяет считывать и записывать изображения в формате PNG с разными опциями и различными путями, но она делает только это; нет необходимости в функциях отображения или редактирования изображения."

msgid "Moreover, these libraries are often referred to as “shared libraries”, since the kernel is able to only load them into memory once, even if several processes use the same library at the same time. This allows saving memory, when compared with the opposite (hypothetical) situation where the code for a library would be loaded as many times as there are processes using it."
msgstr "Кроме того, эти библиотеки часто называют “общими библиотеками”, так как ядро может загружать их в память единожды, тогда как несколько процессов будут использовать эти библиотеки одновременно. Это позволяет экономить память, в сравнении с обратной (гипотетической) ситуацией, когда код библиотеки будет загружаться в память столько раз, сколько процессов его использует."
